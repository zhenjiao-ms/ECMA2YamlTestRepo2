### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.Contracts.Contract
  id: Contract
  children:
  - System.Diagnostics.Contracts.Contract.Assert(System.Boolean)
  - System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)
  - System.Diagnostics.Contracts.Contract.Assume(System.Boolean)
  - System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)
  - System.Diagnostics.Contracts.Contract.ContractFailed
  - System.Diagnostics.Contracts.Contract.EndContractBlock
  - System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)
  - System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)
  - System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)
  - System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)
  - System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})
  - System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable`1,System.Predicate`1)
  - System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})
  - System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable`1,System.Predicate`1)
  - System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)
  - System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)
  - System.Diagnostics.Contracts.Contract.OldValue``1(``0)
  - System.Diagnostics.Contracts.Contract.Requires(System.Boolean)
  - System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)
  - System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)
  - System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)
  - System.Diagnostics.Contracts.Contract.Result``1
  - System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)
  langs:
  - csharp
  name: Contract
  nameWithType: Contract
  fullName: System.Diagnostics.Contracts.Contract
  type: Class
  summary: Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.
  remarks: "Code contract classes let you specify preconditions, postconditions, and object invariants in your code. Preconditions are requirements that must be met when entering a method or property. Postconditions describe expectations at the time the method or property code exits. Object invariants describe the expected state for a class that has no condition problems. For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/add/includes/ajax-current-ext-md.md).  \n  \n For tools and detailed instructions for using code contracts, see [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.  \n  \n> [!IMPORTANT]\n>  You must use a binary rewriter to insert run-time enforcement of contracts. Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=fullName> method can only be tested statically and will not throw exceptions during run time if a contract is violated. You can download the binary rewriter CCRewrite from [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site. CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page. The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/add/includes/vs-dev10-long-md.md)] or the Windows SDK."
  syntax:
    content: public static class Contract
  inheritance:
  - System.Object
  implements: []
  inheritedMembers:
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Assert(System.Boolean)
  id: Assert(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Assert(Boolean)
  nameWithType: Contract.Assert(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Assert(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Checks for a condition; if the condition is `false`, follows the escalation policy set for the analyzer.
  remarks: The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached. Optionally, the analyzer can be instructed to throw an exception.
  syntax:
    content: public static void Assert (bool condition);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to test.
  overload: System.Diagnostics.Contracts.Contract.Assert*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)
  id: Assert(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Assert(Boolean,String)
  nameWithType: Contract.Assert(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Assert(Boolean,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Checks for a condition; if the condition is `false`, follows the escalation policy set by the analyzer and displays the specified message.
  remarks: The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached. Optionally, the analyzer can be instructed to throw an exception. The `userMessage` parameter is passed to the debugger output. If `userMessage` is not a constant string literal, tools may not be able to read it.
  syntax:
    content: public static void Assert (bool condition, string userMessage);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to test.
    - id: userMessage
      type: System.String
      description: A message to display if the condition is not met.
  overload: System.Diagnostics.Contracts.Contract.Assert*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Assume(System.Boolean)
  id: Assume(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Assume(Boolean)
  nameWithType: Contract.Assume(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Assume(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Instructs code analysis tools to assume that the specified condition is `true`, even if it cannot be statically proven to always be `true`.
  remarks: At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.
  syntax:
    content: public static void Assume (bool condition);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to assume `true`.
  overload: System.Diagnostics.Contracts.Contract.Assume*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)
  id: Assume(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Assume(Boolean,String)
  nameWithType: Contract.Assume(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Assume(Boolean,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Instructs code analysis tools to assume that a condition is `true`, even if it cannot be statically proven to always be `true`, and displays a message if the assumption fails.
  remarks: "If `userMessage` is not a constant string literal, the contract may not be understood by tools.  \n  \n At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method."
  syntax:
    content: public static void Assume (bool condition, string userMessage);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to assume `true`.
    - id: userMessage
      type: System.String
      description: The message to post if the assumption fails.
  overload: System.Diagnostics.Contracts.Contract.Assume*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.ContractFailed
  id: ContractFailed
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: ContractFailed
  nameWithType: Contract.ContractFailed
  fullName: System.Diagnostics.Contracts.Contract.ContractFailed
  type: Event
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Occurs when a contract fails.
  remarks: "The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=fullName> object that is passed to the event handler. This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed. Before doing so, it will raise an event that an application can handle as it sees fit. For example, if code is being run in a testing framework, you can log a test failure and then end the test.  \n  \n The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the ContractFailed event. Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments. If any handler sets the failure as handled, the method returns `null` and no further action is taken. Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind. In that case, an exception is thrown after all handlers have executed."
  syntax:
    content: public static event EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs> ContractFailed;
    return:
      type: System.EventHandler{System.Diagnostics.Contracts.ContractFailedEventArgs}
      description: To be added.
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.EndContractBlock
  id: EndContractBlock
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: EndContractBlock()
  nameWithType: Contract.EndContractBlock()
  fullName: System.Diagnostics.Contracts.Contract.EndContractBlock()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Marks the end of the contract section when a method's contracts contain only preconditions in the `if`-`then`-`throw` form.
  remarks: "Most code already contains some parameter validation in the form of `if`-`then`-`throw` code. The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or EndContractBlock.  \n  \n When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements. The EndContractBlock form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires."
  syntax:
    content: public static void EndContractBlock ();
    parameters: []
  overload: System.Diagnostics.Contracts.Contract.EndContractBlock*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)
  id: Ensures(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Ensures(Boolean)
  nameWithType: Contract.Ensures(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Ensures(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Specifies a postcondition contract for the enclosing method or property.
  remarks: "The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.  \n  \n-   This method call must be at the beginning of a method or property, before any other code.  \n  \n-   You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition."
  example:
  - "The following example shows how to use the Ensures method to ensure that an expected value is returned. This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.  \n  \n [!code-vb[ContractExample#3](~/add/codesnippet/visualbasic/m-system.diagnostics.con_5_1.vb)]\n [!code-cs[ContractExample#3](~/add/codesnippet/csharp/m-system.diagnostics.con_5_1.cs)]"
  syntax:
    content: public static void Ensures (bool condition);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to test. The expression may include <xref:System.Diagnostics.Contracts.Contract.OldValue*>, <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn*>, and <xref:System.Diagnostics.Contracts.Contract.Result*> values.
  overload: System.Diagnostics.Contracts.Contract.Ensures*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)
  id: Ensures(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Ensures(Boolean,String)
  nameWithType: Contract.Ensures(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Ensures(Boolean,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Specifies a postcondition contract for a provided exit condition and a message to display if the condition is `false`.
  remarks: "The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.  \n  \n-   This method call must be at the beginning of a method or property, before any other code.  \n  \n-   This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.  \n  \n-   You must use the binary rewriter (available at [Code Contracts](http://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.  \n  \n-   If `userMessage` is not a constant string literal, the contract may not be understood by tools."
  syntax:
    content: public static void Ensures (bool condition, string userMessage);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to test. The expression may include <xref:System.Diagnostics.Contracts.Contract.OldValue*> and <xref:System.Diagnostics.Contracts.Contract.Result*> values.
    - id: userMessage
      type: System.String
      description: The message to display if the expression is not `true`.
  overload: System.Diagnostics.Contracts.Contract.Ensures*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)
  id: EnsuresOnThrow``1(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: EnsuresOnThrow(Boolean)
  nameWithType: Contract.EnsuresOnThrow(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.EnsuresOnThrow(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: 'public static void EnsuresOnThrow<TException> (bool condition) where TException : Exception;'
    parameters:
    - id: condition
      type: System.Boolean
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.EnsuresOnThrow<TException>*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)
  id: EnsuresOnThrow``1(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: EnsuresOnThrow(Boolean,String)
  nameWithType: Contract.EnsuresOnThrow(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.EnsuresOnThrow(Boolean,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: 'public static void EnsuresOnThrow<TException> (bool condition, string userMessage) where TException : Exception;'
    parameters:
    - id: condition
      type: System.Boolean
      description: To be added.
    - id: userMessage
      type: System.String
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.EnsuresOnThrow<TException>*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})
  id: Exists(System.Int32,System.Int32,System.Predicate{System.Int32})
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Exists(Int32,Int32,Predicate<Int32>)
  nameWithType: Contract.Exists(Int32,Int32,Predicate<Int32>)
  fullName: System.Diagnostics.Contracts.Contract.Exists(Int32,Int32,Predicate<Int32>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Determines whether a specified test is true for any integer within a range of integers.
  remarks: The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0. For example, it would be set to 5 for integers 0 through 4.
  syntax:
    content: public static bool Exists (int fromInclusive, int toExclusive, Predicate<int> predicate);
    parameters:
    - id: fromInclusive
      type: System.Int32
      description: The first integer to pass to `predicate`.
    - id: toExclusive
      type: System.Int32
      description: One more than the last integer to pass to `predicate`.
    - id: predicate
      type: System.Predicate{System.Int32}
      description: The function to evaluate for any value of the integer in the specified range.
    return:
      type: System.Boolean
      description: '`true` if <code>predicate</code> returns `true` for any integer starting from <code>fromInclusive</code> to <code>toExclusive</code> - 1.'
  overload: System.Diagnostics.Contracts.Contract.Exists*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>predicate</code> is `null`.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>toExclusive </code>is less than <code>fromInclusive</code>.
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable`1,System.Predicate`1)
  id: Exists``1(System.Collections.Generic.IEnumerable`1,System.Predicate`1)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Exists(IEnumerable<T>,Predicate<T>)
  nameWithType: Contract.Exists(IEnumerable<T>,Predicate<T>)
  fullName: System.Diagnostics.Contracts.Contract.Exists(IEnumerable<T>,Predicate<T>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: public static bool Exists<T> (System.Collections.Generic.IEnumerable<T> collection, Predicate<T> predicate);
    parameters:
    - id: collection
      type: System.Collections.Generic.IEnumerable`1
      description: To be added.
    - id: predicate
      type: System.Predicate`1
      description: To be added.
    return:
      type: System.Boolean
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.Exists<T>*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})
  id: ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: ForAll(Int32,Int32,Predicate<Int32>)
  nameWithType: Contract.ForAll(Int32,Int32,Predicate<Int32>)
  fullName: System.Diagnostics.Contracts.Contract.ForAll(Int32,Int32,Predicate<Int32>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Determines whether a particular condition is valid for all integers in a specified range.
  remarks: The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0. For example, it would be set to 5 for integers 0 through 4.
  example:
  - "The following example demonstrates how to use the ForAll method to determine whether an array has a null element.  \n  \n [!code-vb[Contract.ForAllExample#1](~/add/codesnippet/visualbasic/64e9cd2c-6ba1-4449-9e84-_1.vb)]\n [!code-cs[Contract.ForAllExample#1](~/add/codesnippet/csharp/64e9cd2c-6ba1-4449-9e84-_1.cs)]"
  syntax:
    content: public static bool ForAll (int fromInclusive, int toExclusive, Predicate<int> predicate);
    parameters:
    - id: fromInclusive
      type: System.Int32
      description: The first integer to pass to `predicate`.
    - id: toExclusive
      type: System.Int32
      description: One more than the last integer to pass to `predicate`.
    - id: predicate
      type: System.Predicate{System.Int32}
      description: The function to evaluate for the existence of the integers in the specified range.
    return:
      type: System.Boolean
      description: '`true` if <code>predicate</code> returns `true` for all integers starting from <code>fromInclusive</code> to <code>toExclusive</code> - 1.'
  overload: System.Diagnostics.Contracts.Contract.ForAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>predicate</code> is `null`.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>toExclusive </code>is less than <code>fromInclusive</code>.
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable`1,System.Predicate`1)
  id: ForAll``1(System.Collections.Generic.IEnumerable`1,System.Predicate`1)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: ForAll(IEnumerable<T>,Predicate<T>)
  nameWithType: Contract.ForAll(IEnumerable<T>,Predicate<T>)
  fullName: System.Diagnostics.Contracts.Contract.ForAll(IEnumerable<T>,Predicate<T>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: public static bool ForAll<T> (System.Collections.Generic.IEnumerable<T> collection, Predicate<T> predicate);
    parameters:
    - id: collection
      type: System.Collections.Generic.IEnumerable`1
      description: To be added.
    - id: predicate
      type: System.Predicate`1
      description: To be added.
    return:
      type: System.Boolean
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.ForAll<T>*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)
  id: Invariant(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Invariant(Boolean)
  nameWithType: Contract.Invariant(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Invariant(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Specifies an invariant contract for the enclosing method or property.
  remarks: "Invariant contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.  \n  \n-   This contract can be specified only in a dedicated invariant method that is declared on a class. If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.  \n  \n-   This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.  \n  \n-   You must use the binary rewriter for run-time enforcement of this invariant.  \n  \n-   Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol. During run-time checking, invariants are checked at the end of each public method. If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class. This also happens if the class is re-entered because of a call to a method on another class."
  syntax:
    content: public static void Invariant (bool condition);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to test.
  overload: System.Diagnostics.Contracts.Contract.Invariant*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)
  id: Invariant(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Invariant(Boolean,String)
  nameWithType: Contract.Invariant(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Invariant(Boolean,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.
  remarks: "Invariant contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.  \n  \n-   This contract can be specified only in a dedicated invariant method that is declared on a class.  \n  \n-   This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.  \n  \n-   You must use the binary rewriter for run-time enforcement of this invariant.  \n  \n-   Invariants are conditionally defined on the `CONTRACTS FULL` symbol. During run-time checking, invariants are checked at the end of each public method. If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class. This also happens if the class is re-entered because of a call to a method on another class."
  syntax:
    content: public static void Invariant (bool condition, string userMessage);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to test.
    - id: userMessage
      type: System.String
      description: The message to display if the condition is `false`.
  overload: System.Diagnostics.Contracts.Contract.Invariant*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.OldValue``1(``0)
  id: OldValue``1(``0)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: OldValue(T)
  nameWithType: Contract.OldValue(T)
  fullName: System.Diagnostics.Contracts.Contract.OldValue(T)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: public static T OldValue<T> (T value);
    parameters:
    - id: value
      type: T
      description: To be added.
    return:
      type: T
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.OldValue<T>*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Requires(System.Boolean)
  id: Requires(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Requires(Boolean)
  nameWithType: Contract.Requires(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Requires(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Specifies a precondition contract for the enclosing method or property.
  remarks: "-   This method call must be at the beginning of a method or property, before any other code.  \n  \n-   This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.  \n  \n-   Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=fullName> method when backward compatibility does not force you to throw a particular exception."
  syntax:
    content: public static void Requires (bool condition);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to test.
  overload: System.Diagnostics.Contracts.Contract.Requires*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)
  id: Requires(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Requires(Boolean,String)
  nameWithType: Contract.Requires(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Requires(Boolean,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  summary: Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.
  remarks: "-   This method call must be at the beginning of a method or property, before any other code.  \n  \n-   This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.  \n  \n-   Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=fullName> method when backward compatibility does not force you to throw a particular exception."
  syntax:
    content: public static void Requires (bool condition, string userMessage);
    parameters:
    - id: condition
      type: System.Boolean
      description: The conditional expression to test.
    - id: userMessage
      type: System.String
      description: The message to display if the condition is `false`.
  overload: System.Diagnostics.Contracts.Contract.Requires*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)
  id: Requires``1(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Requires(Boolean)
  nameWithType: Contract.Requires(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Requires(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: 'public static void Requires<TException> (bool condition) where TException : Exception;'
    parameters:
    - id: condition
      type: System.Boolean
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.Requires<TException>*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)
  id: Requires``1(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Requires(Boolean,String)
  nameWithType: Contract.Requires(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Requires(Boolean,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: 'public static void Requires<TException> (bool condition, string userMessage) where TException : Exception;'
    parameters:
    - id: condition
      type: System.Boolean
      description: To be added.
    - id: userMessage
      type: System.String
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.Requires<TException>*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.Result``1
  id: Result``1
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: Result()
  nameWithType: Contract.Result()
  fullName: System.Diagnostics.Contracts.Contract.Result()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: public static T Result<T> ();
    parameters: []
    return:
      type: T
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.Result<T>*
  exceptions: []
  version:
  - netframework-40
- uid: System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)
  id: ValueAtReturn``1(``0@)
  parent: System.Diagnostics.Contracts.Contract
  langs:
  - csharp
  name: ValueAtReturn(T)
  nameWithType: Contract.ValueAtReturn(T)
  fullName: System.Diagnostics.Contracts.Contract.ValueAtReturn(T)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Diagnostics.Contracts
  syntax:
    content: public static T ValueAtReturn<T> (out T value);
    parameters:
    - id: value
      type: T
      description: To be added.
    return:
      type: T
      description: To be added.
  overload: System.Diagnostics.Contracts.Contract.ValueAtReturn<T>*
  exceptions: []
  version:
  - netframework-40
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  parent: System
  isExternal: false
  name: ArgumentNullException
  nameWithType: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  nameWithType: ArgumentException
  fullName: System.ArgumentException
- uid: System.Diagnostics.Contracts.Contract.Assert(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Assert(Boolean)
  nameWithType: Contract.Assert(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Assert(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Assert(Boolean,String)
  nameWithType: Contract.Assert(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Assert(Boolean,String)
- uid: System.String
  parent: System
  isExternal: false
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.Contracts.Contract.Assume(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Assume(Boolean)
  nameWithType: Contract.Assume(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Assume(Boolean)
- uid: System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Assume(Boolean,String)
  nameWithType: Contract.Assume(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Assume(Boolean,String)
- uid: System.Diagnostics.Contracts.Contract.ContractFailed
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: ContractFailed
  nameWithType: Contract.ContractFailed
  fullName: System.Diagnostics.Contracts.Contract.ContractFailed
- uid: System.EventHandler{System.Diagnostics.Contracts.ContractFailedEventArgs}
  parent: System
  isExternal: false
  name: EventHandler<ContractFailedEventArgs>
  nameWithType: EventHandler<ContractFailedEventArgs>
  fullName: System.EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Diagnostics.Contracts.ContractFailedEventArgs
    name: ContractFailedEventArgs
    nameWithType: ContractFailedEventArgs
    fullName: ContractFailedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Diagnostics.Contracts.Contract.EndContractBlock
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: EndContractBlock()
  nameWithType: Contract.EndContractBlock()
  fullName: System.Diagnostics.Contracts.Contract.EndContractBlock()
- uid: System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Ensures(Boolean)
  nameWithType: Contract.Ensures(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Ensures(Boolean)
- uid: System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Ensures(Boolean,String)
  nameWithType: Contract.Ensures(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Ensures(Boolean,String)
- uid: System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: EnsuresOnThrow(Boolean)
  nameWithType: Contract.EnsuresOnThrow(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.EnsuresOnThrow(Boolean)
- uid: System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: EnsuresOnThrow(Boolean,String)
  nameWithType: Contract.EnsuresOnThrow(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.EnsuresOnThrow(Boolean,String)
- uid: System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Exists(Int32,Int32,Predicate<Int32>)
  nameWithType: Contract.Exists(Int32,Int32,Predicate<Int32>)
  fullName: System.Diagnostics.Contracts.Contract.Exists(Int32,Int32,Predicate<Int32>)
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Predicate{System.Int32}
  parent: System
  isExternal: false
  name: Predicate<Int32>
  nameWithType: Predicate<Int32>
  fullName: System.Predicate<System.Int32>
  spec.csharp:
  - uid: System.Predicate`1
    name: Predicate
    nameWithType: Predicate
    fullName: Predicate<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable`1,System.Predicate`1)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Exists(IEnumerable<T>,Predicate<T>)
  nameWithType: Contract.Exists(IEnumerable<T>,Predicate<T>)
  fullName: System.Diagnostics.Contracts.Contract.Exists(IEnumerable<T>,Predicate<T>)
- uid: System.Collections.Generic.IEnumerable`1
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
- uid: System.Predicate`1
  parent: System
  isExternal: false
  name: Predicate<T>
  nameWithType: Predicate<T>
  fullName: System.Predicate<T>
- uid: System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: ForAll(Int32,Int32,Predicate<Int32>)
  nameWithType: Contract.ForAll(Int32,Int32,Predicate<Int32>)
  fullName: System.Diagnostics.Contracts.Contract.ForAll(Int32,Int32,Predicate<Int32>)
- uid: System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable`1,System.Predicate`1)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: ForAll(IEnumerable<T>,Predicate<T>)
  nameWithType: Contract.ForAll(IEnumerable<T>,Predicate<T>)
  fullName: System.Diagnostics.Contracts.Contract.ForAll(IEnumerable<T>,Predicate<T>)
- uid: System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Invariant(Boolean)
  nameWithType: Contract.Invariant(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Invariant(Boolean)
- uid: System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Invariant(Boolean,String)
  nameWithType: Contract.Invariant(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Invariant(Boolean,String)
- uid: System.Diagnostics.Contracts.Contract.OldValue``1(``0)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: OldValue(T)
  nameWithType: Contract.OldValue(T)
  fullName: System.Diagnostics.Contracts.Contract.OldValue(T)
- uid: T
  isExternal: true
  name: T
  nameWithType: T
  fullName: T
- uid: System.Diagnostics.Contracts.Contract.Requires(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Requires(Boolean)
  nameWithType: Contract.Requires(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Requires(Boolean)
- uid: System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Requires(Boolean,String)
  nameWithType: Contract.Requires(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Requires(Boolean,String)
- uid: System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Requires(Boolean)
  nameWithType: Contract.Requires(Boolean)
  fullName: System.Diagnostics.Contracts.Contract.Requires(Boolean)
- uid: System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Requires(Boolean,String)
  nameWithType: Contract.Requires(Boolean,String)
  fullName: System.Diagnostics.Contracts.Contract.Requires(Boolean,String)
- uid: System.Diagnostics.Contracts.Contract.Result``1
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Result()
  nameWithType: Contract.Result()
  fullName: System.Diagnostics.Contracts.Contract.Result()
- uid: System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: ValueAtReturn(T)
  nameWithType: Contract.ValueAtReturn(T)
  fullName: System.Diagnostics.Contracts.Contract.ValueAtReturn(T)
- uid: System.Diagnostics.Contracts.Contract.Assert*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Assert
  nameWithType: Contract.Assert
- uid: System.Diagnostics.Contracts.Contract.Assume*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Assume
  nameWithType: Contract.Assume
- uid: System.Diagnostics.Contracts.Contract.EndContractBlock*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: EndContractBlock
  nameWithType: Contract.EndContractBlock
- uid: System.Diagnostics.Contracts.Contract.Ensures*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Ensures
  nameWithType: Contract.Ensures
- uid: System.Diagnostics.Contracts.Contract.EnsuresOnThrow<TException>*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: EnsuresOnThrow<TException>
  nameWithType: Contract.EnsuresOnThrow<TException>
- uid: System.Diagnostics.Contracts.Contract.Exists*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Exists
  nameWithType: Contract.Exists
- uid: System.Diagnostics.Contracts.Contract.Exists<T>*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Exists<T>
  nameWithType: Contract.Exists<T>
- uid: System.Diagnostics.Contracts.Contract.ForAll*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: ForAll
  nameWithType: Contract.ForAll
- uid: System.Diagnostics.Contracts.Contract.ForAll<T>*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: ForAll<T>
  nameWithType: Contract.ForAll<T>
- uid: System.Diagnostics.Contracts.Contract.Invariant*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Invariant
  nameWithType: Contract.Invariant
- uid: System.Diagnostics.Contracts.Contract.OldValue<T>*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: OldValue<T>
  nameWithType: Contract.OldValue<T>
- uid: System.Diagnostics.Contracts.Contract.Requires*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Requires
  nameWithType: Contract.Requires
- uid: System.Diagnostics.Contracts.Contract.Requires<TException>*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Requires<TException>
  nameWithType: Contract.Requires<TException>
- uid: System.Diagnostics.Contracts.Contract.Result<T>*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: Result<T>
  nameWithType: Contract.Result<T>
- uid: System.Diagnostics.Contracts.Contract.ValueAtReturn<T>*
  parent: System.Diagnostics.Contracts.Contract
  isExternal: false
  name: ValueAtReturn<T>
  nameWithType: Contract.ValueAtReturn<T>
