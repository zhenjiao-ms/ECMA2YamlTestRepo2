### YamlMime:ManagedReference
items:
- uid: System.Reflection.Emit.TypeBuilder
  id: TypeBuilder
  children:
  - System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)
  - System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)
  - System.Reflection.Emit.TypeBuilder.Assembly
  - System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
  - System.Reflection.Emit.TypeBuilder.BaseType
  - System.Reflection.Emit.TypeBuilder.CreateType
  - System.Reflection.Emit.TypeBuilder.DeclaringMethod
  - System.Reflection.Emit.TypeBuilder.DeclaringType
  - System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])
  - System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)
  - System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
  - System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  - System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  - System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  - System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  - System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  - System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  - System.Reflection.Emit.TypeBuilder.DefineTypeInitializer
  - System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)
  - System.Reflection.Emit.TypeBuilder.FullName
  - System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
  - System.Reflection.Emit.TypeBuilder.GenericParameterPosition
  - System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl
  - System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)
  - System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)
  - System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)
  - System.Reflection.Emit.TypeBuilder.GetElementType
  - System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetEvents
  - System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)
  - System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetGenericArguments
  - System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition
  - System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)
  - System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)
  - System.Reflection.Emit.TypeBuilder.GetInterfaces
  - System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)
  - System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)
  - System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.Emit.TypeBuilder.GUID
  - System.Reflection.Emit.TypeBuilder.HasElementTypeImpl
  - System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  - System.Reflection.Emit.TypeBuilder.IsArrayImpl
  - System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)
  - System.Reflection.Emit.TypeBuilder.IsByRefImpl
  - System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl
  - System.Reflection.Emit.TypeBuilder.IsCreated
  - System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)
  - System.Reflection.Emit.TypeBuilder.IsGenericParameter
  - System.Reflection.Emit.TypeBuilder.IsGenericType
  - System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
  - System.Reflection.Emit.TypeBuilder.IsPointerImpl
  - System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl
  - System.Reflection.Emit.TypeBuilder.IsSecurityCritical
  - System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical
  - System.Reflection.Emit.TypeBuilder.IsSecurityTransparent
  - System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)
  - System.Reflection.Emit.TypeBuilder.MakeArrayType
  - System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)
  - System.Reflection.Emit.TypeBuilder.MakeByRefType
  - System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  - System.Reflection.Emit.TypeBuilder.MakePointerType
  - System.Reflection.Emit.TypeBuilder.Module
  - System.Reflection.Emit.TypeBuilder.Name
  - System.Reflection.Emit.TypeBuilder.Namespace
  - System.Reflection.Emit.TypeBuilder.PackingSize
  - System.Reflection.Emit.TypeBuilder.ReflectedType
  - System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  - System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])
  - System.Reflection.Emit.TypeBuilder.SetParent(System.Type)
  - System.Reflection.Emit.TypeBuilder.Size
  - System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)
  - System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Reflection.Emit.TypeBuilder.ToString
  - System.Reflection.Emit.TypeBuilder.TypeHandle
  - System.Reflection.Emit.TypeBuilder.TypeToken
  - System.Reflection.Emit.TypeBuilder.UnderlyingSystemType
  - System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
  langs:
  - csharp
  name: TypeBuilder
  nameWithType: TypeBuilder
  fullName: System.Reflection.Emit.TypeBuilder
  type: Class
  summary: Defines and creates new instances of classes during run time.
  remarks: "TypeBuilder is the root class used to control the creation of dynamic classes in the runtime. It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module. A new TypeBuilder can be created from a dynamic module by calling the <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=fullName> method, which returns a TypeBuilder object.  \n  \n Reflection emit provides the following options for defining types:  \n  \n-   Define a class or interface with the given name.  \n  \n-   Define a class or interface with the given name and attributes.  \n  \n-   Define a class with the given name, attributes, and base class.  \n  \n-   Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.  \n  \n-   Define a class with the given name, attributes, base class, and packing size.  \n  \n-   Define a class with the given name, attributes, base class, and the class size as a whole.  \n  \n-   Define a class with the given name, attributes, base class, packing size, and the class size as a whole.  \n  \n To create an array type, pointer type, or byref type for an incomplete type that is represented by a TypeBuilder object, use the <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method, or <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method, respectively.  \n  \n Before a type is used, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=fullName> method must be called. **CreateType** completes the creation of the type. Following the call to **CreateType**, the caller can instantiate the type by using the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method, and invoke members of the type by using the <xref:System.Type.InvokeMember%2A?displayProperty=fullName> method. It is an error to invoke methods that change the implementation of a type after **CreateType** has been called. For example, the common language runtime throws an exception if the caller tries to add new members to a type.  \n  \n A class initializer is created by using the <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=fullName> method. **DefineTypeInitializer** returns a <xref:System.Reflection.Emit.ConstructorBuilder> object.  \n  \n Nested types are defined by calling one of the <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=fullName> methods.  \n  \n## Attributes  \n The TypeBuilder class uses the <xref:System.Reflection.TypeAttributes> enumeration to further specify the characteristics of the type to be created:  \n  \n-   Interfaces are specified using the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> attributes.  \n  \n-   Concrete classes (classes that cannot be extended) are specified using the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> attribute.  \n  \n-   Several attributes determine type visibility. See the description of the <xref:System.Reflection.TypeAttributes> enumeration.  \n  \n-   If <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is specified, the class loader lays out fields in the order they are read from metadata. The class loader considers the specified packing size but ignores any specified field offsets. The metadata preserves the order in which the field definitions are emitted. Even across a merge, the metadata will not reorder the field definitions. The loader will honor the specified field offsets only if <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is specified.  \n  \n## Known Issues  \n  \n-   Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface. However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.  \n  \n-   Although TypeBuilder is derived from <xref:System.Type>, some of the abstract methods defined in the <xref:System.Type> class are not fully implemented in the TypeBuilder class. Calls to these TypeBuilder methods throw a <xref:System.NotSupportedException> exception. The desired functionality can be obtained by retrieving the created type using the <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and reflecting on the retrieved type."
  example:
  - "This section contains two code examples. The first example shows how to create a dynamic type with a field, constructor, property, and method. The second example builds a method dynamically from user input.  \n  \n **Example one**  \n  \n The following code example shows how to define a dynamic assembly with one module. The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.  \n  \n The <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> field is specified when the assembly is created. The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) or used in another program.  \n  \n [!code-vb[AssemblyBuilderClass#1](~/add/codesnippet/visualbasic/t-system.reflection.emit_6_1.vb)]\n [!code-cpp[AssemblyBuilderClass#1](~/add/codesnippet/cpp/t-system.reflection.emit_6_1.cpp)]\n [!code-cs[AssemblyBuilderClass#1](~/add/codesnippet/csharp/t-system.reflection.emit_6_1.cs)]  \n  \n **Example two**  \n  \n The following code sample demonstrates how to build a dynamic type by using `TypeBuilder`.  \n  \n [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/add/codesnippet/cpp/t-system.reflection.emit_6_2.cpp)]\n [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/add/codesnippet/visualbasic/t-system.reflection.emit_6_2.vb)]\n [!code-cs[System.Reflection.Emit ILGenerator Example#1](~/add/codesnippet/csharp/t-system.reflection.emit_6_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class TypeBuilder : Type, System.Runtime.InteropServices._TypeBuilder
  inheritance:
  - System.Object
  - System.Reflection.MemberInfo
  - System.Type
  implements:
  - System.Runtime.InteropServices._TypeBuilder
  inheritedMembers:
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Reflection.MemberInfo.GetCustomAttributesData
  - System.Reflection.MemberInfo.MetadataToken
  - System.Reflection.MemberInfo.op_Equality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)
  - System.Reflection.MemberInfo.op_Inequality(System.Reflection.MemberInfo,System.Reflection.MemberInfo)
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetType
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#GetTypeInfoCount(System.UInt32@)
  - System.Reflection.MemberInfo.System#Runtime#InteropServices#_MemberInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Type.Attributes
  - System.Type.ContainsGenericParameters
  - System.Type.DefaultBinder
  - System.Type.Delimiter
  - System.Type.EmptyTypes
  - System.Type.Equals(System.Object)
  - System.Type.Equals(System.Type)
  - System.Type.FilterAttribute
  - System.Type.FilterName
  - System.Type.FilterNameIgnoreCase
  - System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)
  - System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)
  - System.Type.GetArrayRank
  - System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])
  - System.Type.GetConstructor(System.Type[])
  - System.Type.GetConstructors
  - System.Type.GetDefaultMembers
  - System.Type.GetEnumName(System.Object)
  - System.Type.GetEnumNames
  - System.Type.GetEnumUnderlyingType
  - System.Type.GetEnumValues
  - System.Type.GetEvent(System.String)
  - System.Type.GetField(System.String)
  - System.Type.GetFields
  - System.Type.GetGenericParameterConstraints
  - System.Type.GetHashCode
  - System.Type.GetInterface(System.String)
  - System.Type.GetMember(System.String)
  - System.Type.GetMember(System.String,System.Reflection.BindingFlags)
  - System.Type.GetMembers
  - System.Type.GetMethod(System.String)
  - System.Type.GetMethod(System.String,System.Reflection.BindingFlags)
  - System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])
  - System.Type.GetMethod(System.String,System.Type[])
  - System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])
  - System.Type.GetMethods
  - System.Type.GetNestedType(System.String)
  - System.Type.GetNestedTypes
  - System.Type.GetProperties
  - System.Type.GetProperty(System.String)
  - System.Type.GetProperty(System.String,System.Reflection.BindingFlags)
  - System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  - System.Type.GetProperty(System.String,System.Type)
  - System.Type.GetProperty(System.String,System.Type,System.Type[])
  - System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  - System.Type.GetProperty(System.String,System.Type[])
  - System.Type.GetType
  - System.Type.GetType(System.String)
  - System.Type.GetType(System.String,System.Boolean)
  - System.Type.GetType(System.String,System.Boolean,System.Boolean)
  - System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})
  - System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)
  - System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)
  - System.Type.GetTypeArray(System.Object[])
  - System.Type.GetTypeCode(System.Type)
  - System.Type.GetTypeCodeImpl
  - System.Type.GetTypeFromCLSID(System.Guid)
  - System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)
  - System.Type.GetTypeFromCLSID(System.Guid,System.String)
  - System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)
  - System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)
  - System.Type.GetTypeFromProgID(System.String)
  - System.Type.GetTypeFromProgID(System.String,System.Boolean)
  - System.Type.GetTypeFromProgID(System.String,System.String)
  - System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)
  - System.Type.GetTypeHandle(System.Object)
  - System.Type.HasElementType
  - System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])
  - System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)
  - System.Type.IsAbstract
  - System.Type.IsAnsiClass
  - System.Type.IsArray
  - System.Type.IsAutoClass
  - System.Type.IsAutoLayout
  - System.Type.IsByRef
  - System.Type.IsClass
  - System.Type.IsCOMObject
  - System.Type.IsContextful
  - System.Type.IsContextfulImpl
  - System.Type.IsEnum
  - System.Type.IsEnumDefined(System.Object)
  - System.Type.IsEquivalentTo(System.Type)
  - System.Type.IsExplicitLayout
  - System.Type.IsImport
  - System.Type.IsInstanceOfType(System.Object)
  - System.Type.IsInterface
  - System.Type.IsLayoutSequential
  - System.Type.IsMarshalByRef
  - System.Type.IsMarshalByRefImpl
  - System.Type.IsNested
  - System.Type.IsNestedAssembly
  - System.Type.IsNestedFamANDAssem
  - System.Type.IsNestedFamily
  - System.Type.IsNestedFamORAssem
  - System.Type.IsNestedPrivate
  - System.Type.IsNestedPublic
  - System.Type.IsNotPublic
  - System.Type.IsPointer
  - System.Type.IsPrimitive
  - System.Type.IsPublic
  - System.Type.IsSealed
  - System.Type.IsSerializable
  - System.Type.IsSpecialName
  - System.Type.IsUnicodeClass
  - System.Type.IsValueType
  - System.Type.IsValueTypeImpl
  - System.Type.IsVisible
  - System.Type.MemberType
  - System.Type.Missing
  - System.Type.op_Equality(System.Type,System.Type)
  - System.Type.op_Inequality(System.Type,System.Type)
  - System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)
  - System.Type.StructLayoutAttribute
  - System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)
  - System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Type.TypeInitializer
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)
  id: AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: AddDeclarativeSecurity(SecurityAction,PermissionSet)
  nameWithType: TypeBuilder.AddDeclarativeSecurity(SecurityAction,PermissionSet)
  fullName: System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(SecurityAction,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds declarative security to this type.
  remarks: "`AddDeclarativeSecurity` may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.  \n  \n> [!NOTE]\n>  In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format."
  example:
  - "The following example demonstrates the use of the `AddDeclarativeSecurity` method to add a security demand for <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> flag to a dynamic type named `MyDynamicClass`, in an assembly named EmittedExample.dll. The example produces no console output; after you run it, you can use [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) to examine EmittedExample.dll. In `MyDynamicClass`, open the `.class public auto ansi` statement to see the declarative permission.  \n  \n [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/add/codesnippet/cpp/8b72e3a1-0274-4283-88c1-_1.cpp)]\n [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/add/codesnippet/visualbasic/8b72e3a1-0274-4283-88c1-_1.vb)]\n [!code-cs[TypeBuilder_AddDeclarativeSecurity#1](~/add/codesnippet/csharp/8b72e3a1-0274-4283-88c1-_1.cs)]"
  syntax:
    content: public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);
    parameters:
    - id: action
      type: System.Security.Permissions.SecurityAction
      description: The security action to be taken such as Demand, Assert, and so on.
    - id: pset
      type: System.Security.PermissionSet
      description: The set of permissions the action applies to.
  overload: System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: The <code>action</code> is invalid (<xref uid="langword_csharp_RequestMinimum" name="RequestMinimum" href=""></xref>, <xref uid="langword_csharp_RequestOptional" name="RequestOptional" href=""></xref>, and <xref uid="langword_csharp_RequestRefuse" name="RequestRefuse" href=""></xref> are invalid).
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The containing type has been created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n The permission set <code>pset</code> contains an action that was added earlier by <xref uid=\"langword_csharp_AddDeclarativeSecurity\" name=\"AddDeclarativeSecurity\" href=\"\"></xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>pset</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)
  id: AddInterfaceImplementation(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: AddInterfaceImplementation(Type)
  nameWithType: TypeBuilder.AddInterfaceImplementation(Type)
  fullName: System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds an interface that this type implements.
  remarks: ''
  example:
  - "The following code sample demonstrates the implementation of an interface on a dynamically created type using `AddInterfaceImplementation`.  \n  \n [!code-cs[TypeBuilder_Sample_4#3](~/add/codesnippet/csharp/m-system.reflection.emit_27_1.cs)]\n [!code-vb[TypeBuilder_Sample_4#3](~/add/codesnippet/visualbasic/m-system.reflection.emit_27_1.vb)]\n [!code-cpp[TypeBuilder_Sample_4#3](~/add/codesnippet/cpp/m-system.reflection.emit_27_1.cpp)]"
  syntax:
    content: public void AddInterfaceImplementation (Type interfaceType);
    parameters:
    - id: interfaceType
      type: System.Type
      description: The interface that this type implements.
  overload: System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>interfaceType</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.Assembly
  id: Assembly
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: Assembly
  nameWithType: TypeBuilder.Assembly
  fullName: System.Reflection.Emit.TypeBuilder.Assembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the dynamic assembly that contains this type definition.
  syntax:
    content: public override System.Reflection.Assembly Assembly { get; }
    return:
      type: System.Reflection.Assembly
      description: Read-only. Retrieves the dynamic assembly that contains this type definition.
  overload: System.Reflection.Emit.TypeBuilder.Assembly*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
  id: AssemblyQualifiedName
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: AssemblyQualifiedName
  nameWithType: TypeBuilder.AssemblyQualifiedName
  fullName: System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the full name of this type qualified by the display name of the assembly.
  remarks: "The format of the returned string is the concatenation of the full name of the type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) and the display name of the assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=fullName>), separated by a comma and a space.  \n  \n See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.  \n  \n## Version Information  \n In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key."
  syntax:
    content: public override string AssemblyQualifiedName { get; }
    return:
      type: System.String
      description: Read-only. The full name of this type qualified by the display name of the assembly.
  overload: System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.BaseType
  id: BaseType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: BaseType
  nameWithType: TypeBuilder.BaseType
  fullName: System.Reflection.Emit.TypeBuilder.BaseType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the base type of this type.
  syntax:
    content: public override Type BaseType { get; }
    return:
      type: System.Type
      description: Read-only. Retrieves the base type of this type.
  overload: System.Reflection.Emit.TypeBuilder.BaseType*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.CreateType
  id: CreateType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: CreateType()
  nameWithType: TypeBuilder.CreateType()
  fullName: System.Reflection.Emit.TypeBuilder.CreateType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Creates a <xref href="System.Type"></xref> object for the class. After defining fields and methods on the class, <xref uid="langword_csharp_CreateType" name="CreateType" href=""></xref> is called in order to load its <xref uid="langword_csharp_Type" name="Type" href=""></xref> object.
  remarks: "If this type is a nested type, the CreateType method must be called on the enclosing type before it is called on the nested type.  \n  \n If the current type derives from an incomplete type or implements incomplete interfaces, call the CreateType method on the parent type and the interface types before calling it on the current type.  \n  \n If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the CreateType method on the enclosing type will generate a <xref:System.AppDomain.TypeResolve?displayProperty=fullName> event. This is because the loader cannot determine the size of the enclosing type until the nested type has been completed. The caller should define a handler for the <xref:System.AppDomain.TypeResolve> event to complete the definition of the nested type by calling CreateType on the <xref:System.Reflection.Emit.TypeBuilder> object that represents the nested type. The code example for this topic shows how to define such an event handler.  \n  \n A type is created only once, no matter how many times the CreateType method is called. All calls return the same <xref:System.Type> object."
  example:
  - "The following code example shows how to define an event handler for the <xref:System.AppDomain.TypeResolve?displayProperty=fullName> event, in order to call the CreateType method on a nested type during a CreateType call on the enclosing type.  \n  \n [!code-cs[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/add/codesnippet/csharp/m-system.reflection.emit_0_1.cs)]\n [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/add/codesnippet/cpp/m-system.reflection.emit_0_1.cpp)]\n [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_0_1.vb)]"
  syntax:
    content: public Type CreateType ();
    parameters: []
    return:
      type: System.Type
      description: Returns the new <xref href="System.Type"></xref> object for this class.
  overload: System.Reflection.Emit.TypeBuilder.CreateType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The enclosing type has not been created.  \n  \n -or-  \n  \n This type is non-abstract and contains an abstract method.  \n  \n -or-  \n  \n This type is not an abstract class or an interface and has a method without a method body."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The type contains invalid Microsoft intermediate language (MSIL) code.  \n  \n -or-  \n  \n The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: The type cannot be loaded. For example, it contains a <xref uid="langword_csharp_static" name="static" href=""></xref> method that has the calling convention <xref href="System.Reflection.CallingConventions"></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DeclaringMethod
  id: DeclaringMethod
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DeclaringMethod
  nameWithType: TypeBuilder.DeclaringMethod
  fullName: System.Reflection.Emit.TypeBuilder.DeclaringMethod
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets the method that declared the current generic type parameter.
  remarks: >-
    > [!NOTE]

    >  When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.
  syntax:
    content: public override System.Reflection.MethodBase DeclaringMethod { get; }
    return:
      type: System.Reflection.MethodBase
      description: A <xref href="System.Reflection.MethodBase"></xref> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <xref uid="langword_csharp_null" name="null" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.DeclaringMethod*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DeclaringType
  id: DeclaringType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DeclaringType
  nameWithType: TypeBuilder.DeclaringType
  fullName: System.Reflection.Emit.TypeBuilder.DeclaringType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the type that declared this type.
  syntax:
    content: public override Type DeclaringType { get; }
    return:
      type: System.Type
      description: Read-only. The type that declared this type.
  overload: System.Reflection.Emit.TypeBuilder.DeclaringType*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])
  id: DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineConstructor(MethodAttributes,CallingConventions,Type[])
  nameWithType: TypeBuilder.DefineConstructor(MethodAttributes,CallingConventions,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineConstructor(MethodAttributes,CallingConventions,Type[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new constructor to the type, with the given attributes and signature.
  remarks: "If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.  \n  \n If you define a constructor for your dynamic type, a default constructor is not provided. You have the following options for providing a default constructor in addition to the constructor you defined:  \n  \n-   If you want a default constructor that simply calls the default constructor of the base class, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> method to create one (and optionally restrict access to it). Do not provide an implementation for this default constructor. If you do, an exception is thrown when you try to use the constructor. No exception is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.  \n  \n-   If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the DefineConstructor method to create one, and provide your own implementation."
  example:
  - "The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.  \n  \n [!code-cs[TypeBuilder_Sample_4#2](~/add/codesnippet/csharp/be894ff3-6a0d-4583-bcff-_1.cs)]\n [!code-vb[TypeBuilder_Sample_4#2](~/add/codesnippet/visualbasic/be894ff3-6a0d-4583-bcff-_1.vb)]\n [!code-cpp[TypeBuilder_Sample_4#2](~/add/codesnippet/cpp/be894ff3-6a0d-4583-bcff-_1.cpp)]"
  syntax:
    content: public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);
    parameters:
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the constructor.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The calling convention of the constructor.
    - id: parameterTypes
      type: System.Type[]
      description: The parameter types of the constructor.
    return:
      type: System.Reflection.Emit.ConstructorBuilder
      description: The defined constructor.
  overload: System.Reflection.Emit.TypeBuilder.DefineConstructor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])
  id: DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineConstructor(MethodAttributes,CallingConventions,Type[],Type[][],Type[][])
  nameWithType: TypeBuilder.DefineConstructor(MethodAttributes,CallingConventions,Type[],Type[][],Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineConstructor(MethodAttributes,CallingConventions,Type[],Type[][],Type[][])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.
  remarks: "This overload is provided for designers of managed compilers.  \n  \n> [!NOTE]\n>  For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site."
  syntax:
    content: public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    parameters:
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the constructor.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The calling convention of the constructor.
    - id: parameterTypes
      type: System.Type[]
      description: The parameter types of the constructor.
    - id: requiredCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    - id: optionalCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    return:
      type: System.Reflection.Emit.ConstructorBuilder
      description: The defined constructor.
  overload: System.Reflection.Emit.TypeBuilder.DefineConstructor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The size of <code>requiredCustomModifiers</code> or <code>optionalCustomModifiers</code> does not equal the size of <code>parameterTypes</code>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)
  id: DefineDefaultConstructor(System.Reflection.MethodAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineDefaultConstructor(MethodAttributes)
  nameWithType: TypeBuilder.DefineDefaultConstructor(MethodAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(MethodAttributes)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines the default constructor. The constructor defined here will simply call the default constructor of the parent.
  remarks: "Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:  \n  \n-   You have defined another constructor and you also want a default constructor that simply calls the base class constructor.  \n  \n-   You want to set the attributes on the default constructor to something other than <xref:System.Reflection.MethodAttributes>, <xref:System.Reflection.MethodAttributes>, <xref:System.Reflection.MethodAttributes>, <xref:System.Reflection.MethodAttributes>, and <xref:System.Reflection.MethodAttributes>."
  example:
  - "The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.  \n  \n [!code-cs[TypeBuilder_Sample_4#2](~/add/codesnippet/csharp/094fdf86-59fd-4571-ab9e-_1.cs)]\n [!code-vb[TypeBuilder_Sample_4#2](~/add/codesnippet/visualbasic/094fdf86-59fd-4571-ab9e-_1.vb)]\n [!code-cpp[TypeBuilder_Sample_4#2](~/add/codesnippet/cpp/094fdf86-59fd-4571-ab9e-_1.cpp)]"
  syntax:
    content: public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);
    parameters:
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: A <xref uid="langword_csharp_MethodAttributes" name="MethodAttributes" href=""></xref> object representing the attributes to be applied to the constructor.
    return:
      type: System.Reflection.Emit.ConstructorBuilder
      description: Returns the constructor.
  overload: System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: The parent type (base type) does not have a default constructor.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)
  id: DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineEvent(String,EventAttributes,Type)
  nameWithType: TypeBuilder.DefineEvent(String,EventAttributes,Type)
  fullName: System.Reflection.Emit.TypeBuilder.DefineEvent(String,EventAttributes,Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new event to the type, with the given name, attributes and event type.
  syntax:
    content: public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);
    parameters:
    - id: name
      type: System.String
      description: The name of the event. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.EventAttributes
      description: The attributes of the event.
    - id: eventtype
      type: System.Type
      description: The type of the event.
    return:
      type: System.Reflection.Emit.EventBuilder
      description: The defined event.
  overload: System.Reflection.Emit.TypeBuilder.DefineEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The length of <code>name</code> is zero.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n -or-  \n  \n <code>eventtype</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)
  id: DefineField(System.String,System.Type,System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineField(String,Type,FieldAttributes)
  nameWithType: TypeBuilder.DefineField(String,Type,FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineField(String,Type,FieldAttributes)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new field to the type, with the given name, attributes, and field type.
  syntax:
    content: public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);
    parameters:
    - id: fieldName
      type: System.String
      description: The name of the field. `fieldName` cannot contain embedded nulls.
    - id: type
      type: System.Type
      description: The type of the field
    - id: attributes
      type: System.Reflection.FieldAttributes
      description: The attributes of the field.
    return:
      type: System.Reflection.Emit.FieldBuilder
      description: The defined field.
  overload: System.Reflection.Emit.TypeBuilder.DefineField*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The length of <code>fieldName</code> is zero.  \n  \n -or-  \n  \n <code>type</code> is System.Void.  \n  \n -or-  \n  \n A total size was specified for the parent class of this field."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>fieldName</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)
  id: DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineField(String,Type,Type[],Type[],FieldAttributes)
  nameWithType: TypeBuilder.DefineField(String,Type,Type[],Type[],FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineField(String,Type,Type[],Type[],FieldAttributes)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.
  remarks: This overload is provided for designers of managed compilers.
  syntax:
    content: public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);
    parameters:
    - id: fieldName
      type: System.String
      description: The name of the field. `fieldName` cannot contain embedded nulls.
    - id: type
      type: System.Type
      description: The type of the field
    - id: requiredCustomModifiers
      type: System.Type[]
      description: An array of types representing the required custom modifiers for the field, such as <xref href="Microsoft.VisualC.IsConstModifier"></xref>.
    - id: optionalCustomModifiers
      type: System.Type[]
      description: An array of types representing the optional custom modifiers for the field, such as <xref href="Microsoft.VisualC.IsConstModifier"></xref>.
    - id: attributes
      type: System.Reflection.FieldAttributes
      description: The attributes of the field.
    return:
      type: System.Reflection.Emit.FieldBuilder
      description: The defined field.
  overload: System.Reflection.Emit.TypeBuilder.DefineField*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The length of <code>fieldName</code> is zero.  \n  \n -or-  \n  \n <code>type</code> is System.Void.  \n  \n -or-  \n  \n A total size was specified for the parent class of this field."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>fieldName</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
  id: DefineGenericParameters(System.String[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineGenericParameters(String[])
  nameWithType: TypeBuilder.DefineGenericParameters(String[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineGenericParameters(String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <xref href="System.Reflection.Emit.GenericTypeParameterBuilder"></xref> objects that can be used to set their constraints.
  remarks: Calling this method makes the current type a generic type. If the method is called again on the same type, an <xref:System.InvalidOperationException> is thrown.
  example:
  - "The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll. You can use the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) to view the generated types. For a more detailed explanation of the steps involved in defining a dynamic generic type, see [How to: Define a Generic Type with Reflection Emit](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[EmitGenericType#1](~/add/codesnippet/cpp/m-system.reflection.emit_56_1.cpp)]\n [!code-vb[EmitGenericType#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_56_1.vb)]\n [!code-cs[EmitGenericType#1](~/add/codesnippet/csharp/m-system.reflection.emit_56_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (string[] names);
    parameters:
    - id: names
      type: System.String[]
      description: An array of names for the generic type parameters.
    return:
      type: System.Reflection.Emit.GenericTypeParameterBuilder[]
      description: An array of <xref href="System.Reflection.Emit.GenericTypeParameterBuilder"></xref> objects that can be used to define the constraints of the generic type parameters for the current type.
  overload: System.Reflection.Emit.TypeBuilder.DefineGenericParameters*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: Generic type parameters have already been defined for this type.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>names</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n -or-  \n  \n An element of <code>names</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>names</code> is an empty array.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)
  id: DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineInitializedData(String,Byte[],FieldAttributes)
  nameWithType: TypeBuilder.DefineInitializedData(String,Byte[],FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineInitializedData(String,Byte[],FieldAttributes)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines initialized data field in the .sdata section of the portable executable (PE) file.
  remarks: The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.
  syntax:
    content: public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);
    parameters:
    - id: name
      type: System.String
      description: The name used to refer to the data. `name` cannot contain embedded nulls.
    - id: data
      type: System.Byte[]
      description: The blob of data.
    - id: attributes
      type: System.Reflection.FieldAttributes
      description: The attributes for the field.
    return:
      type: System.Reflection.Emit.FieldBuilder
      description: A field to reference the data.
  overload: System.Reflection.Emit.TypeBuilder.DefineInitializedData*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>name</code> is zero.  \n  \n -or-  \n  \n The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> or <code>data</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: <xref:System.Reflection.Emit.TypeBuilder.CreateType*> has been previously called.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)
  id: DefineMethod(System.String,System.Reflection.MethodAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineMethod(String,MethodAttributes)
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new method to the type, with the specified name and method attributes.
  remarks: "Use this method overload when you do not know the method signature at the time you define the method. For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type. The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName> method.  \n  \n This method overload defines a method with <xref:System.Reflection.CallingConventions?displayProperty=fullName>. If you need to define a method without a signature, with a different calling convention, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overload."
  example:
  - "The following code example defines a generic method named `DemoMethod` whose parameter type and return type are specified by its generic type parameters. The method is defined without a signature, using the standard calling convention. The <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=fullName> method is used to make `DemoMethod` a generic method, and the newly defined type parameters are then used for the signature and return type.  \n  \n This code example is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.  \n  \n [!code-cs[GenericMethodBuilder#4](~/add/codesnippet/csharp/e62728c6-695c-4255-be9d-_1.cs)]\n [!code-cpp[GenericMethodBuilder#4](~/add/codesnippet/cpp/e62728c6-695c-4255-be9d-_1.cpp)]\n [!code-vb[GenericMethodBuilder#4](~/add/codesnippet/visualbasic/e62728c6-695c-4255-be9d-_1.vb)]  \n[!code-cs[GenericMethodBuilder#3](~/add/codesnippet/csharp/e62728c6-695c-4255-be9d-_2.cs)]\n[!code-cpp[GenericMethodBuilder#3](~/add/codesnippet/cpp/e62728c6-695c-4255-be9d-_2.cpp)]\n[!code-vb[GenericMethodBuilder#3](~/add/codesnippet/visualbasic/e62728c6-695c-4255-be9d-_2.vb)]  \n[!code-cs[GenericMethodBuilder#5](~/add/codesnippet/csharp/e62728c6-695c-4255-be9d-_3.cs)]\n[!code-cpp[GenericMethodBuilder#5](~/add/codesnippet/cpp/e62728c6-695c-4255-be9d-_3.cpp)]\n[!code-vb[GenericMethodBuilder#5](~/add/codesnippet/visualbasic/e62728c6-695c-4255-be9d-_3.vb)]"
  syntax:
    content: public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);
    parameters:
    - id: name
      type: System.String
      description: The name of the method. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the method.
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: A <xref href="System.Reflection.Emit.MethodBuilder"></xref> representing the newly defined method.
  overload: System.Reflection.Emit.TypeBuilder.DefineMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The length of <code>name</code> is zero.  \n  \n -or-  \n  \n The type of the parent of this method is an interface, and this method is not virtual (<xref uid=\"langword_csharp_Overridable\" name=\"Overridable\" href=\"\"></xref> in Visual Basic)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)
  id: DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineMethod(String,MethodAttributes,CallingConventions)
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new method to the type, with the specified name, method attributes, and calling convention.
  remarks: Use this method overload when you do not know the method signature at the time you define the method. For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type. The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName> method.
  syntax:
    content: public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);
    parameters:
    - id: name
      type: System.String
      description: The name of the method. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the method.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The calling convention of the method.
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: A <xref href="System.Reflection.Emit.MethodBuilder"></xref> representing the newly defined method.
  overload: System.Reflection.Emit.TypeBuilder.DefineMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The length of <code>name</code> is zero.  \n  \n -or-  \n  \n The type of the parent of this method is an interface and this method is not virtual (<xref uid=\"langword_csharp_Overridable\" name=\"Overridable\" href=\"\"></xref> in Visual Basic)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])
  id: DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineMethod(String,MethodAttributes,Type,Type[])
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes,Type,Type[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new method to the type, with the specified name, method attributes, and method signature.
  remarks: ''
  example:
  - "The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.  \n  \n [!code-cs[TypeBuilder_DefineNestedType1#2](~/add/codesnippet/csharp/3323b9a3-56ad-444a-8c21-_1.cs)]\n [!code-vb[TypeBuilder_DefineNestedType1#2](~/add/codesnippet/visualbasic/3323b9a3-56ad-444a-8c21-_1.vb)]\n [!code-cpp[TypeBuilder_DefineNestedType1#2](~/add/codesnippet/cpp/3323b9a3-56ad-444a-8c21-_1.cpp)]"
  syntax:
    content: public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    parameters:
    - id: name
      type: System.String
      description: The name of the method. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the method.
    - id: returnType
      type: System.Type
      description: The return type of the method.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the parameters of the method.
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: The defined method.
  overload: System.Reflection.Emit.TypeBuilder.DefineMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The length of <code>name</code> is zero.  \n  \n -or-  \n  \n The type of the parent of this method is an interface, and this method is not virtual (<xref uid=\"langword_csharp_Overridable\" name=\"Overridable\" href=\"\"></xref> in Visual Basic)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  id: DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[])
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.
  remarks: ''
  example:
  - "The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.  \n  \n [!code-cs[TypeBuilder_DefineNestedType1#2](~/add/codesnippet/csharp/3b09b3c4-59d2-483e-8739-_1.cs)]\n [!code-vb[TypeBuilder_DefineNestedType1#2](~/add/codesnippet/visualbasic/3b09b3c4-59d2-483e-8739-_1.vb)]\n [!code-cpp[TypeBuilder_DefineNestedType1#2](~/add/codesnippet/cpp/3b09b3c4-59d2-483e-8739-_1.cpp)]"
  syntax:
    content: public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    parameters:
    - id: name
      type: System.String
      description: The name of the method. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the method.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The calling convention of the method.
    - id: returnType
      type: System.Type
      description: The return type of the method.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the parameters of the method.
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: A <xref href="System.Reflection.Emit.MethodBuilder"></xref> representing the newly defined method.
  overload: System.Reflection.Emit.TypeBuilder.DefineMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The length of <code>name</code> is zero.  \n  \n -or-  \n  \n The type of the parent of this method is an interface, and this method is not virtual (<xref uid=\"langword_csharp_Overridable\" name=\"Overridable\" href=\"\"></xref> in Visual Basic)."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  id: DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.
  remarks: "Use this overload if you need to specify custom modifiers. If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> or <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overloads to define the method and then use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName> method to define the parameter and return types with custom modifiers.  \n  \n> [!NOTE]\n>  For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site."
  syntax:
    content: public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    parameters:
    - id: name
      type: System.String
      description: The name of the method. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the method.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The calling convention of the method.
    - id: returnType
      type: System.Type
      description: The return type of the method.
    - id: returnTypeRequiredCustomModifiers
      type: System.Type[]
      description: An array of types representing the required custom modifiers, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>, for the return type of the method. If the return type has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref>.
    - id: returnTypeOptionalCustomModifiers
      type: System.Type[]
      description: An array of types representing the optional custom modifiers, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>, for the return type of the method. If the return type has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref>.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the parameters of the method.
    - id: parameterTypeRequiredCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    - id: parameterTypeOptionalCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: A <xref href="System.Reflection.Emit.MethodBuilder"></xref> object representing the newly added method.
  overload: System.Reflection.Emit.TypeBuilder.DefineMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The length of <code>name</code> is zero.  \n  \n -or-  \n  \n The type of the parent of this method is an interface, and this method is not virtual (<xref uid=\"langword_csharp_Overridable\" name=\"Overridable\" href=\"\"></xref> in Visual Basic).  \n  \n -or-  \n  \n The size of <code>parameterTypeRequiredCustomModifiers</code> or <code>parameterTypeOptionalCustomModifiers</code> does not equal the size of <code>parameterTypes</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)
  id: DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineMethodOverride(MethodInfo,MethodInfo)
  nameWithType: TypeBuilder.DefineMethodOverride(MethodInfo,MethodInfo)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethodOverride(MethodInfo,MethodInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Specifies a given method body that implements a given method declaration, potentially with a different name.
  remarks: "Do not use this method to emit method overrides or interface implementations. To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.  \n  \n The DefineMethodOverride method is used when a method body and a method declaration have different names. For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.  \n  \n `DefineMethodOverride` defines a `methodimpl`, which consists of a pair of metadata tokens. One token points to an implementation, and the other token points to a declaration that the body implements. The body must be defined on the type the method impl is defined on, and the body must be virtual (`Overridable` in Visual Basic). The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type. If the declaration is on an interface only, the slot defined for the interface is altered. If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced. The overridden method cannot be the actual method that is declared. If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.  \n  \n> [!NOTE]\n>  For more information about method impls, see `MethodImpl` in the ECMA Partition II Metadata documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.  \n  \n> [!IMPORTANT]\n>  After the DefineMethodOverride method is called, some features of `methodInfoBody` cannot be changed. For example, you cannot apply an attribute to a generic type parameter of `methodInfoBody` by using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method. If you must use the DefineMethodOverride method, do so after all characteristics of `methodInfoBody` have been defined."
  example:
  - "The following code example contains an interface `I` with a method `M()`, a base class `A` that implements the interface, and a derived class `C` that overrides the base class implementation of `M()` and also provides a separate explicit implementation of `I.M()`.  \n  \n The `main()` method of the code example shows how to emit the derived class `C`. The override of `A.M()` is accomplished simply by emitting a method `M()` with the same signature. However, to provide a separate implementation of `I.M()`, you must define a method body and then use the DefineMethodOverride method to associate that method body with a <xref:System.Reflection.MethodInfo> representing `I.M()`. The name of the method body does not matter.  \n  \n The code example creates an instance of the emitted class. It obtains a <xref:System.Reflection.MethodInfo> object for `I.M()`, and uses it to invoke the emitted class's explicit interface implementation. It then obtains a <xref:System.Reflection.MethodInfo> object for `A.M()`, and uses it to invoke the emitted class's override of that method.  \n  \n [!code-cs[TypeBuilder.DefineMethodOverride#1](~/add/codesnippet/csharp/d6de2ea9-0bd7-4e01-9879-_1.cs)]\n [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/add/codesnippet/cpp/d6de2ea9-0bd7-4e01-9879-_1.cpp)]\n [!code-vb[TypeBuilder.DefineMethodOverride#1](~/add/codesnippet/visualbasic/d6de2ea9-0bd7-4e01-9879-_1.vb)]"
  syntax:
    content: public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);
    parameters:
    - id: methodInfoBody
      type: System.Reflection.MethodInfo
      description: The method body to be used. This should be a <xref uid="langword_csharp_MethodBuilder" name="MethodBuilder" href=""></xref> object.
    - id: methodInfoDeclaration
      type: System.Reflection.MethodInfo
      description: The method whose declaration is to be used.
  overload: System.Reflection.Emit.TypeBuilder.DefineMethodOverride*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>methodInfoBody</code> does not belong to this class.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>methodInfoBody</code> or <code>methodInfoDeclaration</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n The declaring type of <code>methodInfoBody</code> is not the type represented by this <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)
  id: DefineNestedType(System.String)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineNestedType(String)
  nameWithType: TypeBuilder.DefineNestedType(String)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a nested type, given its name.
  remarks: "This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.  \n  \n The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.  \n  \n See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.  \n  \n A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types."
  syntax:
    content: public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);
    parameters:
    - id: name
      type: System.String
      description: The short name of the type. `name` cannot contain embedded nulls.
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: The defined nested type.
  overload: System.Reflection.Emit.TypeBuilder.DefineNestedType*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>name</code> is zero or greater than 1023.  \n  \n -or-  \n  \n This operation would create a type with a duplicate <xref:System.Reflection.Emit.TypeBuilder.FullName*> in the current assembly."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineNestedType(String,TypeAttributes)
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a nested type, given its name and attributes.
  remarks: "This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.  \n  \n The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.  \n  \n See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.  \n  \n A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types."
  syntax:
    content: public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);
    parameters:
    - id: name
      type: System.String
      description: The short name of the type. `name` cannot contain embedded nulls.
    - id: attr
      type: System.Reflection.TypeAttributes
      description: The attributes of the type.
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: The defined nested type.
  overload: System.Reflection.Emit.TypeBuilder.DefineNestedType*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The nested attribute is not specified.  \n  \n -or-  \n  \n This type is sealed.  \n  \n -or-  \n  \n This type is an array.  \n  \n -or-  \n  \n This type is an interface, but the nested type is not an interface.  \n  \n -or-  \n  \n The length of <code>name</code> is zero or greater than 1023.  \n  \n -or-  \n  \n This operation would create a type with a duplicate <xref:System.Reflection.Emit.TypeBuilder.FullName*> in the current assembly."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineNestedType(String,TypeAttributes,Type)
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes,Type)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes,Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a nested type, given its name, attributes, and the type that it extends.
  remarks: "This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.  \n  \n The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.  \n  \n See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.  \n  \n A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types."
  syntax:
    content: public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);
    parameters:
    - id: name
      type: System.String
      description: The short name of the type. `name` cannot contain embedded nulls.
    - id: attr
      type: System.Reflection.TypeAttributes
      description: The attributes of the type.
    - id: parent
      type: System.Type
      description: The type that the nested type extends.
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: The defined nested type.
  overload: System.Reflection.Emit.TypeBuilder.DefineNestedType*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The nested attribute is not specified.  \n  \n -or-  \n  \n This type is sealed.  \n  \n -or-  \n  \n This type is an array.  \n  \n -or-  \n  \n This type is an interface, but the nested type is not an interface.  \n  \n -or-  \n  \n The length of <code>name</code> is zero or greater than 1023.  \n  \n -or-  \n  \n This operation would create a type with a duplicate <xref:System.Reflection.Emit.TypeBuilder.FullName*> in the current assembly."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineNestedType(String,TypeAttributes,Type,Int32)
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes,Type,Int32)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes,Type,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.
  remarks: "This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.  \n  \n The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.  \n  \n See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.  \n  \n A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types."
  syntax:
    content: public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);
    parameters:
    - id: name
      type: System.String
      description: The short name of the type. `name` cannot contain embedded nulls.
    - id: attr
      type: System.Reflection.TypeAttributes
      description: The attributes of the type.
    - id: parent
      type: System.Type
      description: The type that the nested type extends.
    - id: typeSize
      type: System.Int32
      description: The total size of the type.
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: The defined nested type.
  overload: System.Reflection.Emit.TypeBuilder.DefineNestedType*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The nested attribute is not specified.  \n  \n -or-  \n  \n This type is sealed.  \n  \n -or-  \n  \n This type is an array.  \n  \n -or-  \n  \n This type is an interface, but the nested type is not an interface.  \n  \n -or-  \n  \n The length of <code>name</code> is zero or greater than 1023.  \n  \n -or-  \n  \n This operation would create a type with a duplicate <xref:System.Reflection.Emit.TypeBuilder.FullName*> in the current assembly."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineNestedType(String,TypeAttributes,Type,PackingSize)
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes,Type,PackingSize)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes,Type,PackingSize)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a nested type, given its name, attributes, the type that it extends, and the packing size.
  remarks: "This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.  \n  \n The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.  \n  \n See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.  \n  \n A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types."
  syntax:
    content: public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);
    parameters:
    - id: name
      type: System.String
      description: The short name of the type. `name` cannot contain embedded nulls.
    - id: attr
      type: System.Reflection.TypeAttributes
      description: The attributes of the type.
    - id: parent
      type: System.Type
      description: The type that the nested type extends.
    - id: packSize
      type: System.Reflection.Emit.PackingSize
      description: The packing size of the type.
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: The defined nested type.
  overload: System.Reflection.Emit.TypeBuilder.DefineNestedType*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The nested attribute is not specified.  \n  \n -or-  \n  \n This type is sealed.  \n  \n -or-  \n  \n This type is an array.  \n  \n -or-  \n  \n This type is an interface, but the nested type is not an interface.  \n  \n -or-  \n  \n The length of <code>name</code> is zero or greater than 1023.  \n  \n -or-  \n  \n This operation would create a type with a duplicate <xref:System.Reflection.Emit.TypeBuilder.FullName*> in the current assembly."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineNestedType(String,TypeAttributes,Type,Type[])
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes,Type,Type[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.
  remarks: "This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.  \n  \n The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.  \n  \n See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.  \n  \n A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types."
  syntax:
    content: public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);
    parameters:
    - id: name
      type: System.String
      description: The short name of the type. `name` cannot contain embedded nulls.
    - id: attr
      type: System.Reflection.TypeAttributes
      description: The attributes of the type.
    - id: parent
      type: System.Type
      description: The type that the nested type extends.
    - id: interfaces
      type: System.Type[]
      description: The interfaces that the nested type implements.
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: The defined nested type.
  overload: System.Reflection.Emit.TypeBuilder.DefineNestedType*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The nested attribute is not specified.  \n  \n -or-  \n  \n This type is sealed.  \n  \n -or-  \n  \n This type is an array.  \n  \n -or-  \n  \n This type is an interface, but the nested type is not an interface.  \n  \n -or-  \n  \n The length of <code>name</code> is zero or greater than 1023.  \n  \n -or-  \n  \n This operation would create a type with a duplicate <xref:System.Reflection.Emit.TypeBuilder.FullName*> in the current assembly."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n -or-  \n  \n An element of the <code>interfaces</code> array is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  id: DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefinePInvokeMethod(String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  nameWithType: TypeBuilder.DefinePInvokeMethod(String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  fullName: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> flags.
  remarks: Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method. For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> must be added after the `PInvoke` method is created, if the method returns a value. The example shows how to do this.
  example:
  - "The following example demonstrates how to use the DefinePInvokeMethod method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=fullName> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=fullName> methods.  \n  \n> [!IMPORTANT]\n>  To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> flag.  \n  \n The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method. The `PInvoke` method represents the Win32 `GetTickCount` function.  \n  \n When the example is run, it executes the `PInvoke` method. It also saves the dynamic assembly as PInvokeTest.dll. You can use the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains. You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.  \n  \n [!code-cs[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/csharp/24029d60-b1df-4a7e-9ff9-_1.cs)]\n [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/cpp/24029d60-b1df-4a7e-9ff9-_1.cpp)]\n [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/visualbasic/24029d60-b1df-4a7e-9ff9-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);
    parameters:
    - id: name
      type: System.String
      description: The name of the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method. `name` cannot contain embedded nulls.
    - id: dllName
      type: System.String
      description: The name of the DLL in which the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method is defined.
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the method.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The method's calling convention.
    - id: returnType
      type: System.Type
      description: The method's return type.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the method's parameters.
    - id: nativeCallConv
      type: System.Runtime.InteropServices.CallingConvention
      description: The native calling convention.
    - id: nativeCharSet
      type: System.Runtime.InteropServices.CharSet
      description: The method's native character set.
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: The defined <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method.
  overload: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The method is not static.  \n  \n -or-  \n  \n The parent type is an interface.  \n  \n -or-  \n  \n The method is abstract.  \n  \n -or-  \n  \n The method was previously defined.  \n  \n -or-  \n  \n The length of <code>name</code> or <code>dllName</code> is zero."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> or <code>dllName</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The containing type has been previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  id: DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  nameWithType: TypeBuilder.DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  fullName: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> flags.
  remarks: Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method. For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> must be added after the `PInvoke` method is created, if the method returns a value. The example shows how to do this.
  example:
  - "The following code example demonstrates how to use the DefinePInvokeMethod method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=fullName> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=fullName> methods.  \n  \n> [!IMPORTANT]\n>  To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> flag.  \n  \n The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method. The `PInvoke` method represents the Win32 `GetTickCount` function.  \n  \n When the example is run, it executes the `PInvoke` method. It also saves the dynamic assembly as PInvokeTest.dll. You can use the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains. You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.  \n  \n [!code-cs[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/csharp/861428cf-86ca-4ed9-826a-_1.cs)]\n [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/cpp/861428cf-86ca-4ed9-826a-_1.cpp)]\n [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/visualbasic/861428cf-86ca-4ed9-826a-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);
    parameters:
    - id: name
      type: System.String
      description: The name of the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method. `name` cannot contain embedded nulls.
    - id: dllName
      type: System.String
      description: The name of the DLL in which the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method is defined.
    - id: entryName
      type: System.String
      description: The name of the entry point in the DLL.
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the method.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The method's calling convention.
    - id: returnType
      type: System.Type
      description: The method's return type.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the method's parameters.
    - id: nativeCallConv
      type: System.Runtime.InteropServices.CallingConvention
      description: The native calling convention.
    - id: nativeCharSet
      type: System.Runtime.InteropServices.CharSet
      description: The method's native character set.
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: The defined <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method.
  overload: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The method is not static.  \n  \n -or-  \n  \n The parent type is an interface.  \n  \n -or-  \n  \n The method is abstract.  \n  \n -or-  \n  \n The method was previously defined.  \n  \n -or-  \n  \n The length of <code>name</code>, <code>dllName</code>, or <code>entryName</code> is zero."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code>, <code>dllName</code>, or <code>entryName</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The containing type has been previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  id: DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][],CallingConvention,CharSet)
  nameWithType: TypeBuilder.DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][],CallingConvention,CharSet)
  fullName: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][],CallingConvention,CharSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines a <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> flags, and custom modifiers for the parameters and return type.
  remarks: "Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method. For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> must be added after the `PInvoke` method is created, if the method returns a value. The example shows how to do this.  \n  \n> [!NOTE]\n>  For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site."
  example:
  - "The following code example demonstrates how to use the DefinePInvokeMethod method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=fullName> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=fullName> methods.  \n  \n The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method. The `PInvoke` method represents the Win32 `GetTickCount` function.  \n  \n> [!IMPORTANT]\n>  To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes?displayProperty=fullName> flag.  \n  \n> [!NOTE]\n>  The example uses an overload that does not specify custom modifiers. To specify custom modifiers, change the example code to use this method overload instead.  \n  \n When the example is run, it executes the `PInvoke` method. It also saves the dynamic assembly as PInvokeTest.dll. You can use the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains. You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.  \n  \n [!code-cs[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/csharp/ad88ca7a-2b4e-4afb-814f-_1.cs)]\n [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/cpp/ad88ca7a-2b4e-4afb-814f-_1.cpp)]\n [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/add/codesnippet/visualbasic/ad88ca7a-2b4e-4afb-814f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);
    parameters:
    - id: name
      type: System.String
      description: The name of the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method. `name` cannot contain embedded nulls.
    - id: dllName
      type: System.String
      description: The name of the DLL in which the <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method is defined.
    - id: entryName
      type: System.String
      description: The name of the entry point in the DLL.
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: The attributes of the method.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The method's calling convention.
    - id: returnType
      type: System.Type
      description: The method's return type.
    - id: returnTypeRequiredCustomModifiers
      type: System.Type[]
      description: An array of types representing the required custom modifiers, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>, for the return type of the method. If the return type has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref>.
    - id: returnTypeOptionalCustomModifiers
      type: System.Type[]
      description: An array of types representing the optional custom modifiers, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>, for the return type of the method. If the return type has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref>.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the method's parameters.
    - id: parameterTypeRequiredCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    - id: parameterTypeOptionalCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    - id: nativeCallConv
      type: System.Runtime.InteropServices.CallingConvention
      description: The native calling convention.
    - id: nativeCharSet
      type: System.Runtime.InteropServices.CharSet
      description: The method's native character set.
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: A <xref href="System.Reflection.Emit.MethodBuilder"></xref> representing the defined <xref uid="langword_csharp_PInvoke" name="PInvoke" href=""></xref> method.
  overload: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The method is not static.  \n  \n -or-  \n  \n The parent type is an interface.  \n  \n -or-  \n  \n The method is abstract.  \n  \n -or-  \n  \n The method was previously defined.  \n  \n -or-  \n  \n The length of <code>name</code>, <code>dllName</code>, or <code>entryName</code> is zero.  \n  \n -or-  \n  \n The size of <code>parameterTypeRequiredCustomModifiers</code> or <code>parameterTypeOptionalCustomModifiers</code> does not equal the size of <code>parameterTypes</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code>, <code>dllName</code>, or <code>entryName</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])
  id: DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineProperty(String,PropertyAttributes,Type,Type[])
  nameWithType: TypeBuilder.DefineProperty(String,PropertyAttributes,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(String,PropertyAttributes,Type,Type[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new property to the type, with the given name and property signature.
  remarks: ''
  example:
  - "The following code sample demonstrates how to define a dynamic property and obtain a <xref:System.Reflection.Emit.PropertyBuilder> for specification. Note that a `PropertyBuilder` must also have a corresponding <xref:System.Reflection.Emit.MethodBuilder>, which will house the IL logic for the property.  \n  \n [!code-cs[System.Reflection.Emit.PropertyBuilder Example#1](~/add/codesnippet/csharp/585da80d-b23a-4b89-a62f-_1.cs)]\n [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/add/codesnippet/cpp/585da80d-b23a-4b89-a62f-_1.cpp)]\n [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/add/codesnippet/visualbasic/585da80d-b23a-4b89-a62f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    parameters:
    - id: name
      type: System.String
      description: The name of the property. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.PropertyAttributes
      description: The attributes of the property.
    - id: returnType
      type: System.Type
      description: The return type of the property.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the parameters of the property.
    return:
      type: System.Reflection.Emit.PropertyBuilder
      description: The defined property.
  overload: System.Reflection.Emit.TypeBuilder.DefineProperty*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The length of <code>name</code> is zero.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n -or-  \n  \n Any of the elements of the <code>parameterTypes</code> array is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  id: DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[])
  nameWithType: TypeBuilder.DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new property to the type, with the given name, attributes, calling convention, and property signature.
  syntax:
    content: public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    parameters:
    - id: name
      type: System.String
      description: The name of the property. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.PropertyAttributes
      description: The attributes of the property.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The calling convention of the property accessors.
    - id: returnType
      type: System.Type
      description: The return type of the property.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the parameters of the property.
    return:
      type: System.Reflection.Emit.PropertyBuilder
      description: The defined property.
  overload: System.Reflection.Emit.TypeBuilder.DefineProperty*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The length of <code>name</code> is zero.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n -or-  \n  \n Any of the elements of the <code>parameterTypes</code> array is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  id: DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineProperty(String,PropertyAttributes,Type,Type[],Type[],Type[],Type[][],Type[][])
  nameWithType: TypeBuilder.DefineProperty(String,PropertyAttributes,Type,Type[],Type[],Type[],Type[][],Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(String,PropertyAttributes,Type,Type[],Type[],Type[],Type[][],Type[][])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new property to the type, with the given name, property signature, and custom modifiers.
  remarks: "This overload is provided for designers of managed compilers.  \n  \n> [!NOTE]\n>  For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site."
  syntax:
    content: public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    parameters:
    - id: name
      type: System.String
      description: The name of the property. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.PropertyAttributes
      description: The attributes of the property.
    - id: returnType
      type: System.Type
      description: The return type of the property.
    - id: returnTypeRequiredCustomModifiers
      type: System.Type[]
      description: An array of types representing the required custom modifiers, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>, for the return type of the property. If the return type has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref>.
    - id: returnTypeOptionalCustomModifiers
      type: System.Type[]
      description: An array of types representing the optional custom modifiers, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>, for the return type of the property. If the return type has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref>.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the parameters of the property.
    - id: parameterTypeRequiredCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    - id: parameterTypeOptionalCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    return:
      type: System.Reflection.Emit.PropertyBuilder
      description: The defined property.
  overload: System.Reflection.Emit.TypeBuilder.DefineProperty*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The length of <code>name</code> is zero.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>  \n  \n -or-  \n  \n Any of the elements of the <code>parameterTypes</code> array is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  id: DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  nameWithType: TypeBuilder.DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.
  remarks: "This overload is provided for designers of managed compilers.  \n  \n> [!NOTE]\n>  For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.  \n  \n This method overload is introduced in the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later."
  syntax:
    content: public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    parameters:
    - id: name
      type: System.String
      description: The name of the property. `name` cannot contain embedded nulls.
    - id: attributes
      type: System.Reflection.PropertyAttributes
      description: The attributes of the property.
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: The calling convention of the property accessors.
    - id: returnType
      type: System.Type
      description: The return type of the property.
    - id: returnTypeRequiredCustomModifiers
      type: System.Type[]
      description: An array of types representing the required custom modifiers, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>, for the return type of the property. If the return type has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref>.
    - id: returnTypeOptionalCustomModifiers
      type: System.Type[]
      description: An array of types representing the optional custom modifiers, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>, for the return type of the property. If the return type has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref>.
    - id: parameterTypes
      type: System.Type[]
      description: The types of the parameters of the property.
    - id: parameterTypeRequiredCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have required custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    - id: parameterTypeOptionalCustomModifiers
      type: System.Type[][]
      description: An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href="System.Runtime.CompilerServices.IsConst"></xref>. If a particular parameter has no optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of types. If none of the parameters have optional custom modifiers, specify <xref uid="langword_csharp_null" name="null" href=""></xref> instead of an array of arrays.
    return:
      type: System.Reflection.Emit.PropertyBuilder
      description: The defined property.
  overload: System.Reflection.Emit.TypeBuilder.DefineProperty*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The length of <code>name</code> is zero.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n -or-  \n  \n Any of the elements of the <code>parameterTypes</code> array is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineTypeInitializer
  id: DefineTypeInitializer
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineTypeInitializer()
  nameWithType: TypeBuilder.DefineTypeInitializer()
  fullName: System.Reflection.Emit.TypeBuilder.DefineTypeInitializer()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines the initializer for this type.
  remarks: The initializer created is always public.
  example:
  - "The following code sample demonstrates how to create an initialization constructor using `DefineTypeInitializer`.  \n  \n [!code-cpp[TypeBuilder_Properties1#3](~/add/codesnippet/cpp/m-system.reflection.emit_43_1.cpp)]\n [!code-vb[TypeBuilder_Properties1#3](~/add/codesnippet/visualbasic/m-system.reflection.emit_43_1.vb)]\n [!code-cs[TypeBuilder_Properties1#3](~/add/codesnippet/csharp/m-system.reflection.emit_43_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();
    parameters: []
    return:
      type: System.Reflection.Emit.ConstructorBuilder
      description: Returns a type initializer.
  overload: System.Reflection.Emit.TypeBuilder.DefineTypeInitializer*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The containing type has been previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)
  id: DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: DefineUninitializedData(String,Int32,FieldAttributes)
  nameWithType: TypeBuilder.DefineUninitializedData(String,Int32,FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineUninitializedData(String,Int32,FieldAttributes)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Defines an uninitialized data field in the <xref uid="langword_csharp_.sdata" name=".sdata" href=""></xref> section of the portable executable (PE) file.
  remarks: The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.
  example:
  - "The following code sample demonstrates the use of `DefineUninitializedData` to create an uninitialized data field in a dynamic type:  \n  \n [!code-cs[TypeBuilder_DefineUninitializedData#1](~/add/codesnippet/csharp/aba733a9-c2e1-4d9d-9baf-_1.cs)]\n [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/add/codesnippet/cpp/aba733a9-c2e1-4d9d-9baf-_1.cpp)]\n [!code-vb[TypeBuilder_DefineUninitializedData#1](~/add/codesnippet/visualbasic/aba733a9-c2e1-4d9d-9baf-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);
    parameters:
    - id: name
      type: System.String
      description: The name used to refer to the data. `name` cannot contain embedded nulls.
    - id: size
      type: System.Int32
      description: The size of the data field.
    - id: attributes
      type: System.Reflection.FieldAttributes
      description: The attributes for the field.
    return:
      type: System.Reflection.Emit.FieldBuilder
      description: A field to reference the data.
  overload: System.Reflection.Emit.TypeBuilder.DefineUninitializedData*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "Length of <code>name</code> is zero.  \n  \n -or-  \n  \n <code>size</code> is less than or equal to zero, or greater than or equal to 0x003f0000."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>name</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.FullName
  id: FullName
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: FullName
  nameWithType: TypeBuilder.FullName
  fullName: System.Reflection.Emit.TypeBuilder.FullName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the full path of this type.
  remarks: The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.
  syntax:
    content: public override string FullName { get; }
    return:
      type: System.String
      description: Read-only. Retrieves the full path of this type.
  overload: System.Reflection.Emit.TypeBuilder.FullName*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
  id: GenericParameterAttributes
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GenericParameterAttributes
  nameWithType: TypeBuilder.GenericParameterAttributes
  fullName: System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets a value that indicates the covariance and special constraints of the current generic type parameter.
  remarks: >-
    > [!NOTE]

    >  When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.
  syntax:
    content: public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }
    return:
      type: System.Reflection.GenericParameterAttributes
      description: A bitwise combination of <xref href="System.Reflection.GenericParameterAttributes"></xref> values that describes the covariance and special constraints of the current generic type parameter.
  overload: System.Reflection.Emit.TypeBuilder.GenericParameterAttributes*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GenericParameterPosition
  id: GenericParameterPosition
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GenericParameterPosition
  nameWithType: TypeBuilder.GenericParameterPosition
  fullName: System.Reflection.Emit.TypeBuilder.GenericParameterPosition
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.
  remarks: "> [!NOTE]\n>  When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.  \n  \n If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent a generic type parameter, the value of this property is undefined. Use the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property to determine whether the current <xref:System.Reflection.Emit.TypeBuilder> represents a generic type parameter."
  syntax:
    content: public override int GenericParameterPosition { get; }
    return:
      type: System.Int32
      description: If the current <xref href="System.Reflection.Emit.TypeBuilder"></xref> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.
  overload: System.Reflection.Emit.TypeBuilder.GenericParameterPosition*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl
  id: GetAttributeFlagsImpl
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetAttributeFlagsImpl()
  nameWithType: TypeBuilder.GetAttributeFlagsImpl()
  fullName: System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();
    parameters: []
    return:
      type: System.Reflection.TypeAttributes
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)
  id: GetConstructor(System.Type,System.Reflection.ConstructorInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetConstructor(Type,ConstructorInfo)
  nameWithType: TypeBuilder.GetConstructor(Type,ConstructorInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetConstructor(Type,ConstructorInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.
  remarks: "The GetConstructor method provides a way to get a <xref:System.Reflection.ConstructorInfo> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.  \n  \n For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.ConstructorBuilder> object that represents a constructor of `G<T>`. Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>`. In order to emit the code to create an instance of the constructed type, you need a <xref:System.Reflection.ConstructorInfo> object that represents the constructor of this constructed type  in other words, that creates an instance of `G<U>`. To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument. Then call the GetConstructor method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.ConstructorBuilder> object that represents the constructor of `G<U>` as parameter `constructor`. The return value is the <xref:System.Reflection.ConstructorInfo> object you need to emit the function call. The code example demonstrates this scenario."
  example:
  - "The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`. The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`. Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`. This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) and compare it to the code emitted by class `Example`.  \n  \n The code in class `Example` demonstrates the use of the GetConstructor method to emit generic code. The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`. A default constructor and a field named `Field`, of type `T`, are added to class `Sample`. A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=fullName> method. The type parameter of `GM` is named `U`. After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName> method. There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter. The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`. The GetConstructor method is used to create a <xref:System.Reflection.ConstructorInfo> that represents the default constructor of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=fullName> instruction that creates the instance.  \n  \n A dummy type is defined to hold the entry-point method `Main`. In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.  \n  \n When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe. You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](../Topic/Ildasm.exe%20\\(IL%20Disassembler\\).md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.  \n  \n [!code-cs[TypeBuilder.GetField_Generic#1](~/add/codesnippet/csharp/130b44ea-71e0-44de-86c0-_1.cs)]\n [!code-vb[TypeBuilder.GetField_Generic#1](~/add/codesnippet/visualbasic/130b44ea-71e0-44de-86c0-_1.vb)]"
  syntax:
    content: public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);
    parameters:
    - id: type
      type: System.Type
      description: The constructed generic type whose constructor is returned.
    - id: constructor
      type: System.Reflection.ConstructorInfo
      description: A constructor on the generic type definition of `type`, which specifies which constructor of `type` to return.
    return:
      type: System.Reflection.ConstructorInfo
      description: A <xref href="System.Reflection.ConstructorInfo"></xref> object that represents the constructor of <code>type</code> corresponding to <code>constructor</code>, which specifies a constructor belonging to the generic type definition of <code>type</code>.
  overload: System.Reflection.Emit.TypeBuilder.GetConstructor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>type</code> does not represent a generic type.  \n  \n -or-  \n  \n <code>type</code> is not of type <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref>.  \n  \n -or-  \n  \n The declaring type of <code>constructor</code> is not a generic type definition.  \n  \n -or-  \n  \n The declaring type of <code>constructor</code> is not the generic type definition of <code>type</code>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  id: GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeBuilder.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.Emit.TypeBuilder.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: To be added.
    - id: binder
      type: System.Reflection.Binder
      description: To be added.
    - id: callConvention
      type: System.Reflection.CallingConventions
      description: To be added.
    - id: types
      type: System.Type[]
      description: To be added.
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: To be added.
    return:
      type: System.Reflection.ConstructorInfo
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.GetConstructorImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)
  id: GetConstructors(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetConstructors(BindingFlags)
  nameWithType: TypeBuilder.GetConstructors(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetConstructors(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns an array of <xref href="System.Reflection.ConstructorInfo"></xref> objects representing the public and non-public constructors defined for this class, as specified.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: This must be a bit flag from <xref href="System.Reflection.BindingFlags"></xref> as in <xref uid="langword_csharp_InvokeMethod" name="InvokeMethod" href=""></xref>, <xref uid="langword_csharp_NonPublic" name="NonPublic" href=""></xref>, and so on.
    return:
      type: System.Reflection.ConstructorInfo[]
      description: Returns an array of <xref href="System.Reflection.ConstructorInfo"></xref> objects representing the specified constructors defined for this class. If no constructors are defined, an empty array is returned.
  overload: System.Reflection.Emit.TypeBuilder.GetConstructors*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)
  id: GetCustomAttributes(System.Boolean)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetCustomAttributes(Boolean)
  nameWithType: TypeBuilder.GetCustomAttributes(Boolean)
  fullName: System.Reflection.Emit.TypeBuilder.GetCustomAttributes(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns all the custom attributes defined for this type.
  syntax:
    content: public override object[] GetCustomAttributes (bool inherit);
    parameters:
    - id: inherit
      type: System.Boolean
      description: Specifies whether to search this member's inheritance chain to find the attributes.
    return:
      type: System.Object[]
      description: Returns an array of objects representing all the custom attributes of this type.
  overload: System.Reflection.Emit.TypeBuilder.GetCustomAttributes*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not currently supported for incomplete types. Retrieve the type using <xref:System.Type.GetType*> and call <xref:System.Reflection.MemberInfo.GetCustomAttributes*> on the returned <xref href="System.Type"></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)
  id: GetCustomAttributes(System.Type,System.Boolean)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetCustomAttributes(Type,Boolean)
  nameWithType: TypeBuilder.GetCustomAttributes(Type,Boolean)
  fullName: System.Reflection.Emit.TypeBuilder.GetCustomAttributes(Type,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns all the custom attributes of the current type that are assignable to a specified type.
  syntax:
    content: public override object[] GetCustomAttributes (Type attributeType, bool inherit);
    parameters:
    - id: attributeType
      type: System.Type
      description: The type of attribute to search for. Only attributes that are assignable to this type are returned.
    - id: inherit
      type: System.Boolean
      description: Specifies whether to search this member's inheritance chain to find the attributes.
    return:
      type: System.Object[]
      description: An array of custom attributes defined on the current type.
  overload: System.Reflection.Emit.TypeBuilder.GetCustomAttributes*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not currently supported for incomplete types. Retrieve the type using <xref:System.Type.GetType*> and call <xref:System.Reflection.MemberInfo.GetCustomAttributes*> on the returned <xref href="System.Type"></xref>.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>attributeType</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The type must be a type provided by the underlying runtime system.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetElementType
  id: GetElementType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetElementType()
  nameWithType: TypeBuilder.GetElementType()
  fullName: System.Reflection.Emit.TypeBuilder.GetElementType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Calling this method always throws <xref href="System.NotSupportedException"></xref>.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override Type GetElementType ();
    parameters: []
    return:
      type: System.Type
      description: This method is not supported. No value is returned.
  overload: System.Reflection.Emit.TypeBuilder.GetElementType*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not supported.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)
  id: GetEvent(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetEvent(String,BindingFlags)
  nameWithType: TypeBuilder.GetEvent(String,BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetEvent(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the event with the specified name.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: The name of the event to search for.
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: A bitwise combination of <xref href="System.Reflection.BindingFlags"></xref> values that limits the search.
    return:
      type: System.Reflection.EventInfo
      description: An <xref href="System.Reflection.EventInfo"></xref> object representing the event declared or inherited by this type with the specified name, or <xref uid="langword_csharp_null" name="null" href=""></xref> if there are no matches.
  overload: System.Reflection.Emit.TypeBuilder.GetEvent*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetEvents
  id: GetEvents
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetEvents()
  nameWithType: TypeBuilder.GetEvents()
  fullName: System.Reflection.Emit.TypeBuilder.GetEvents()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the public events declared or inherited by this type.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetType%2A> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.EventInfo[] GetEvents ();
    parameters: []
    return:
      type: System.Reflection.EventInfo[]
      description: Returns an array of <xref href="System.Reflection.EventInfo"></xref> objects representing the public events declared or inherited by this type. An empty array is returned if there are no public events.
  overload: System.Reflection.Emit.TypeBuilder.GetEvents*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)
  id: GetEvents(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetEvents(BindingFlags)
  nameWithType: TypeBuilder.GetEvents(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetEvents(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the public and non-public events that are declared by this type.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: A bitwise combination of <xref href="System.Reflection.BindingFlags"></xref> values that limits the search.
    return:
      type: System.Reflection.EventInfo[]
      description: Returns an array of <xref href="System.Reflection.EventInfo"></xref> objects representing the events declared or inherited by this type that match the specified binding flags. An empty array is returned if there are no matching events.
  overload: System.Reflection.Emit.TypeBuilder.GetEvents*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)
  id: GetField(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetField(String,BindingFlags)
  nameWithType: TypeBuilder.GetField(String,BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetField(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the field specified by the given name.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: The name of the field to get.
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: This must be a bit flag from <xref href="System.Reflection.BindingFlags"></xref> as in <xref uid="langword_csharp_InvokeMethod" name="InvokeMethod" href=""></xref>, <xref uid="langword_csharp_NonPublic" name="NonPublic" href=""></xref>, and so on.
    return:
      type: System.Reflection.FieldInfo
      description: Returns the <xref href="System.Reflection.FieldInfo"></xref> object representing the field declared or inherited by this type with the specified name and public or non-public modifier. If there are no matches then <xref uid="langword_csharp_null" name="null" href=""></xref> is returned.
  overload: System.Reflection.Emit.TypeBuilder.GetField*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)
  id: GetField(System.Type,System.Reflection.FieldInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetField(Type,FieldInfo)
  nameWithType: TypeBuilder.GetField(Type,FieldInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetField(Type,FieldInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.
  remarks: "The GetField method provides a way to get a <xref:System.Reflection.FieldInfo> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.  \n  \n For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.FieldBuilder> object that represents a field `public T F` in C# syntax (`Public F As T` in Visual Basic, `public: T F` in C++) that is defined by `G<T>`. Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls field `F` on that instance. In order to emit the function call, you need a <xref:System.Reflection.FieldInfo> object that represents `F` on the constructed type  in other words, that is of type `U` rather than type `T`. To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument. Then call the GetField method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.FieldBuilder> object that represents `F` as parameter `field`. The return value is the <xref:System.Reflection.FieldInfo> object you need to emit the function call. The code example demonstrates this scenario."
  example:
  - "The following code example contains source code for a generic class named Sample that has a type parameter named `T`. The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`. Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`. This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) and compare it to the code emitted by class `Example`.  \n  \n The code in class `Example` demonstrates the use of the GetField method to emit generic code. The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`. A default constructor and a field named `Field`, of type `T`, are added to class `Sample`. A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=fullName> method. The type parameter of `GM` is named `U`. After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName> method. There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter. The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`. The GetField method is used to create a <xref:System.Reflection.FieldInfo> that represents the field of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=fullName> and <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=fullName> instructions.  \n  \n A dummy type is defined to hold the entry-point method `Main`. In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.  \n  \n When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe. You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](../Topic/Ildasm.exe%20\\(IL%20Disassembler\\).md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.  \n  \n [!code-cs[TypeBuilder.GetField_Generic#1](~/add/codesnippet/csharp/7015d1e4-6d46-4e1c-93a7-_1.cs)]\n [!code-vb[TypeBuilder.GetField_Generic#1](~/add/codesnippet/visualbasic/7015d1e4-6d46-4e1c-93a7-_1.vb)]"
  syntax:
    content: public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);
    parameters:
    - id: type
      type: System.Type
      description: The constructed generic type whose field is returned.
    - id: field
      type: System.Reflection.FieldInfo
      description: A field on the generic type definition of `type`, which specifies which field of `type` to return.
    return:
      type: System.Reflection.FieldInfo
      description: A <xref href="System.Reflection.FieldInfo"></xref> object that represents the field of <code>type</code> corresponding to <code>field</code>, which specifies a field belonging to the generic type definition of <code>type</code>.
  overload: System.Reflection.Emit.TypeBuilder.GetField*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>type</code> does not represent a generic type.  \n  \n -or-  \n  \n <code>type</code> is not of type <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref>.  \n  \n -or-  \n  \n The declaring type of <code>field</code> is not a generic type definition.  \n  \n -or-  \n  \n The declaring type of <code>field</code> is not the generic type definition of <code>type</code>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)
  id: GetFields(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetFields(BindingFlags)
  nameWithType: TypeBuilder.GetFields(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetFields(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the public and non-public fields that are declared by this type.
  remarks: "The GetFields method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order can vary.  \n  \n Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type."
  syntax:
    content: public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: 'This must be a bit flag from <xref href="System.Reflection.BindingFlags"></xref> : <xref uid="langword_csharp_InvokeMethod" name="InvokeMethod" href=""></xref>, <xref uid="langword_csharp_NonPublic" name="NonPublic" href=""></xref>, and so on.'
    return:
      type: System.Reflection.FieldInfo[]
      description: Returns an array of <xref href="System.Reflection.FieldInfo"></xref> objects representing the public and non-public fields declared or inherited by this type. An empty array is returned if there are no fields, as specified.
  overload: System.Reflection.Emit.TypeBuilder.GetFields*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetGenericArguments
  id: GetGenericArguments
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetGenericArguments()
  nameWithType: TypeBuilder.GetGenericArguments()
  fullName: System.Reflection.Emit.TypeBuilder.GetGenericArguments()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns an array of <xref href="System.Type"></xref> objects representing the type arguments of a generic type or the type parameters of a generic type definition.
  remarks: "The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.  \n  \n A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters. This method retrieves the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects that represent the generic type parameters.  \n  \n For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=fullName> property."
  syntax:
    content: public override Type[] GetGenericArguments ();
    parameters: []
    return:
      type: System.Type[]
      description: An array of <xref href="System.Type"></xref> objects. The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.
  overload: System.Reflection.Emit.TypeBuilder.GetGenericArguments*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition
  id: GetGenericTypeDefinition
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetGenericTypeDefinition()
  nameWithType: TypeBuilder.GetGenericTypeDefinition()
  fullName: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns a <xref href="System.Type"></xref> object that represents a generic type definition from which the current type can be obtained.
  remarks: "If you call the GetGenericTypeDefinition method on a <xref:System.Reflection.Emit.TypeBuilder> object for which the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property returns `true`, the GetGenericTypeDefinition property returns the current instance. A <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type is always a generic type definition.  \n  \n If you used the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method to construct a generic type from a <xref:System.Reflection.Emit.TypeBuilder> object that represents a generic type definition, using the <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=fullName> method on the constructed type gets back the <xref:System.Reflection.Emit.TypeBuilder> object that represents the generic type definition."
  syntax:
    content: public override Type GetGenericTypeDefinition ();
    parameters: []
    return:
      type: System.Type
      description: A <xref href="System.Type"></xref> object representing a generic type definition from which the current type can be obtained.
  overload: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The current type is not generic. That is, <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> returns <xref uid="langword_csharp_false" name="false" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)
  id: GetInterface(System.String,System.Boolean)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetInterface(String,Boolean)
  nameWithType: TypeBuilder.GetInterface(String,Boolean)
  fullName: System.Reflection.Emit.TypeBuilder.GetInterface(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override Type GetInterface (string name, bool ignoreCase);
    parameters:
    - id: name
      type: System.String
      description: The name of the interface.
    - id: ignoreCase
      type: System.Boolean
      description: If <xref uid="langword_csharp_true" name="true" href=""></xref>, the search is case-insensitive. If <xref uid="langword_csharp_false" name="false" href=""></xref>, the search is case-sensitive.
    return:
      type: System.Type
      description: Returns a <xref href="System.Type"></xref> object representing the implemented interface. Returns null if no interface matching name is found.
  overload: System.Reflection.Emit.TypeBuilder.GetInterface*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)
  id: GetInterfaceMap(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetInterfaceMap(Type)
  nameWithType: TypeBuilder.GetInterfaceMap(Type)
  fullName: System.Reflection.Emit.TypeBuilder.GetInterfaceMap(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns an interface mapping for the requested interface.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);
    parameters:
    - id: interfaceType
      type: System.Type
      description: The <xref href="System.Type"></xref> of the interface for which the mapping is to be retrieved.
    return:
      type: System.Reflection.InterfaceMapping
      description: Returns the requested interface mapping.
  overload: System.Reflection.Emit.TypeBuilder.GetInterfaceMap*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetInterfaces
  id: GetInterfaces
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetInterfaces()
  nameWithType: TypeBuilder.GetInterfaces()
  fullName: System.Reflection.Emit.TypeBuilder.GetInterfaces()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns an array of all the interfaces implemented on this type and its base types.
  syntax:
    content: public override Type[] GetInterfaces ();
    parameters: []
    return:
      type: System.Type[]
      description: Returns an array of <xref href="System.Type"></xref> objects representing the implemented interfaces. If none are defined, an empty array is returned.
  overload: System.Reflection.Emit.TypeBuilder.GetInterfaces*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  id: GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetMember(String,MemberTypes,BindingFlags)
  nameWithType: TypeBuilder.GetMember(String,MemberTypes,BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetMember(String,MemberTypes,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns all the public and non-public members declared or inherited by this type, as specified.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: The name of the member.
    - id: type
      type: System.Reflection.MemberTypes
      description: The type of the member to return.
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: This must be a bit flag from <xref href="System.Reflection.BindingFlags"></xref>, as in <xref uid="langword_csharp_InvokeMethod" name="InvokeMethod" href=""></xref>, <xref uid="langword_csharp_NonPublic" name="NonPublic" href=""></xref>, and so on.
    return:
      type: System.Reflection.MemberInfo[]
      description: Returns an array of <xref href="System.Reflection.MemberInfo"></xref> objects representing the public and non-public members defined on this type if <code>nonPublic</code> is used; otherwise, only the public members are returned.
  overload: System.Reflection.Emit.TypeBuilder.GetMember*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)
  id: GetMembers(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetMembers(BindingFlags)
  nameWithType: TypeBuilder.GetMembers(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetMembers(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the members for the public and non-public members declared or inherited by this type.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: This must be a bit flag from <xref href="System.Reflection.BindingFlags"></xref>, such as <xref uid="langword_csharp_InvokeMethod" name="InvokeMethod" href=""></xref>, <xref uid="langword_csharp_NonPublic" name="NonPublic" href=""></xref>, and so on.
    return:
      type: System.Reflection.MemberInfo[]
      description: Returns an array of <xref href="System.Reflection.MemberInfo"></xref> objects representing the public and non-public members declared or inherited by this type. An empty array is returned if there are no matching members.
  overload: System.Reflection.Emit.TypeBuilder.GetMembers*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)
  id: GetMethod(System.Type,System.Reflection.MethodInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetMethod(Type,MethodInfo)
  nameWithType: TypeBuilder.GetMethod(Type,MethodInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetMethod(Type,MethodInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.
  remarks: "The GetMethod method provides a way to get a <xref:System.Reflection.MethodInfo> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.  \n  \n For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.MethodBuilder> object that represents a method `T M()` in C# syntax (`Function M() As T` in Visual Basic, `T M()` in C++) that is defined by `G<T>`. Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls method `M` on that instance. In order to emit the function call, you need a <xref:System.Reflection.MethodInfo> object that represents `M` on the constructed type  in other words, that returns type `U` rather than type `T`. To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument. Then call the GetMethod method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.MethodBuilder> object that represents `T M()` as parameter `method`. The return value is the <xref:System.Reflection.MethodInfo> object you need to emit the function call. The code example demonstrates a scenario similar to this."
  example:
  - "The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`. The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`. Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`. This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md) and compare it to the code emitted by class `Example`.  \n  \n The code in class `Example` demonstrates the use of the GetMethod method to emit generic code. The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`. A default constructor and a field named `Field`, of type `T`, are added to class `Sample`. A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=fullName> method. The type parameter of `GM` is named `U`. After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=fullName> method. There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter. The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`. A dummy type is defined to hold the entry-point method `Main`. In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`. The GetMethod method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=fullName> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.  \n  \n When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe. You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](../Topic/Ildasm.exe%20\\(IL%20Disassembler\\).md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.  \n  \n [!code-cs[TypeBuilder.GetField_Generic#1](~/add/codesnippet/csharp/03b5c4f1-aa46-4e23-824f-_1.cs)]\n [!code-vb[TypeBuilder.GetField_Generic#1](~/add/codesnippet/visualbasic/03b5c4f1-aa46-4e23-824f-_1.vb)]"
  syntax:
    content: public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);
    parameters:
    - id: type
      type: System.Type
      description: The constructed generic type whose method is returned.
    - id: method
      type: System.Reflection.MethodInfo
      description: A method on the generic type definition of `type`, which specifies which method of `type` to return.
    return:
      type: System.Reflection.MethodInfo
      description: A <xref href="System.Reflection.MethodInfo"></xref> object that represents the method of <code>type</code> corresponding to <code>method</code>, which specifies a method belonging to the generic type definition of <code>type</code>.
  overload: System.Reflection.Emit.TypeBuilder.GetMethod*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>method</code> is a generic method that is not a generic method definition.  \n  \n -or-  \n  \n <code>type</code> does not represent a generic type.  \n  \n -or-  \n  \n <code>type</code> is not of type <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref>.  \n  \n -or-  \n  \n The declaring type of <code>method</code> is not a generic type definition.  \n  \n -or-  \n  \n The declaring type of <code>method</code> is not the generic type definition of <code>type</code>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  id: GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeBuilder.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.Emit.TypeBuilder.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: name
      type: System.String
      description: To be added.
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: To be added.
    - id: binder
      type: System.Reflection.Binder
      description: To be added.
    - id: callConvention
      type: System.Reflection.CallingConventions
      description: To be added.
    - id: types
      type: System.Type[]
      description: To be added.
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: To be added.
    return:
      type: System.Reflection.MethodInfo
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.GetMethodImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)
  id: GetMethods(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetMethods(BindingFlags)
  nameWithType: TypeBuilder.GetMethods(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetMethods(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns all the public and non-public methods declared or inherited by this type, as specified.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: This must be a bit flag from <xref href="System.Reflection.BindingFlags"></xref> as in <xref uid="langword_csharp_InvokeMethod" name="InvokeMethod" href=""></xref>, <xref uid="langword_csharp_NonPublic" name="NonPublic" href=""></xref>, and so on.
    return:
      type: System.Reflection.MethodInfo[]
      description: Returns an array of <xref href="System.Reflection.MethodInfo"></xref> objects representing the public and non-public methods defined on this type if <code>nonPublic</code> is used; otherwise, only the public methods are returned.
  overload: System.Reflection.Emit.TypeBuilder.GetMethods*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)
  id: GetNestedType(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetNestedType(String,BindingFlags)
  nameWithType: TypeBuilder.GetNestedType(String,BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetNestedType(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the public and non-public nested types that are declared by this type.
  remarks: "Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.  \n  \n If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called."
  syntax:
    content: public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: The <xref href="System.String"></xref> containing the name of the nested type to get.
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to conduct a case-sensitive search for public methods."
    return:
      type: System.Type
      description: A <xref href="System.Type"></xref> object representing the nested type that matches the specified requirements, if found; otherwise, <xref uid="langword_csharp_null" name="null" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.GetNestedType*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)
  id: GetNestedTypes(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetNestedTypes(BindingFlags)
  nameWithType: TypeBuilder.GetNestedTypes(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetNestedTypes(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the public and non-public nested types that are declared or inherited by this type.
  remarks: "Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.  \n  \n If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called."
  syntax:
    content: public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: This must be a bit flag from <xref href="System.Reflection.BindingFlags"></xref>, as in <xref uid="langword_csharp_InvokeMethod" name="InvokeMethod" href=""></xref>, <xref uid="langword_csharp_NonPublic" name="NonPublic" href=""></xref>, and so on.
    return:
      type: System.Type[]
      description: "An array of <xref href=\"System.Type\"></xref> objects representing all the types nested within the current <xref href=\"System.Type\"></xref> that match the specified binding constraints.  \n  \n An empty array of type <xref href=\"System.Type\"></xref>, if no types are nested within the current <xref href=\"System.Type\"></xref>, or if none of the nested types match the binding constraints."
  overload: System.Reflection.Emit.TypeBuilder.GetNestedTypes*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)
  id: GetProperties(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetProperties(BindingFlags)
  nameWithType: TypeBuilder.GetProperties(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetProperties(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns all the public and non-public properties declared or inherited by this type, as specified.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: 'This invocation attribute. This must be a bit flag from <xref href="System.Reflection.BindingFlags"></xref> : <xref uid="langword_csharp_InvokeMethod" name="InvokeMethod" href=""></xref>, <xref uid="langword_csharp_NonPublic" name="NonPublic" href=""></xref>, and so on.'
    return:
      type: System.Reflection.PropertyInfo[]
      description: Returns an array of <xref uid="langword_csharp_PropertyInfo" name="PropertyInfo" href=""></xref> objects representing the public and non-public properties defined on this type if <code>nonPublic</code> is used; otherwise, only the public properties are returned.
  overload: System.Reflection.Emit.TypeBuilder.GetProperties*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not implemented for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  id: GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  nameWithType: TypeBuilder.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  fullName: System.Reflection.Emit.TypeBuilder.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: name
      type: System.String
      description: To be added.
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: To be added.
    - id: binder
      type: System.Reflection.Binder
      description: To be added.
    - id: returnType
      type: System.Type
      description: To be added.
    - id: types
      type: System.Type[]
      description: To be added.
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: To be added.
    return:
      type: System.Reflection.PropertyInfo
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.GetPropertyImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.GUID
  id: GUID
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: GUID
  nameWithType: TypeBuilder.GUID
  fullName: System.Reflection.Emit.TypeBuilder.GUID
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the GUID of this type.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override Guid GUID { get; }
    return:
      type: System.Guid
      description: Read-only. Retrieves the GUID of this type
  overload: System.Reflection.Emit.TypeBuilder.GUID*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not currently supported for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.HasElementTypeImpl
  id: HasElementTypeImpl
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: HasElementTypeImpl()
  nameWithType: TypeBuilder.HasElementTypeImpl()
  fullName: System.Reflection.Emit.TypeBuilder.HasElementTypeImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override bool HasElementTypeImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.HasElementTypeImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  id: InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  nameWithType: TypeBuilder.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  fullName: System.Reflection.Emit.TypeBuilder.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Invokes the specified member. The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.
  remarks: "A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.  \n  \n The binder will find all of the matching methods. These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder. After the method is selected, it will be invoked. Accessibility is checked at that point. The search can control which set of methods are searched based upon the accessibility attribute associated with the method. The `IBinder.BindToMethod` method is responsible for selecting the method to be invoked. The default binder selects the most specific match.  \n  \n> [!NOTE]\n>  Access restrictions are ignored for fully trusted code. That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.  \n  \n This method is not currently supported. You can retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type."
  syntax:
    content: public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
    parameters:
    - id: name
      type: System.String
      description: The name of the member to invoke. This can be a constructor, method, property, or field. A suitable invocation attribute must be specified. Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.
    - id: invokeAttr
      type: System.Reflection.BindingFlags
      description: The invocation attribute. This must be a bit flag from <xref uid="langword_csharp_BindingFlags" name="BindingFlags" href=""></xref>.
    - id: binder
      type: System.Reflection.Binder
      description: An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <xref uid="langword_csharp_MemberInfo" name="MemberInfo" href=""></xref> objects using reflection. If binder is <xref uid="langword_csharp_null" name="null" href=""></xref>, the default binder is used. See <xref href="System.Reflection.Binder"></xref>.
    - id: target
      type: System.Object
      description: The object on which to invoke the specified member. If the member is static, this parameter is ignored.
    - id: args
      type: System.Object[]
      description: An argument list. This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked. If there are no parameters this should be null.
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: An array of the same length as `args` with elements that represent the attributes associated with the arguments of the member to be invoked. A parameter has attributes associated with it in the metadata. They are used by various interoperability services. See the metadata specs for more details.
    - id: culture
      type: System.Globalization.CultureInfo
      description: An instance of <xref uid="langword_csharp_CultureInfo" name="CultureInfo" href=""></xref> used to govern the coercion of types. If this is null, the <xref uid="langword_csharp_CultureInfo" name="CultureInfo" href=""></xref> for the current thread is used. (Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)
    - id: namedParameters
      type: System.String[]
      description: Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array. If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.
    return:
      type: System.Object
      description: Returns the return value of the invoked member.
  overload: System.Reflection.Emit.TypeBuilder.InvokeMember*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not currently supported for incomplete types.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsArrayImpl
  id: IsArrayImpl
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsArrayImpl()
  nameWithType: TypeBuilder.IsArrayImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsArrayImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override bool IsArrayImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.IsArrayImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)
  id: IsAssignableFrom(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsAssignableFrom(Type)
  nameWithType: TypeBuilder.IsAssignableFrom(Type)
  fullName: System.Reflection.Emit.TypeBuilder.IsAssignableFrom(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets a value that indicates whether a specified <xref href="System.Type"></xref> can be assigned to this object.
  syntax:
    content: public override bool IsAssignableFrom (Type c);
    parameters:
    - id: c
      type: System.Type
      description: The object to test.
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if the <code>c</code> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <code>c</code>, or if the current type is an interface that <code>c</code> supports. <xref uid="langword_csharp_false" name="false" href=""></xref> if none of these conditions are valid, or if <code>c</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.IsAssignableFrom*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsByRefImpl
  id: IsByRefImpl
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsByRefImpl()
  nameWithType: TypeBuilder.IsByRefImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsByRefImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override bool IsByRefImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.IsByRefImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl
  id: IsCOMObjectImpl
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsCOMObjectImpl()
  nameWithType: TypeBuilder.IsCOMObjectImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override bool IsCOMObjectImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsCreated
  id: IsCreated
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsCreated()
  nameWithType: TypeBuilder.IsCreated()
  fullName: System.Reflection.Emit.TypeBuilder.IsCreated()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns a value that indicates whether the current dynamic type has been created.
  remarks: After the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called, the type represented by the <xref:System.Reflection.Emit.TypeBuilder> object is complete. Exceptions are thrown on any further attempts to add members or change other characteristics of the type.
  syntax:
    content: public bool IsCreated ();
    parameters: []
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if the <xref:System.Reflection.Emit.TypeBuilder.CreateType*> method has been called; otherwise, <xref uid="langword_csharp_false" name="false" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.IsCreated*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)
  id: IsDefined(System.Type,System.Boolean)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsDefined(Type,Boolean)
  nameWithType: TypeBuilder.IsDefined(Type,Boolean)
  fullName: System.Reflection.Emit.TypeBuilder.IsDefined(Type,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Determines whether a custom attribute is applied to the current type.
  remarks: This method is not supported for incomplete generic type parameters. Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override bool IsDefined (Type attributeType, bool inherit);
    parameters:
    - id: attributeType
      type: System.Type
      description: The type of attribute to search for. Only attributes that are assignable to this type are returned.
    - id: inherit
      type: System.Boolean
      description: Specifies whether to search this member's inheritance chain to find the attributes.
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if one or more instances of <code>attributeType</code>, or an attribute derived from <code>attributeType</code>, is defined on this type; otherwise, <xref uid="langword_csharp_false" name="false" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.IsDefined*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: This method is not currently supported for incomplete types. Retrieve the type using <xref:System.Type.GetType*> and call <xref:System.Reflection.MemberInfo.IsDefined*> on the returned <xref href="System.Type"></xref>.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>attributeType</code> is not defined.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>attributeType</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsGenericParameter
  id: IsGenericParameter
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsGenericParameter
  nameWithType: TypeBuilder.IsGenericParameter
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericParameter
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets a value indicating whether the current type is a generic type parameter.
  remarks: >-
    > [!NOTE]

    >  When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.
  syntax:
    content: public override bool IsGenericParameter { get; }
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if the current <xref href="System.Reflection.Emit.TypeBuilder"></xref> object represents a generic type parameter; otherwise, <xref uid="langword_csharp_false" name="false" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.IsGenericParameter*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsGenericType
  id: IsGenericType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsGenericType
  nameWithType: TypeBuilder.IsGenericType
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets a value indicating whether the current type is a generic type.
  remarks: "A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters. An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.  \n  \n For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=fullName> property."
  syntax:
    content: public override bool IsGenericType { get; }
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if the type represented by the current <xref href="System.Reflection.Emit.TypeBuilder"></xref> object is generic; otherwise, <xref uid="langword_csharp_false" name="false" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.IsGenericType*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
  id: IsGenericTypeDefinition
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsGenericTypeDefinition
  nameWithType: TypeBuilder.IsGenericTypeDefinition
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets a value indicating whether the current <xref href="System.Reflection.Emit.TypeBuilder"></xref> represents a generic type definition from which other generic types can be constructed.
  remarks: "A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters. An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.  \n  \n A <xref:System.Reflection.Emit.TypeBuilder> can be used to build generic type definitions, but not constructed generic types. To get a constructed generic type, call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.  \n  \n For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=fullName> property."
  syntax:
    content: public override bool IsGenericTypeDefinition { get; }
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if this <xref href="System.Reflection.Emit.TypeBuilder"></xref> object represents a generic type definition; otherwise, <xref uid="langword_csharp_false" name="false" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsPointerImpl
  id: IsPointerImpl
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsPointerImpl()
  nameWithType: TypeBuilder.IsPointerImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsPointerImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override bool IsPointerImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.IsPointerImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl
  id: IsPrimitiveImpl
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsPrimitiveImpl()
  nameWithType: TypeBuilder.IsPrimitiveImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  syntax:
    content: protected override bool IsPrimitiveImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: To be added.
  overload: System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsSecurityCritical
  id: IsSecurityCritical
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsSecurityCritical
  nameWithType: TypeBuilder.IsSecurityCritical
  fullName: System.Reflection.Emit.TypeBuilder.IsSecurityCritical
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.
  remarks: "The IsSecurityCritical, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \n  \n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \n|--------------------|------------------------|----------------------------|---------------------------|  \n|Critical|`true`|`false`|`false`|  \n|Safe-critical|`true`|`true`|`false`|  \n|Transparent|`false`|`false`|`true`|  \n  \n Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n The runtime begins evaluating transparency levels at the assembly. For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.  \n  \n By default, a dynamic assembly inherits the transparency of the assembly that emits it. You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName> method overload and specifying security attributes. You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code. Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.  \n  \n> [!NOTE]\n>  Default inheritance is limited to the runtime's evaluation of transparency. No attributes are applied to the dynamic assembly. If you want to add security attributes, you must apply them yourself.  \n  \n For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/add/includes/ajax-current-ext-md.md). For information about transparency, see [Security Changes](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override bool IsSecurityCritical { get; }
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if the current type is security-critical or security-safe-critical; <xref uid="langword_csharp_false" name="false" href=""></xref> if it is transparent.
  overload: System.Reflection.Emit.TypeBuilder.IsSecurityCritical*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: The current dynamic type has not been created by calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType*> method.
  platform:
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical
  id: IsSecuritySafeCritical
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsSecuritySafeCritical
  nameWithType: TypeBuilder.IsSecuritySafeCritical
  fullName: System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.
  remarks: "The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, IsSecuritySafeCritical, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \n  \n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \n|--------------------|------------------------|----------------------------|---------------------------|  \n|Critical|`true`|`false`|`false`|  \n|Safe-critical|`true`|`true`|`false`|  \n|Transparent|`false`|`false`|`true`|  \n  \n Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n The runtime begins evaluating transparency levels at the assembly. For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.  \n  \n By default, a dynamic assembly inherits the transparency of the assembly that emits it. You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName> method overload and specifying security attributes. You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code. Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.  \n  \n> [!NOTE]\n>  Default inheritance is limited to the runtime's evaluation of transparency. No attributes are applied to the dynamic assembly. If you want to add security attributes, you must apply them yourself.  \n  \n For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/add/includes/ajax-current-ext-md.md). For information about transparency, see [Security Changes](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override bool IsSecuritySafeCritical { get; }
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if the current type is security-safe-critical; <xref uid="langword_csharp_false" name="false" href=""></xref> if it is security-critical or transparent.
  overload: System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: The current dynamic type has not been created by calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType*> method.
  platform:
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsSecurityTransparent
  id: IsSecurityTransparent
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsSecurityTransparent
  nameWithType: TypeBuilder.IsSecurityTransparent
  fullName: System.Reflection.Emit.TypeBuilder.IsSecurityTransparent
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.
  remarks: "The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and IsSecurityTransparent properties report the transparency level of the type, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \n  \n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \n|--------------------|------------------------|----------------------------|---------------------------|  \n|Critical|`true`|`false`|`false`|  \n|Safe-critical|`true`|`true`|`false`|  \n|Transparent|`false`|`false`|`true`|  \n  \n Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n The runtime begins evaluating transparency levels at the assembly. For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.  \n  \n By default, a dynamic assembly inherits the transparency of the assembly that emits it. You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=fullName> method overload and specifying security attributes. You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code. Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.  \n  \n> [!NOTE]\n>  Default inheritance is limited to the runtime's evaluation of transparency. No attributes are applied to the dynamic assembly. If you want to add security attributes, you must apply them yourself.  \n  \n For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/add/includes/ajax-current-ext-md.md). For information about transparency, see [Security Changes](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public override bool IsSecurityTransparent { get; }
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if the type is security-transparent; otherwise, <xref uid="langword_csharp_false" name="false" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.IsSecurityTransparent*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: The current dynamic type has not been created by calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType*> method.
  platform:
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)
  id: IsSubclassOf(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: IsSubclassOf(Type)
  nameWithType: TypeBuilder.IsSubclassOf(Type)
  fullName: System.Reflection.Emit.TypeBuilder.IsSubclassOf(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Determines whether this type is derived from a specified type.
  syntax:
    content: public override bool IsSubclassOf (Type c);
    parameters:
    - id: c
      type: System.Type
      description: A <xref href="System.Type"></xref> that is to be checked.
    return:
      type: System.Boolean
      description: Read-only. Returns <xref uid="langword_csharp_true" name="true" href=""></xref> if this type is the same as the type <code>c</code>, or is a subtype of type <code>c</code>; otherwise, <xref uid="langword_csharp_false" name="false" href=""></xref>.
  overload: System.Reflection.Emit.TypeBuilder.IsSubclassOf*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.MakeArrayType
  id: MakeArrayType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: MakeArrayType()
  nameWithType: TypeBuilder.MakeArrayType()
  fullName: System.Reflection.Emit.TypeBuilder.MakeArrayType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns a <xref href="System.Type"></xref> object that represents a one-dimensional array of the current type, with a lower bound of zero.
  remarks: The MakeArrayType method provides a way to generate an array type with any possible element type, including generic types.
  example:
  - "The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`. `TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`. It returns a two-dimensional array of type `Sample`. The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[MakeXxxTypeBuilder#1](~/add/codesnippet/csharp/m-system.reflection.emit_55_1.cs)]\n [!code-vb[MakeXxxTypeBuilder#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_55_1.vb)]"
  syntax:
    content: public override Type MakeArrayType ();
    parameters: []
    return:
      type: System.Type
      description: A <xref href="System.Type"></xref> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.
  overload: System.Reflection.Emit.TypeBuilder.MakeArrayType*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)
  id: MakeArrayType(System.Int32)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: MakeArrayType(Int32)
  nameWithType: TypeBuilder.MakeArrayType(Int32)
  fullName: System.Reflection.Emit.TypeBuilder.MakeArrayType(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns a <xref href="System.Type"></xref> object that represents an array of the current type, with the specified number of dimensions.
  remarks: The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.
  example:
  - "The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`. `TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`. It returns a two-dimensional array of type `Sample`. The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[MakeXxxTypeBuilder#1](~/add/codesnippet/csharp/m-system.reflection.emit_28_1.cs)]\n [!code-vb[MakeXxxTypeBuilder#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_28_1.vb)]"
  syntax:
    content: public override Type MakeArrayType (int rank);
    parameters:
    - id: rank
      type: System.Int32
      description: The number of dimensions for the array.
    return:
      type: System.Type
      description: A <xref href="System.Type"></xref> object that represents a one-dimensional array of the current type.
  overload: System.Reflection.Emit.TypeBuilder.MakeArrayType*
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: <code>rank</code> is not a valid array dimension.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.MakeByRefType
  id: MakeByRefType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: MakeByRefType()
  nameWithType: TypeBuilder.MakeByRefType()
  fullName: System.Reflection.Emit.TypeBuilder.MakeByRefType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns a <xref href="System.Type"></xref> object that represents the current type when passed as a <xref uid="langword_csharp_ref" name="ref" href=""></xref> parameter (<xref uid="langword_csharp_ByRef" name="ByRef" href=""></xref> in Visual Basic).
  remarks: "The MakeByRefType method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.  \n  \n> [!NOTE]\n>  Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType&`."
  example:
  - "The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`. `TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`. It returns a two-dimensional array of type `Sample`. The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[MakeXxxTypeBuilder#1](~/add/codesnippet/csharp/m-system.reflection.emit_9_1.cs)]\n [!code-vb[MakeXxxTypeBuilder#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_9_1.vb)]"
  syntax:
    content: public override Type MakeByRefType ();
    parameters: []
    return:
      type: System.Type
      description: A <xref href="System.Type"></xref> object that represents the current type when passed as a <xref uid="langword_csharp_ref" name="ref" href=""></xref> parameter (<xref uid="langword_csharp_ByRef" name="ByRef" href=""></xref> in Visual Basic).
  overload: System.Reflection.Emit.TypeBuilder.MakeByRefType*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  id: MakeGenericType(System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: MakeGenericType(Type[])
  nameWithType: TypeBuilder.MakeGenericType(Type[])
  fullName: System.Reflection.Emit.TypeBuilder.MakeGenericType(Type[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.
  remarks: "Use this method when your emitted code requires a type constructed from the current generic type definition. It is not necessary to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method before calling the MakeGenericType method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition. If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent the definition of a generic type, an <xref:System.InvalidOperationException> is thrown.  \n  \n The object returned by this method functions as a placeholder for a constructed generic type in your emitted code. It is an instance of a class derived from <xref:System.Type> that has limited capabilities. In particular:  \n  \n-   To get methods, fields, and constructors for these constructed generic types, use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> method overloads.  \n  \n-   Two instances that represent the same constructed type do not compare as equal. For example, in the following code `t1.Equals(t2)` returns `false`:  \n  \n [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_54_1.vb)]\n [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/add/codesnippet/cpp/m-system.reflection.emit_54_1.cpp)]\n [!code-cs[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/add/codesnippet/csharp/m-system.reflection.emit_54_1.cs)]"
  syntax:
    content: public override Type MakeGenericType (Type[] typeArguments);
    parameters:
    - id: typeArguments
      type: System.Type[]
      description: An array of types to be substituted for the type parameters of the current generic type definition.
    return:
      type: System.Type
      description: A <xref href="System.Type"></xref> representing the constructed type formed by substituting the elements of <code>typeArguments</code> for the type parameters of the current generic type.
  overload: System.Reflection.Emit.TypeBuilder.MakeGenericType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The current type does not represent the definition of a generic type. That is, <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> returns <xref uid="langword_csharp_false" name="false" href=""></xref>.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>typeArguments</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n -or-  \n  \n Any element of <code>typeArguments</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Type.Module*> property of any element of <code>typeArguments</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n -or-  \n  \n The <xref:System.Reflection.Module.Assembly*> property of the module of any element of <code>typeArguments</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>."
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.MakePointerType
  id: MakePointerType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: MakePointerType()
  nameWithType: TypeBuilder.MakePointerType()
  fullName: System.Reflection.Emit.TypeBuilder.MakePointerType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns a <xref href="System.Type"></xref> object that represents the type of an unmanaged pointer to the current type.
  remarks: "The MakePointerType method provides a way to generate pointer types for parameter lists.  \n  \n> [!NOTE]\n>  Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType*`."
  example:
  - "The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`. `TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`. It returns a two-dimensional array of type `Sample`. The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[MakeXxxTypeBuilder#1](~/add/codesnippet/csharp/m-system.reflection.emit_1_1.cs)]\n [!code-vb[MakeXxxTypeBuilder#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_1_1.vb)]"
  syntax:
    content: public override Type MakePointerType ();
    parameters: []
    return:
      type: System.Type
      description: A <xref href="System.Type"></xref> object that represents the type of an unmanaged pointer to the current type.
  overload: System.Reflection.Emit.TypeBuilder.MakePointerType*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.Module
  id: Module
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: Module
  nameWithType: TypeBuilder.Module
  fullName: System.Reflection.Emit.TypeBuilder.Module
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the dynamic module that contains this type definition.
  syntax:
    content: public override System.Reflection.Module Module { get; }
    return:
      type: System.Reflection.Module
      description: Read-only. Retrieves the dynamic module that contains this type definition.
  overload: System.Reflection.Emit.TypeBuilder.Module*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.Name
  id: Name
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: Name
  nameWithType: TypeBuilder.Name
  fullName: System.Reflection.Emit.TypeBuilder.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the name of this type.
  syntax:
    content: public override string Name { get; }
    return:
      type: System.String
      description: Read-only. Retrieves the <xref href="System.String"></xref> name of this type.
  overload: System.Reflection.Emit.TypeBuilder.Name*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.Namespace
  id: Namespace
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: Namespace
  nameWithType: TypeBuilder.Namespace
  fullName: System.Reflection.Emit.TypeBuilder.Namespace
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the namespace where this <xref uid="langword_csharp_TypeBuilder" name="TypeBuilder" href=""></xref> is defined.
  syntax:
    content: public override string Namespace { get; }
    return:
      type: System.String
      description: Read-only. Retrieves the namespace where this <xref uid="langword_csharp_TypeBuilder" name="TypeBuilder" href=""></xref> is defined.
  overload: System.Reflection.Emit.TypeBuilder.Namespace*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.PackingSize
  id: PackingSize
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: PackingSize
  nameWithType: TypeBuilder.PackingSize
  fullName: System.Reflection.Emit.TypeBuilder.PackingSize
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the packing size of this type.
  syntax:
    content: public System.Reflection.Emit.PackingSize PackingSize { get; }
    return:
      type: System.Reflection.Emit.PackingSize
      description: Read-only. Retrieves the packing size of this type.
  overload: System.Reflection.Emit.TypeBuilder.PackingSize*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.ReflectedType
  id: ReflectedType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: ReflectedType
  nameWithType: TypeBuilder.ReflectedType
  fullName: System.Reflection.Emit.TypeBuilder.ReflectedType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the type that was used to obtain this type.
  syntax:
    content: public override Type ReflectedType { get; }
    return:
      type: System.Type
      description: Read-only. The type that was used to obtain this type.
  overload: System.Reflection.Emit.TypeBuilder.ReflectedType*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  id: SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: SetCustomAttribute(CustomAttributeBuilder)
  nameWithType: TypeBuilder.SetCustomAttribute(CustomAttributeBuilder)
  fullName: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(CustomAttributeBuilder)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Set a custom attribute using a custom attribute builder.
  remarks: >-
    > [!NOTE]

    >  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](~/add/includes/ajax-current-ext-md.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.
  syntax:
    content: public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);
    parameters:
    - id: customBuilder
      type: System.Reflection.Emit.CustomAttributeBuilder
      description: An instance of a helper class to define the custom attribute.
  overload: System.Reflection.Emit.TypeBuilder.SetCustomAttribute*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>customBuilder</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid="langword_csharp_true" name="true" href=""></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid="langword_csharp_false" name="false" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])
  id: SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: SetCustomAttribute(ConstructorInfo,Byte[])
  nameWithType: TypeBuilder.SetCustomAttribute(ConstructorInfo,Byte[])
  fullName: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(ConstructorInfo,Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Sets a custom attribute using a specified custom attribute blob.
  remarks: "For more information on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially \"Partition II: Metadata Definition and Semantics\". The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.  \n  \n> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](~/add/includes/ajax-current-ext-md.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later."
  syntax:
    content: public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
    parameters:
    - id: con
      type: System.Reflection.ConstructorInfo
      description: The constructor for the custom attribute.
    - id: binaryAttribute
      type: System.Byte[]
      description: A byte blob representing the attributes.
  overload: System.Reflection.Emit.TypeBuilder.SetCustomAttribute*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>con</code> or <code>binaryAttribute</code> is <xref uid="langword_csharp_null" name="null" href=""></xref>.
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid="langword_csharp_true" name="true" href=""></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid="langword_csharp_false" name="false" href=""></xref>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.SetParent(System.Type)
  id: SetParent(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: SetParent(Type)
  nameWithType: TypeBuilder.SetParent(Type)
  fullName: System.Reflection.Emit.TypeBuilder.SetParent(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Sets the base type of the type currently under construction.
  remarks: "If `parent` is `null`, <xref:System.Object> is used as the base type.  \n  \n In the .NET Framework versions 1.0 and 1.1, no exception is thrown if `parent` is an interface type, but a <xref:System.TypeLoadException> is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.  \n  \n The SetParent method does not check for most invalid parent types. For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <xref:System.Delegate> type. In all these cases, exceptions are thrown by the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method."
  syntax:
    content: public void SetParent (Type parent);
    parameters:
    - id: parent
      type: System.Type
      description: The new base type.
  overload: System.Reflection.Emit.TypeBuilder.SetParent*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.  \n  \n -or-  \n  \n <code>parent</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>, and the current instance represents an interface whose attributes do not include <xref href=\"System.Reflection.TypeAttributes\"></xref>.  \n  \n -or-  \n  \n For the current dynamic type, the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType*> property is <xref uid=\"langword_csharp_true\" name=\"true\" href=\"\"></xref>, but the <xref:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*> property is <xref uid=\"langword_csharp_false\" name=\"false\" href=\"\"></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>parent</code> is an interface. This exception condition is new in the .NET Framework version 2.0.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.Size
  id: Size
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: Size
  nameWithType: TypeBuilder.Size
  fullName: System.Reflection.Emit.TypeBuilder.Size
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the total size of a type.
  syntax:
    content: public int Size { get; }
    return:
      type: System.Int32
      description: Read-only. Retrieves this types total size.
  overload: System.Reflection.Emit.TypeBuilder.Size*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Reflection.Emit.TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Maps a set of names to a corresponding set of dispatch identifiers.
  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.
  syntax:
    content: void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: Reserved for future use. Must be IID_NULL.
    - id: rgszNames
      type: System.IntPtr
      description: Passed-in array of names to be mapped.
    - id: cNames
      type: System.UInt32
      description: Count of the names to be mapped.
    - id: lcid
      type: System.UInt32
      description: The locale context in which to interpret the names.
    - id: rgDispId
      type: System.IntPtr
      description: Caller-allocated array which receives the IDs corresponding to the names.
  overload: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: Late-bound access using the COM `IDispatch` interface is not supported.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Reflection.Emit.TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the type information for an object, which can then be used to get the type information for an interface.
  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.
  syntax:
    content: void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: The type information to return.
    - id: lcid
      type: System.UInt32
      description: The locale identifier for the type information.
    - id: ppTInfo
      type: System.IntPtr
      description: Receives a pointer to the requested type information object.
  overload: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: Late-bound access using the COM `IDispatch` interface is not supported.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32)
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32)
  fullName: System.Reflection.Emit.TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Retrieves the number of type information interfaces that an object provides (either 0 or 1).
  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.
  syntax:
    content: void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: Points to a location that receives the number of type information interfaces provided by the object.
  overload: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: Late-bound access using the COM `IDispatch` interface is not supported.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Reflection.Emit.TypeBuilder.System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Provides access to properties and methods exposed by an object.
  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::Invoke`, see the MSDN Library.
  syntax:
    content: void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: Identifies the member.
    - id: riid
      type: System.Guid
      description: Reserved for future use. Must be IID_NULL.
    - id: lcid
      type: System.UInt32
      description: The locale context in which to interpret arguments.
    - id: wFlags
      type: System.Int16
      description: Flags describing the context of the call.
    - id: pDispParams
      type: System.IntPtr
      description: Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.
    - id: pVarResult
      type: System.IntPtr
      description: Pointer to the location where the result is to be stored.
    - id: pExcepInfo
      type: System.IntPtr
      description: Pointer to a structure that contains exception information.
    - id: puArgErr
      type: System.IntPtr
      description: The index of the first argument that has an error.
  overload: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: Late-bound access using the COM `IDispatch` interface is not supported.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.ToString
  id: ToString
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: ToString()
  nameWithType: TypeBuilder.ToString()
  fullName: System.Reflection.Emit.TypeBuilder.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the name of the type excluding the namespace.
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: Read-only. The name of the type excluding the namespace.
  overload: System.Reflection.Emit.TypeBuilder.ToString*
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.TypeHandle
  id: TypeHandle
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: TypeHandle
  nameWithType: TypeBuilder.TypeHandle
  fullName: System.Reflection.Emit.TypeBuilder.TypeHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Not supported in dynamic modules.
  remarks: Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> and use reflection on the retrieved type.
  syntax:
    content: public override RuntimeTypeHandle TypeHandle { get; }
    return:
      type: System.RuntimeTypeHandle
      description: Read-only.
  overload: System.Reflection.Emit.TypeBuilder.TypeHandle*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: Not supported in dynamic modules.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.TypeToken
  id: TypeToken
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: TypeToken
  nameWithType: TypeBuilder.TypeToken
  fullName: System.Reflection.Emit.TypeBuilder.TypeToken
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the type token of this type.
  syntax:
    content: public System.Reflection.Emit.TypeToken TypeToken { get; }
    return:
      type: System.Reflection.Emit.TypeToken
      description: Read-only. Returns the <xref uid="langword_csharp_TypeToken" name="TypeToken" href=""></xref> of this type.
  overload: System.Reflection.Emit.TypeBuilder.TypeToken*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: The type was previously created using <xref:System.Reflection.Emit.TypeBuilder.CreateType*>.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.UnderlyingSystemType
  id: UnderlyingSystemType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: UnderlyingSystemType
  nameWithType: TypeBuilder.UnderlyingSystemType
  fullName: System.Reflection.Emit.TypeBuilder.UnderlyingSystemType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Returns the underlying system type for this <xref uid="langword_csharp_TypeBuilder" name="TypeBuilder" href=""></xref>.
  syntax:
    content: public override Type UnderlyingSystemType { get; }
    return:
      type: System.Type
      description: Read-only. Returns the underlying system type.
  overload: System.Reflection.Emit.TypeBuilder.UnderlyingSystemType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: This type is an enumeration, but there is no underlying system type.
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
- uid: System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
  id: UnspecifiedTypeSize
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  name: UnspecifiedTypeSize
  nameWithType: TypeBuilder.UnspecifiedTypeSize
  fullName: System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
  type: Field
  assemblies:
  - mscorlib
  namespace: System.Reflection.Emit
  summary: Represents that total size for the type is not specified.
  syntax:
    content: public const int UnspecifiedTypeSize = 0;
    return:
      type: System.Int32
      description: To be added.
  exceptions: []
  platform:
  - netframework-2.0
  - netframework-3.0
  - netframework-3.5
  - netframework-4.0
references:
- uid: System.Type
  isExternal: false
  name: System.Type
- uid: System.ArgumentOutOfRangeException
  parent: System
  isExternal: false
  name: ArgumentOutOfRangeException
  nameWithType: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  nameWithType: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.ArgumentNullException
  parent: System
  isExternal: false
  name: ArgumentNullException
  nameWithType: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  nameWithType: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.TypeLoadException
  parent: System
  isExternal: false
  name: TypeLoadException
  nameWithType: TypeLoadException
  fullName: System.TypeLoadException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  nameWithType: ArgumentException
  fullName: System.ArgumentException
- uid: System.IndexOutOfRangeException
  parent: System
  isExternal: false
  name: IndexOutOfRangeException
  nameWithType: IndexOutOfRangeException
  fullName: System.IndexOutOfRangeException
- uid: System.NotImplementedException
  parent: System
  isExternal: false
  name: NotImplementedException
  nameWithType: NotImplementedException
  fullName: System.NotImplementedException
- uid: System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: AddDeclarativeSecurity(SecurityAction,PermissionSet)
  nameWithType: TypeBuilder.AddDeclarativeSecurity(SecurityAction,PermissionSet)
  fullName: System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(SecurityAction,PermissionSet)
- uid: System.Security.Permissions.SecurityAction
  parent: System.Security.Permissions
  isExternal: false
  name: SecurityAction
  nameWithType: SecurityAction
  fullName: System.Security.Permissions.SecurityAction
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: AddInterfaceImplementation(Type)
  nameWithType: TypeBuilder.AddInterfaceImplementation(Type)
  fullName: System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(Type)
- uid: System.Reflection.Emit.TypeBuilder.Assembly
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Assembly
  nameWithType: TypeBuilder.Assembly
  fullName: System.Reflection.Emit.TypeBuilder.Assembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: false
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: AssemblyQualifiedName
  nameWithType: TypeBuilder.AssemblyQualifiedName
  fullName: System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
- uid: System.String
  parent: System
  isExternal: false
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Reflection.Emit.TypeBuilder.BaseType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: BaseType
  nameWithType: TypeBuilder.BaseType
  fullName: System.Reflection.Emit.TypeBuilder.BaseType
- uid: System.Reflection.Emit.TypeBuilder.CreateType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: CreateType()
  nameWithType: TypeBuilder.CreateType()
  fullName: System.Reflection.Emit.TypeBuilder.CreateType()
- uid: System.Reflection.Emit.TypeBuilder.DeclaringMethod
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DeclaringMethod
  nameWithType: TypeBuilder.DeclaringMethod
  fullName: System.Reflection.Emit.TypeBuilder.DeclaringMethod
- uid: System.Reflection.MethodBase
  parent: System.Reflection
  isExternal: false
  name: MethodBase
  nameWithType: MethodBase
  fullName: System.Reflection.MethodBase
- uid: System.Reflection.Emit.TypeBuilder.DeclaringType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DeclaringType
  nameWithType: TypeBuilder.DeclaringType
  fullName: System.Reflection.Emit.TypeBuilder.DeclaringType
- uid: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineConstructor(MethodAttributes,CallingConventions,Type[])
  nameWithType: TypeBuilder.DefineConstructor(MethodAttributes,CallingConventions,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineConstructor(MethodAttributes,CallingConventions,Type[])
- uid: System.Reflection.Emit.ConstructorBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: ConstructorBuilder
  nameWithType: ConstructorBuilder
  fullName: System.Reflection.Emit.ConstructorBuilder
- uid: System.Reflection.MethodAttributes
  parent: System.Reflection
  isExternal: false
  name: MethodAttributes
  nameWithType: MethodAttributes
  fullName: System.Reflection.MethodAttributes
- uid: System.Reflection.CallingConventions
  parent: System.Reflection
  isExternal: false
  name: CallingConventions
  nameWithType: CallingConventions
  fullName: System.Reflection.CallingConventions
- uid: System.Type[]
  parent: System
  isExternal: false
  name: Type
  nameWithType: Type
  fullName: System.Type[]
  spec.csharp:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineConstructor(MethodAttributes,CallingConventions,Type[],Type[][],Type[][])
  nameWithType: TypeBuilder.DefineConstructor(MethodAttributes,CallingConventions,Type[],Type[][],Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineConstructor(MethodAttributes,CallingConventions,Type[],Type[][],Type[][])
- uid: System.Type[][]
  parent: System
  isExternal: false
  name: Type
  nameWithType: Type
  fullName: System.Type[][]
  spec.csharp:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type[][]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineDefaultConstructor(MethodAttributes)
  nameWithType: TypeBuilder.DefineDefaultConstructor(MethodAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(MethodAttributes)
- uid: System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineEvent(String,EventAttributes,Type)
  nameWithType: TypeBuilder.DefineEvent(String,EventAttributes,Type)
  fullName: System.Reflection.Emit.TypeBuilder.DefineEvent(String,EventAttributes,Type)
- uid: System.Reflection.Emit.EventBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: EventBuilder
  nameWithType: EventBuilder
  fullName: System.Reflection.Emit.EventBuilder
- uid: System.Reflection.EventAttributes
  parent: System.Reflection
  isExternal: false
  name: EventAttributes
  nameWithType: EventAttributes
  fullName: System.Reflection.EventAttributes
- uid: System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineField(String,Type,FieldAttributes)
  nameWithType: TypeBuilder.DefineField(String,Type,FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineField(String,Type,FieldAttributes)
- uid: System.Reflection.Emit.FieldBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: FieldBuilder
  nameWithType: FieldBuilder
  fullName: System.Reflection.Emit.FieldBuilder
- uid: System.Reflection.FieldAttributes
  parent: System.Reflection
  isExternal: false
  name: FieldAttributes
  nameWithType: FieldAttributes
  fullName: System.Reflection.FieldAttributes
- uid: System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineField(String,Type,Type[],Type[],FieldAttributes)
  nameWithType: TypeBuilder.DefineField(String,Type,Type[],Type[],FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineField(String,Type,Type[],Type[],FieldAttributes)
- uid: System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineGenericParameters(String[])
  nameWithType: TypeBuilder.DefineGenericParameters(String[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineGenericParameters(String[])
- uid: System.Reflection.Emit.GenericTypeParameterBuilder[]
  parent: System.Reflection.Emit
  isExternal: false
  name: GenericTypeParameterBuilder
  nameWithType: GenericTypeParameterBuilder
  fullName: System.Reflection.Emit.GenericTypeParameterBuilder[]
  spec.csharp:
  - uid: System.Reflection.Emit.GenericTypeParameterBuilder
    name: GenericTypeParameterBuilder
    nameWithType: GenericTypeParameterBuilder
    fullName: GenericTypeParameterBuilder[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.String[]
  parent: System
  isExternal: false
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineInitializedData(String,Byte[],FieldAttributes)
  nameWithType: TypeBuilder.DefineInitializedData(String,Byte[],FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineInitializedData(String,Byte[],FieldAttributes)
- uid: System.Byte[]
  parent: System
  isExternal: false
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineMethod(String,MethodAttributes)
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes)
- uid: System.Reflection.Emit.MethodBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: MethodBuilder
  nameWithType: MethodBuilder
  fullName: System.Reflection.Emit.MethodBuilder
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineMethod(String,MethodAttributes,CallingConventions)
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions)
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineMethod(String,MethodAttributes,Type,Type[])
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes,Type,Type[])
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[])
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[])
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  nameWithType: TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
- uid: System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineMethodOverride(MethodInfo,MethodInfo)
  nameWithType: TypeBuilder.DefineMethodOverride(MethodInfo,MethodInfo)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethodOverride(MethodInfo,MethodInfo)
- uid: System.Reflection.MethodInfo
  parent: System.Reflection
  isExternal: false
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineNestedType(String)
  nameWithType: TypeBuilder.DefineNestedType(String)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String)
- uid: System.Reflection.Emit.TypeBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: TypeBuilder
  nameWithType: TypeBuilder
  fullName: System.Reflection.Emit.TypeBuilder
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineNestedType(String,TypeAttributes)
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes)
- uid: System.Reflection.TypeAttributes
  parent: System.Reflection
  isExternal: false
  name: TypeAttributes
  nameWithType: TypeAttributes
  fullName: System.Reflection.TypeAttributes
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineNestedType(String,TypeAttributes,Type)
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes,Type)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes,Type)
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineNestedType(String,TypeAttributes,Type,Int32)
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes,Type,Int32)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes,Type,Int32)
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineNestedType(String,TypeAttributes,Type,PackingSize)
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes,Type,PackingSize)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes,Type,PackingSize)
- uid: System.Reflection.Emit.PackingSize
  parent: System.Reflection.Emit
  isExternal: false
  name: PackingSize
  nameWithType: PackingSize
  fullName: System.Reflection.Emit.PackingSize
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineNestedType(String,TypeAttributes,Type,Type[])
  nameWithType: TypeBuilder.DefineNestedType(String,TypeAttributes,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(String,TypeAttributes,Type,Type[])
- uid: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefinePInvokeMethod(String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  nameWithType: TypeBuilder.DefinePInvokeMethod(String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  fullName: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
- uid: System.Runtime.InteropServices.CallingConvention
  parent: System.Runtime.InteropServices
  isExternal: false
  name: CallingConvention
  nameWithType: CallingConvention
  fullName: System.Runtime.InteropServices.CallingConvention
- uid: System.Runtime.InteropServices.CharSet
  parent: System.Runtime.InteropServices
  isExternal: false
  name: CharSet
  nameWithType: CharSet
  fullName: System.Runtime.InteropServices.CharSet
- uid: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  nameWithType: TypeBuilder.DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
  fullName: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],CallingConvention,CharSet)
- uid: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][],CallingConvention,CharSet)
  nameWithType: TypeBuilder.DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][],CallingConvention,CharSet)
  fullName: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(String,String,String,MethodAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][],CallingConvention,CharSet)
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineProperty(String,PropertyAttributes,Type,Type[])
  nameWithType: TypeBuilder.DefineProperty(String,PropertyAttributes,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(String,PropertyAttributes,Type,Type[])
- uid: System.Reflection.Emit.PropertyBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: PropertyBuilder
  nameWithType: PropertyBuilder
  fullName: System.Reflection.Emit.PropertyBuilder
- uid: System.Reflection.PropertyAttributes
  parent: System.Reflection
  isExternal: false
  name: PropertyAttributes
  nameWithType: PropertyAttributes
  fullName: System.Reflection.PropertyAttributes
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[])
  nameWithType: TypeBuilder.DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[])
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineProperty(String,PropertyAttributes,Type,Type[],Type[],Type[],Type[][],Type[][])
  nameWithType: TypeBuilder.DefineProperty(String,PropertyAttributes,Type,Type[],Type[],Type[],Type[][],Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(String,PropertyAttributes,Type,Type[],Type[],Type[],Type[][],Type[][])
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  nameWithType: TypeBuilder.DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(String,PropertyAttributes,CallingConventions,Type,Type[],Type[],Type[],Type[][],Type[][])
- uid: System.Reflection.Emit.TypeBuilder.DefineTypeInitializer
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineTypeInitializer()
  nameWithType: TypeBuilder.DefineTypeInitializer()
  fullName: System.Reflection.Emit.TypeBuilder.DefineTypeInitializer()
- uid: System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineUninitializedData(String,Int32,FieldAttributes)
  nameWithType: TypeBuilder.DefineUninitializedData(String,Int32,FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineUninitializedData(String,Int32,FieldAttributes)
- uid: System.Reflection.Emit.TypeBuilder.FullName
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: FullName
  nameWithType: TypeBuilder.FullName
  fullName: System.Reflection.Emit.TypeBuilder.FullName
- uid: System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GenericParameterAttributes
  nameWithType: TypeBuilder.GenericParameterAttributes
  fullName: System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
- uid: System.Reflection.GenericParameterAttributes
  parent: System.Reflection
  isExternal: false
  name: GenericParameterAttributes
  nameWithType: GenericParameterAttributes
  fullName: System.Reflection.GenericParameterAttributes
- uid: System.Reflection.Emit.TypeBuilder.GenericParameterPosition
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GenericParameterPosition
  nameWithType: TypeBuilder.GenericParameterPosition
  fullName: System.Reflection.Emit.TypeBuilder.GenericParameterPosition
- uid: System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetAttributeFlagsImpl()
  nameWithType: TypeBuilder.GetAttributeFlagsImpl()
  fullName: System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl()
- uid: System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetConstructor(Type,ConstructorInfo)
  nameWithType: TypeBuilder.GetConstructor(Type,ConstructorInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetConstructor(Type,ConstructorInfo)
- uid: System.Reflection.ConstructorInfo
  parent: System.Reflection
  isExternal: false
  name: ConstructorInfo
  nameWithType: ConstructorInfo
  fullName: System.Reflection.ConstructorInfo
- uid: System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeBuilder.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.Emit.TypeBuilder.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Reflection.ParameterModifier[]
  parent: System.Reflection
  isExternal: false
  name: ParameterModifier
  nameWithType: ParameterModifier
  fullName: System.Reflection.ParameterModifier[]
  spec.csharp:
  - uid: System.Reflection.ParameterModifier
    name: ParameterModifier
    nameWithType: ParameterModifier
    fullName: ParameterModifier[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetConstructors(BindingFlags)
  nameWithType: TypeBuilder.GetConstructors(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetConstructors(BindingFlags)
- uid: System.Reflection.ConstructorInfo[]
  parent: System.Reflection
  isExternal: false
  name: ConstructorInfo
  nameWithType: ConstructorInfo
  fullName: System.Reflection.ConstructorInfo[]
  spec.csharp:
  - uid: System.Reflection.ConstructorInfo
    name: ConstructorInfo
    nameWithType: ConstructorInfo
    fullName: ConstructorInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetCustomAttributes(Boolean)
  nameWithType: TypeBuilder.GetCustomAttributes(Boolean)
  fullName: System.Reflection.Emit.TypeBuilder.GetCustomAttributes(Boolean)
- uid: System.Object[]
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetCustomAttributes(Type,Boolean)
  nameWithType: TypeBuilder.GetCustomAttributes(Type,Boolean)
  fullName: System.Reflection.Emit.TypeBuilder.GetCustomAttributes(Type,Boolean)
- uid: System.Reflection.Emit.TypeBuilder.GetElementType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetElementType()
  nameWithType: TypeBuilder.GetElementType()
  fullName: System.Reflection.Emit.TypeBuilder.GetElementType()
- uid: System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetEvent(String,BindingFlags)
  nameWithType: TypeBuilder.GetEvent(String,BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetEvent(String,BindingFlags)
- uid: System.Reflection.EventInfo
  parent: System.Reflection
  isExternal: false
  name: EventInfo
  nameWithType: EventInfo
  fullName: System.Reflection.EventInfo
- uid: System.Reflection.Emit.TypeBuilder.GetEvents
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetEvents()
  nameWithType: TypeBuilder.GetEvents()
  fullName: System.Reflection.Emit.TypeBuilder.GetEvents()
- uid: System.Reflection.EventInfo[]
  parent: System.Reflection
  isExternal: false
  name: EventInfo
  nameWithType: EventInfo
  fullName: System.Reflection.EventInfo[]
  spec.csharp:
  - uid: System.Reflection.EventInfo
    name: EventInfo
    nameWithType: EventInfo
    fullName: EventInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetEvents(BindingFlags)
  nameWithType: TypeBuilder.GetEvents(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetEvents(BindingFlags)
- uid: System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetField(String,BindingFlags)
  nameWithType: TypeBuilder.GetField(String,BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetField(String,BindingFlags)
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: false
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetField(Type,FieldInfo)
  nameWithType: TypeBuilder.GetField(Type,FieldInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetField(Type,FieldInfo)
- uid: System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetFields(BindingFlags)
  nameWithType: TypeBuilder.GetFields(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetFields(BindingFlags)
- uid: System.Reflection.FieldInfo[]
  parent: System.Reflection
  isExternal: false
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo[]
  spec.csharp:
  - uid: System.Reflection.FieldInfo
    name: FieldInfo
    nameWithType: FieldInfo
    fullName: FieldInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.GetGenericArguments
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetGenericArguments()
  nameWithType: TypeBuilder.GetGenericArguments()
  fullName: System.Reflection.Emit.TypeBuilder.GetGenericArguments()
- uid: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetGenericTypeDefinition()
  nameWithType: TypeBuilder.GetGenericTypeDefinition()
  fullName: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition()
- uid: System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetInterface(String,Boolean)
  nameWithType: TypeBuilder.GetInterface(String,Boolean)
  fullName: System.Reflection.Emit.TypeBuilder.GetInterface(String,Boolean)
- uid: System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetInterfaceMap(Type)
  nameWithType: TypeBuilder.GetInterfaceMap(Type)
  fullName: System.Reflection.Emit.TypeBuilder.GetInterfaceMap(Type)
- uid: System.Reflection.InterfaceMapping
  parent: System.Reflection
  isExternal: false
  name: InterfaceMapping
  nameWithType: InterfaceMapping
  fullName: System.Reflection.InterfaceMapping
- uid: System.Reflection.Emit.TypeBuilder.GetInterfaces
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetInterfaces()
  nameWithType: TypeBuilder.GetInterfaces()
  fullName: System.Reflection.Emit.TypeBuilder.GetInterfaces()
- uid: System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMember(String,MemberTypes,BindingFlags)
  nameWithType: TypeBuilder.GetMember(String,MemberTypes,BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetMember(String,MemberTypes,BindingFlags)
- uid: System.Reflection.MemberInfo[]
  parent: System.Reflection
  isExternal: false
  name: MemberInfo
  nameWithType: MemberInfo
  fullName: System.Reflection.MemberInfo[]
  spec.csharp:
  - uid: System.Reflection.MemberInfo
    name: MemberInfo
    nameWithType: MemberInfo
    fullName: MemberInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.MemberTypes
  parent: System.Reflection
  isExternal: false
  name: MemberTypes
  nameWithType: MemberTypes
  fullName: System.Reflection.MemberTypes
- uid: System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMembers(BindingFlags)
  nameWithType: TypeBuilder.GetMembers(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetMembers(BindingFlags)
- uid: System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMethod(Type,MethodInfo)
  nameWithType: TypeBuilder.GetMethod(Type,MethodInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetMethod(Type,MethodInfo)
- uid: System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeBuilder.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.Emit.TypeBuilder.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
- uid: System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMethods(BindingFlags)
  nameWithType: TypeBuilder.GetMethods(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetMethods(BindingFlags)
- uid: System.Reflection.MethodInfo[]
  parent: System.Reflection
  isExternal: false
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo[]
  spec.csharp:
  - uid: System.Reflection.MethodInfo
    name: MethodInfo
    nameWithType: MethodInfo
    fullName: MethodInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetNestedType(String,BindingFlags)
  nameWithType: TypeBuilder.GetNestedType(String,BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetNestedType(String,BindingFlags)
- uid: System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetNestedTypes(BindingFlags)
  nameWithType: TypeBuilder.GetNestedTypes(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetNestedTypes(BindingFlags)
- uid: System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetProperties(BindingFlags)
  nameWithType: TypeBuilder.GetProperties(BindingFlags)
  fullName: System.Reflection.Emit.TypeBuilder.GetProperties(BindingFlags)
- uid: System.Reflection.PropertyInfo[]
  parent: System.Reflection
  isExternal: false
  name: PropertyInfo
  nameWithType: PropertyInfo
  fullName: System.Reflection.PropertyInfo[]
  spec.csharp:
  - uid: System.Reflection.PropertyInfo
    name: PropertyInfo
    nameWithType: PropertyInfo
    fullName: PropertyInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  nameWithType: TypeBuilder.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  fullName: System.Reflection.Emit.TypeBuilder.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
- uid: System.Reflection.PropertyInfo
  parent: System.Reflection
  isExternal: false
  name: PropertyInfo
  nameWithType: PropertyInfo
  fullName: System.Reflection.PropertyInfo
- uid: System.Reflection.Emit.TypeBuilder.GUID
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GUID
  nameWithType: TypeBuilder.GUID
  fullName: System.Reflection.Emit.TypeBuilder.GUID
- uid: System.Guid
  parent: System
  isExternal: false
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Reflection.Emit.TypeBuilder.HasElementTypeImpl
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: HasElementTypeImpl()
  nameWithType: TypeBuilder.HasElementTypeImpl()
  fullName: System.Reflection.Emit.TypeBuilder.HasElementTypeImpl()
- uid: System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  nameWithType: TypeBuilder.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  fullName: System.Reflection.Emit.TypeBuilder.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: false
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Reflection.Emit.TypeBuilder.IsArrayImpl
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsArrayImpl()
  nameWithType: TypeBuilder.IsArrayImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsArrayImpl()
- uid: System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsAssignableFrom(Type)
  nameWithType: TypeBuilder.IsAssignableFrom(Type)
  fullName: System.Reflection.Emit.TypeBuilder.IsAssignableFrom(Type)
- uid: System.Reflection.Emit.TypeBuilder.IsByRefImpl
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsByRefImpl()
  nameWithType: TypeBuilder.IsByRefImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsByRefImpl()
- uid: System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsCOMObjectImpl()
  nameWithType: TypeBuilder.IsCOMObjectImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl()
- uid: System.Reflection.Emit.TypeBuilder.IsCreated
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsCreated()
  nameWithType: TypeBuilder.IsCreated()
  fullName: System.Reflection.Emit.TypeBuilder.IsCreated()
- uid: System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsDefined(Type,Boolean)
  nameWithType: TypeBuilder.IsDefined(Type,Boolean)
  fullName: System.Reflection.Emit.TypeBuilder.IsDefined(Type,Boolean)
- uid: System.Reflection.Emit.TypeBuilder.IsGenericParameter
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsGenericParameter
  nameWithType: TypeBuilder.IsGenericParameter
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericParameter
- uid: System.Reflection.Emit.TypeBuilder.IsGenericType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsGenericType
  nameWithType: TypeBuilder.IsGenericType
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericType
- uid: System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsGenericTypeDefinition
  nameWithType: TypeBuilder.IsGenericTypeDefinition
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
- uid: System.Reflection.Emit.TypeBuilder.IsPointerImpl
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsPointerImpl()
  nameWithType: TypeBuilder.IsPointerImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsPointerImpl()
- uid: System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsPrimitiveImpl()
  nameWithType: TypeBuilder.IsPrimitiveImpl()
  fullName: System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl()
- uid: System.Reflection.Emit.TypeBuilder.IsSecurityCritical
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsSecurityCritical
  nameWithType: TypeBuilder.IsSecurityCritical
  fullName: System.Reflection.Emit.TypeBuilder.IsSecurityCritical
- uid: System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsSecuritySafeCritical
  nameWithType: TypeBuilder.IsSecuritySafeCritical
  fullName: System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical
- uid: System.Reflection.Emit.TypeBuilder.IsSecurityTransparent
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsSecurityTransparent
  nameWithType: TypeBuilder.IsSecurityTransparent
  fullName: System.Reflection.Emit.TypeBuilder.IsSecurityTransparent
- uid: System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsSubclassOf(Type)
  nameWithType: TypeBuilder.IsSubclassOf(Type)
  fullName: System.Reflection.Emit.TypeBuilder.IsSubclassOf(Type)
- uid: System.Reflection.Emit.TypeBuilder.MakeArrayType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakeArrayType()
  nameWithType: TypeBuilder.MakeArrayType()
  fullName: System.Reflection.Emit.TypeBuilder.MakeArrayType()
- uid: System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakeArrayType(Int32)
  nameWithType: TypeBuilder.MakeArrayType(Int32)
  fullName: System.Reflection.Emit.TypeBuilder.MakeArrayType(Int32)
- uid: System.Reflection.Emit.TypeBuilder.MakeByRefType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakeByRefType()
  nameWithType: TypeBuilder.MakeByRefType()
  fullName: System.Reflection.Emit.TypeBuilder.MakeByRefType()
- uid: System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakeGenericType(Type[])
  nameWithType: TypeBuilder.MakeGenericType(Type[])
  fullName: System.Reflection.Emit.TypeBuilder.MakeGenericType(Type[])
- uid: System.Reflection.Emit.TypeBuilder.MakePointerType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakePointerType()
  nameWithType: TypeBuilder.MakePointerType()
  fullName: System.Reflection.Emit.TypeBuilder.MakePointerType()
- uid: System.Reflection.Emit.TypeBuilder.Module
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Module
  nameWithType: TypeBuilder.Module
  fullName: System.Reflection.Emit.TypeBuilder.Module
- uid: System.Reflection.Module
  parent: System.Reflection
  isExternal: false
  name: Module
  nameWithType: Module
  fullName: System.Reflection.Module
- uid: System.Reflection.Emit.TypeBuilder.Name
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Name
  nameWithType: TypeBuilder.Name
  fullName: System.Reflection.Emit.TypeBuilder.Name
- uid: System.Reflection.Emit.TypeBuilder.Namespace
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Namespace
  nameWithType: TypeBuilder.Namespace
  fullName: System.Reflection.Emit.TypeBuilder.Namespace
- uid: System.Reflection.Emit.TypeBuilder.PackingSize
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: PackingSize
  nameWithType: TypeBuilder.PackingSize
  fullName: System.Reflection.Emit.TypeBuilder.PackingSize
- uid: System.Reflection.Emit.TypeBuilder.ReflectedType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: ReflectedType
  nameWithType: TypeBuilder.ReflectedType
  fullName: System.Reflection.Emit.TypeBuilder.ReflectedType
- uid: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: SetCustomAttribute(CustomAttributeBuilder)
  nameWithType: TypeBuilder.SetCustomAttribute(CustomAttributeBuilder)
  fullName: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(CustomAttributeBuilder)
- uid: System.Reflection.Emit.CustomAttributeBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: CustomAttributeBuilder
  nameWithType: CustomAttributeBuilder
  fullName: System.Reflection.Emit.CustomAttributeBuilder
- uid: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: SetCustomAttribute(ConstructorInfo,Byte[])
  nameWithType: TypeBuilder.SetCustomAttribute(ConstructorInfo,Byte[])
  fullName: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(ConstructorInfo,Byte[])
- uid: System.Reflection.Emit.TypeBuilder.SetParent(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: SetParent(Type)
  nameWithType: TypeBuilder.SetParent(Type)
  fullName: System.Reflection.Emit.TypeBuilder.SetParent(Type)
- uid: System.Reflection.Emit.TypeBuilder.Size
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Size
  nameWithType: TypeBuilder.Size
  fullName: System.Reflection.Emit.TypeBuilder.Size
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Reflection.Emit.TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Reflection.Emit.TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32)
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32)
  fullName: System.Reflection.Emit.TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(UInt32)
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Reflection.Emit.TypeBuilder.System.Runtime.InteropServices._TypeBuilder.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: false
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Reflection.Emit.TypeBuilder.ToString
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: ToString()
  nameWithType: TypeBuilder.ToString()
  fullName: System.Reflection.Emit.TypeBuilder.ToString()
- uid: System.Reflection.Emit.TypeBuilder.TypeHandle
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: TypeHandle
  nameWithType: TypeBuilder.TypeHandle
  fullName: System.Reflection.Emit.TypeBuilder.TypeHandle
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: false
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.Emit.TypeBuilder.TypeToken
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: TypeToken
  nameWithType: TypeBuilder.TypeToken
  fullName: System.Reflection.Emit.TypeBuilder.TypeToken
- uid: System.Reflection.Emit.TypeToken
  parent: System.Reflection.Emit
  isExternal: false
  name: TypeToken
  nameWithType: TypeToken
  fullName: System.Reflection.Emit.TypeToken
- uid: System.Reflection.Emit.TypeBuilder.UnderlyingSystemType
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: UnderlyingSystemType
  nameWithType: TypeBuilder.UnderlyingSystemType
  fullName: System.Reflection.Emit.TypeBuilder.UnderlyingSystemType
- uid: System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: UnspecifiedTypeSize
  nameWithType: TypeBuilder.UnspecifiedTypeSize
  fullName: System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
- uid: System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: AddDeclarativeSecurity
  nameWithType: TypeBuilder.AddDeclarativeSecurity
- uid: System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: AddInterfaceImplementation
  nameWithType: TypeBuilder.AddInterfaceImplementation
- uid: System.Reflection.Emit.TypeBuilder.Assembly*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Assembly
  nameWithType: TypeBuilder.Assembly
- uid: System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: AssemblyQualifiedName
  nameWithType: TypeBuilder.AssemblyQualifiedName
- uid: System.Reflection.Emit.TypeBuilder.BaseType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: BaseType
  nameWithType: TypeBuilder.BaseType
- uid: System.Reflection.Emit.TypeBuilder.CreateType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: CreateType
  nameWithType: TypeBuilder.CreateType
- uid: System.Reflection.Emit.TypeBuilder.DeclaringMethod*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DeclaringMethod
  nameWithType: TypeBuilder.DeclaringMethod
- uid: System.Reflection.Emit.TypeBuilder.DeclaringType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DeclaringType
  nameWithType: TypeBuilder.DeclaringType
- uid: System.Reflection.Emit.TypeBuilder.DefineConstructor*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineConstructor
  nameWithType: TypeBuilder.DefineConstructor
- uid: System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineDefaultConstructor
  nameWithType: TypeBuilder.DefineDefaultConstructor
- uid: System.Reflection.Emit.TypeBuilder.DefineEvent*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineEvent
  nameWithType: TypeBuilder.DefineEvent
- uid: System.Reflection.Emit.TypeBuilder.DefineField*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineField
  nameWithType: TypeBuilder.DefineField
- uid: System.Reflection.Emit.TypeBuilder.DefineGenericParameters*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineGenericParameters
  nameWithType: TypeBuilder.DefineGenericParameters
- uid: System.Reflection.Emit.TypeBuilder.DefineInitializedData*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineInitializedData
  nameWithType: TypeBuilder.DefineInitializedData
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineMethod
  nameWithType: TypeBuilder.DefineMethod
- uid: System.Reflection.Emit.TypeBuilder.DefineMethodOverride*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineMethodOverride
  nameWithType: TypeBuilder.DefineMethodOverride
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineNestedType
  nameWithType: TypeBuilder.DefineNestedType
- uid: System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefinePInvokeMethod
  nameWithType: TypeBuilder.DefinePInvokeMethod
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineProperty
  nameWithType: TypeBuilder.DefineProperty
- uid: System.Reflection.Emit.TypeBuilder.DefineTypeInitializer*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineTypeInitializer
  nameWithType: TypeBuilder.DefineTypeInitializer
- uid: System.Reflection.Emit.TypeBuilder.DefineUninitializedData*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: DefineUninitializedData
  nameWithType: TypeBuilder.DefineUninitializedData
- uid: System.Reflection.Emit.TypeBuilder.FullName*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: FullName
  nameWithType: TypeBuilder.FullName
- uid: System.Reflection.Emit.TypeBuilder.GenericParameterAttributes*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GenericParameterAttributes
  nameWithType: TypeBuilder.GenericParameterAttributes
- uid: System.Reflection.Emit.TypeBuilder.GenericParameterPosition*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GenericParameterPosition
  nameWithType: TypeBuilder.GenericParameterPosition
- uid: System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetAttributeFlagsImpl
  nameWithType: TypeBuilder.GetAttributeFlagsImpl
- uid: System.Reflection.Emit.TypeBuilder.GetConstructor*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetConstructor
  nameWithType: TypeBuilder.GetConstructor
- uid: System.Reflection.Emit.TypeBuilder.GetConstructorImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetConstructorImpl
  nameWithType: TypeBuilder.GetConstructorImpl
- uid: System.Reflection.Emit.TypeBuilder.GetConstructors*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetConstructors
  nameWithType: TypeBuilder.GetConstructors
- uid: System.Reflection.Emit.TypeBuilder.GetCustomAttributes*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetCustomAttributes
  nameWithType: TypeBuilder.GetCustomAttributes
- uid: System.Reflection.Emit.TypeBuilder.GetElementType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetElementType
  nameWithType: TypeBuilder.GetElementType
- uid: System.Reflection.Emit.TypeBuilder.GetEvent*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetEvent
  nameWithType: TypeBuilder.GetEvent
- uid: System.Reflection.Emit.TypeBuilder.GetEvents*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetEvents
  nameWithType: TypeBuilder.GetEvents
- uid: System.Reflection.Emit.TypeBuilder.GetField*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetField
  nameWithType: TypeBuilder.GetField
- uid: System.Reflection.Emit.TypeBuilder.GetFields*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetFields
  nameWithType: TypeBuilder.GetFields
- uid: System.Reflection.Emit.TypeBuilder.GetGenericArguments*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetGenericArguments
  nameWithType: TypeBuilder.GetGenericArguments
- uid: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetGenericTypeDefinition
  nameWithType: TypeBuilder.GetGenericTypeDefinition
- uid: System.Reflection.Emit.TypeBuilder.GetInterface*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetInterface
  nameWithType: TypeBuilder.GetInterface
- uid: System.Reflection.Emit.TypeBuilder.GetInterfaceMap*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetInterfaceMap
  nameWithType: TypeBuilder.GetInterfaceMap
- uid: System.Reflection.Emit.TypeBuilder.GetInterfaces*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetInterfaces
  nameWithType: TypeBuilder.GetInterfaces
- uid: System.Reflection.Emit.TypeBuilder.GetMember*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMember
  nameWithType: TypeBuilder.GetMember
- uid: System.Reflection.Emit.TypeBuilder.GetMembers*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMembers
  nameWithType: TypeBuilder.GetMembers
- uid: System.Reflection.Emit.TypeBuilder.GetMethod*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMethod
  nameWithType: TypeBuilder.GetMethod
- uid: System.Reflection.Emit.TypeBuilder.GetMethodImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMethodImpl
  nameWithType: TypeBuilder.GetMethodImpl
- uid: System.Reflection.Emit.TypeBuilder.GetMethods*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetMethods
  nameWithType: TypeBuilder.GetMethods
- uid: System.Reflection.Emit.TypeBuilder.GetNestedType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetNestedType
  nameWithType: TypeBuilder.GetNestedType
- uid: System.Reflection.Emit.TypeBuilder.GetNestedTypes*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetNestedTypes
  nameWithType: TypeBuilder.GetNestedTypes
- uid: System.Reflection.Emit.TypeBuilder.GetProperties*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetProperties
  nameWithType: TypeBuilder.GetProperties
- uid: System.Reflection.Emit.TypeBuilder.GetPropertyImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GetPropertyImpl
  nameWithType: TypeBuilder.GetPropertyImpl
- uid: System.Reflection.Emit.TypeBuilder.GUID*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: GUID
  nameWithType: TypeBuilder.GUID
- uid: System.Reflection.Emit.TypeBuilder.HasElementTypeImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: HasElementTypeImpl
  nameWithType: TypeBuilder.HasElementTypeImpl
- uid: System.Reflection.Emit.TypeBuilder.InvokeMember*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: InvokeMember
  nameWithType: TypeBuilder.InvokeMember
- uid: System.Reflection.Emit.TypeBuilder.IsArrayImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsArrayImpl
  nameWithType: TypeBuilder.IsArrayImpl
- uid: System.Reflection.Emit.TypeBuilder.IsAssignableFrom*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsAssignableFrom
  nameWithType: TypeBuilder.IsAssignableFrom
- uid: System.Reflection.Emit.TypeBuilder.IsByRefImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsByRefImpl
  nameWithType: TypeBuilder.IsByRefImpl
- uid: System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsCOMObjectImpl
  nameWithType: TypeBuilder.IsCOMObjectImpl
- uid: System.Reflection.Emit.TypeBuilder.IsCreated*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsCreated
  nameWithType: TypeBuilder.IsCreated
- uid: System.Reflection.Emit.TypeBuilder.IsDefined*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsDefined
  nameWithType: TypeBuilder.IsDefined
- uid: System.Reflection.Emit.TypeBuilder.IsGenericParameter*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsGenericParameter
  nameWithType: TypeBuilder.IsGenericParameter
- uid: System.Reflection.Emit.TypeBuilder.IsGenericType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsGenericType
  nameWithType: TypeBuilder.IsGenericType
- uid: System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsGenericTypeDefinition
  nameWithType: TypeBuilder.IsGenericTypeDefinition
- uid: System.Reflection.Emit.TypeBuilder.IsPointerImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsPointerImpl
  nameWithType: TypeBuilder.IsPointerImpl
- uid: System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsPrimitiveImpl
  nameWithType: TypeBuilder.IsPrimitiveImpl
- uid: System.Reflection.Emit.TypeBuilder.IsSecurityCritical*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsSecurityCritical
  nameWithType: TypeBuilder.IsSecurityCritical
- uid: System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsSecuritySafeCritical
  nameWithType: TypeBuilder.IsSecuritySafeCritical
- uid: System.Reflection.Emit.TypeBuilder.IsSecurityTransparent*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsSecurityTransparent
  nameWithType: TypeBuilder.IsSecurityTransparent
- uid: System.Reflection.Emit.TypeBuilder.IsSubclassOf*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: IsSubclassOf
  nameWithType: TypeBuilder.IsSubclassOf
- uid: System.Reflection.Emit.TypeBuilder.MakeArrayType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakeArrayType
  nameWithType: TypeBuilder.MakeArrayType
- uid: System.Reflection.Emit.TypeBuilder.MakeByRefType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakeByRefType
  nameWithType: TypeBuilder.MakeByRefType
- uid: System.Reflection.Emit.TypeBuilder.MakeGenericType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakeGenericType
  nameWithType: TypeBuilder.MakeGenericType
- uid: System.Reflection.Emit.TypeBuilder.MakePointerType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: MakePointerType
  nameWithType: TypeBuilder.MakePointerType
- uid: System.Reflection.Emit.TypeBuilder.Module*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Module
  nameWithType: TypeBuilder.Module
- uid: System.Reflection.Emit.TypeBuilder.Name*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Name
  nameWithType: TypeBuilder.Name
- uid: System.Reflection.Emit.TypeBuilder.Namespace*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Namespace
  nameWithType: TypeBuilder.Namespace
- uid: System.Reflection.Emit.TypeBuilder.PackingSize*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: PackingSize
  nameWithType: TypeBuilder.PackingSize
- uid: System.Reflection.Emit.TypeBuilder.ReflectedType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: ReflectedType
  nameWithType: TypeBuilder.ReflectedType
- uid: System.Reflection.Emit.TypeBuilder.SetCustomAttribute*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: SetCustomAttribute
  nameWithType: TypeBuilder.SetCustomAttribute
- uid: System.Reflection.Emit.TypeBuilder.SetParent*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: SetParent
  nameWithType: TypeBuilder.SetParent
- uid: System.Reflection.Emit.TypeBuilder.Size*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: Size
  nameWithType: TypeBuilder.Size
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: System.Runtime.InteropServices._TypeBuilder.GetTypeInfo
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfo
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount
- uid: System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: System.Runtime.InteropServices._TypeBuilder.Invoke
  nameWithType: TypeBuilder.System.Runtime.InteropServices._TypeBuilder.Invoke
- uid: System.Reflection.Emit.TypeBuilder.ToString*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: ToString
  nameWithType: TypeBuilder.ToString
- uid: System.Reflection.Emit.TypeBuilder.TypeHandle*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: TypeHandle
  nameWithType: TypeBuilder.TypeHandle
- uid: System.Reflection.Emit.TypeBuilder.TypeToken*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: TypeToken
  nameWithType: TypeBuilder.TypeToken
- uid: System.Reflection.Emit.TypeBuilder.UnderlyingSystemType*
  parent: System.Reflection.Emit.TypeBuilder
  isExternal: false
  name: UnderlyingSystemType
  nameWithType: TypeBuilder.UnderlyingSystemType
