### YamlMime:ManagedReference
items:
- uid: System.Runtime.CompilerServices.RuntimeHelpers
  id: RuntimeHelpers
  children:
  - System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack
  - System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)
  - System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)
  - System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)
  - System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)
  - System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)
  - System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData
  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions
  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP
  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)
  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)
  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)
  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])
  - System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack
  - System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)
  - System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)
  langs:
  - csharp
  name: RuntimeHelpers
  nameWithType: RuntimeHelpers
  fullName: System.Runtime.CompilerServices.RuntimeHelpers
  type: Class
  summary: Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.
  remarks: ''
  example:
  - "The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method. To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic. Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.  You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.  \n  \n [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/add/codesnippet/visualbasic/t-system.runtime.compile_18_1.vb)]\n [!code-cs[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/add/codesnippet/csharp/t-system.runtime.compile_18_1.cs)]"
  syntax:
    content: public static class RuntimeHelpers
  inheritance:
  - System.Object
  implements: []
  inheritedMembers:
  - System.Object.Equals(System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack
  id: EnsureSufficientExecutionStack
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: EnsureSufficientExecutionStack()
  nameWithType: RuntimeHelpers.EnsureSufficientExecutionStack()
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Ensures that the remaining stack space is large enough to execute the average .NET Framework function.
  remarks: "EnsureSufficientExecutionStack provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken. The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.  \n  \n This method is useful in situations where stack overflow might occur as a result of unbounded recursion. It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.  \n  \n If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.  \n  \n> [!NOTE]\n>  This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=fullName> method."
  syntax:
    content: public static void EnsureSufficientExecutionStack ();
    parameters: []
  overload: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack*
  exceptions:
  - type: System.InsufficientExecutionStackException
    commentId: T:System.InsufficientExecutionStackException
    description: The available stack space is insufficient to execute the average .NET Framework function.
  version:
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)
  id: Equals(System.Object,System.Object)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: Equals(Object,Object)
  nameWithType: RuntimeHelpers.Equals(Object,Object)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.Equals(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Determines whether the specified <xref href="System.Object"></xref> instances are considered equal.
  remarks: This method is used by compilers.
  example:
  - "The following example demonstrates how to compare two objects by using the Equals method.  \n  \n [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/add/codesnippet/visualbasic/e11de728-5102-413c-a8b5-_1.vb)]\n [!code-cs[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/add/codesnippet/csharp/e11de728-5102-413c-a8b5-_1.cs)]"
  syntax:
    content: public static bool Equals (object o1, object o2);
    parameters:
    - id: o1
      type: System.Object
      description: The first object to compare.
    - id: o2
      type: System.Object
      description: The second object to compare.
    return:
      type: System.Boolean
      description: <xref uid="langword_csharp_true" name="true" href=""></xref> if the <code>o1</code> parameter is the same instance as the <code>o2</code> parameter, or if both are <xref uid="langword_csharp_null" name="null" href=""></xref>, or if `o1.Equals(o2)` returns <xref uid="langword_csharp_true" name="true" href=""></xref>; otherwise, <xref uid="langword_csharp_false" name="false" href=""></xref>.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.Equals*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)
  id: ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode,RuntimeHelpers+CleanupCode,Object)
  nameWithType: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode,RuntimeHelpers+CleanupCode,Object)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode,RuntimeHelpers+CleanupCode,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  syntax:
    content: public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);
    parameters:
    - id: code
      type: System.Runtime.CompilerServices.RuntimeHelpers.TryCode
      description: To be added.
    - id: backoutCode
      type: System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode
      description: To be added.
    - id: userData
      type: System.Object
      description: To be added.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)
  id: GetHashCode(System.Object)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: GetHashCode(Object)
  nameWithType: RuntimeHelpers.GetHashCode(Object)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.
  remarks: "The GetHashCode method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method. Therefore, using GetHashCode might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method.  \n  \n> [!WARNING]\n>  Although the GetHashCode method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference. To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> method. Nor should you use GetHashCode to test whether two strings represent equal object references, because the string is interned. To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=fullName> method.  \n  \n The <xref:System.Object.GetHashCode%2A?displayProperty=fullName> and GetHashCode methods differ as follows:  \n  \n-   <xref:System.Object.GetHashCode%2A?displayProperty=fullName> returns a hash code that is based on the object's definition of equality. For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.  \n  \n-   GetHashCode returns a hash code that indicates object identity. That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.  \n  \n> [!IMPORTANT]\n>  Note that GetHashCode always returns identical hash codes for equal object references. However, the reverse is not true: equal hash codes do not indicate equal object references. A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.  \n  \n This method is used by compilers.  \n  \n<a name=\"interning\"></a>   \n## String Interning  \n The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool. If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory. Calling GetHashCode on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.  \n  \n The CLR adds only literals to the pool. Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal. Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using GetHashCode on these two string objects will not produce the same hash code.  \n  \n If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=fullName> method.  \n  \n You can also use the <xref:System.String.IsInterned%2A?displayProperty=fullName> method to check whether a string has an interned reference."
  example:
  - "The following example demonstrates the difference between the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> and GetHashCode methods. The output from the example illustrates the following:  \n  \n-   Both sets of hash codes for the first set of strings passed to the `ShowHashCodes` method are different, because the strings are completely different.  \n  \n-   <xref:System.Object.GetHashCode%2A?displayProperty=fullName> generates the same hash code for the second set of strings passed to the `ShowHashCodes` method, because the strings are equal. However, the GetHashCode method does not. The first string is defined by using a string literal and so is interned. Although the value of the second string is the same, it is not interned, because it is returned by a call to the <xref:System.String.Format%2A?displayProperty=fullName> method.  \n  \n-   In the case of the third string, the hash codes produced by <xref:System.Object.GetHashCode%2A?displayProperty=fullName> for both strings are identical, as are the hash codes produced by GetHashCode. This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.  \n  \n [!code-cs[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/add/codesnippet/csharp/m-system.runtime.compile_5_1.cs)]\n [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/add/codesnippet/visualbasic/m-system.runtime.compile_5_1.vb)]"
  syntax:
    content: public static int GetHashCode (object o);
    parameters:
    - id: o
      type: System.Object
      description: An object to retrieve the hash code for.
    return:
      type: System.Int32
      description: A hash code for the object identified by the <code>o</code> parameter.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)
  id: GetObjectValue(System.Object)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: GetObjectValue(Object)
  nameWithType: RuntimeHelpers.GetObjectValue(Object)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Boxes a value type.
  remarks: "Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.  \n  \n This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.  \n  \n The return value depends on whether the value class is mutable or immutable:  \n  \n-   If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.  \n  \n-   If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.  \n  \n Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types. That is, boxed value types get cloned when you pass them around, and they are always passed by value. The compiler can call GetObjectValue to assign a value type to an object or to pass a value type as a parameter of a type object.  \n  \n This method is used by compilers."
  example:
  - "The following example demonstrates how to box a value class by using the GetObjectValue method.  \n  \n [!code-cs[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/add/codesnippet/csharp/m-system.runtime.compile_6_1.cs)]\n [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/add/codesnippet/visualbasic/m-system.runtime.compile_6_1.vb)]"
  syntax:
    content: public static object GetObjectValue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: The value type to be boxed.
    return:
      type: System.Object
      description: A boxed copy of <code>obj</code> if it is a value class; otherwise, <code>obj</code> itself.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)
  id: InitializeArray(System.Array,System.RuntimeFieldHandle)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: InitializeArray(Array,RuntimeFieldHandle)
  nameWithType: RuntimeHelpers.InitializeArray(Array,RuntimeFieldHandle)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(Array,RuntimeFieldHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Provides a fast way to initialize an array from data that is stored in a module.
  remarks: This method is used by compilers.
  syntax:
    content: public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);
    parameters:
    - id: array
      type: System.Array
      description: The array to be initialized.
    - id: fldHandle
      type: System.RuntimeFieldHandle
      description: A field handle that specifies the location of the data used to initialize the array.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData
  id: OffsetToStringData
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: OffsetToStringData
  nameWithType: RuntimeHelpers.OffsetToStringData
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Gets the offset, in bytes, to the data in the given string.
  remarks: Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string. Compilers should pin the string against movement by the garbage collector before use. Note that common language runtime strings are immutable; that is, their contents can be read but not changed.
  syntax:
    content: public static int OffsetToStringData { get; }
    return:
      type: System.Int32
      description: The byte offset, from the start of the <xref href="System.String"></xref> object to the first character in the string.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions
  id: PrepareConstrainedRegions
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: PrepareConstrainedRegions()
  nameWithType: RuntimeHelpers.PrepareConstrainedRegions()
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Designates a body of code as a constrained execution region (CER).
  remarks: "Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs). Code that is marked as a constrained region must only call other code with strong reliability contracts. It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.  \n  \n Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the PrepareConstrainedRegions method and the `try` block. For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.  \n  \n CERs that are marked using the PrepareConstrainedRegions method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block. For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.  \n  \n The PrepareConstrainedRegions method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method."
  example:
  - "The following example shows how to reliably set handles by using the PrepareConstrainedRegions method. To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic. Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked. You can use the PrepareConstrainedRegions method to make sure that the handle is not leaked.  \n  \n [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/add/codesnippet/visualbasic/m-system.runtime.compile_1_1.vb)]\n [!code-cs[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/add/codesnippet/csharp/m-system.runtime.compile_1_1.cs)]"
  syntax:
    content: public static void PrepareConstrainedRegions ();
    parameters: []
  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP
  id: PrepareConstrainedRegionsNoOP
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: PrepareConstrainedRegionsNoOP()
  nameWithType: RuntimeHelpers.PrepareConstrainedRegionsNoOP()
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Designates a body of code as a constrained execution region (CER) without performing any probing.
  remarks: Compilers should not call this method directly. Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method.
  syntax:
    content: public static void PrepareConstrainedRegionsNoOP ();
    parameters: []
  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)
  id: PrepareContractedDelegate(System.Delegate)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: PrepareContractedDelegate(Delegate)
  nameWithType: RuntimeHelpers.PrepareContractedDelegate(Delegate)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(Delegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Provides a way for applications to dynamically prepare <xref href="System.AppDomain"></xref> event delegates.
  remarks: "<xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup. You can use the following methods to prepare them:  \n  \n-   Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.  \n  \n-   Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.  \n  \n-   Call the PrepareContractedDelegate method to dynamically prepare the delegate.  \n  \n For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine."
  syntax:
    content: public static void PrepareContractedDelegate (Delegate d);
    parameters:
    - id: d
      type: System.Delegate
      description: The event delegate to prepare.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate*
  exceptions: []
  version:
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)
  id: PrepareDelegate(System.Delegate)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: PrepareDelegate(Delegate)
  nameWithType: RuntimeHelpers.PrepareDelegate(Delegate)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(Delegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).
  remarks: Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).
  syntax:
    content: public static void PrepareDelegate (Delegate d);
    parameters:
    - id: d
      type: System.Delegate
      description: The delegate type to prepare.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)
  id: PrepareMethod(System.RuntimeMethodHandle)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: PrepareMethod(RuntimeMethodHandle)
  nameWithType: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(RuntimeMethodHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Prepares a method for inclusion in a constrained execution region (CER).
  remarks: Compilers use the PrepareMethod method to handle virtual calls that are made inside a constrained execution region (CER). At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call. Therefore, the runtime does not initially prepare that segment of the call graph. If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call PrepareMethod to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.
  syntax:
    content: public static void PrepareMethod (RuntimeMethodHandle method);
    parameters:
    - id: method
      type: System.RuntimeMethodHandle
      description: A handle to the method to prepare.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])
  id: PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: PrepareMethod(RuntimeMethodHandle,RuntimeTypeHandle[])
  nameWithType: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle,RuntimeTypeHandle[])
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(RuntimeMethodHandle,RuntimeTypeHandle[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.
  remarks: "You can provide generics support for compilers by using the PrepareMethod method. The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.  \n  \n You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any). The runtime prepares that instantiation of the method. (This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types. To instantiate reference types such as <xref:System.String>, you must use an explicit PrepareMethod method on the CER root method first."
  syntax:
    content: public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    parameters:
    - id: method
      type: System.RuntimeMethodHandle
      description: A handle to the method to prepare.
    - id: instantiation
      type: System.RuntimeTypeHandle[]
      description: The instantiation to pass to the method.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack
  id: ProbeForSufficientStack
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: ProbeForSufficientStack()
  nameWithType: RuntimeHelpers.ProbeForSufficientStack()
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space). We recommend that you use a constrained execution region (CER) instead of this method.
  remarks: "This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server. This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.  \n  \n This method is also used by compilers.  \n  \n Instead of using the ProbeForSufficientStack method, you should use a standard CER. That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method immediately before your `try`/`finally` or `try`/`catch` block. If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=fullName> method."
  syntax:
    content: public static void ProbeForSufficientStack ();
    parameters: []
  overload: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)
  id: RunClassConstructor(System.RuntimeTypeHandle)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: RunClassConstructor(RuntimeTypeHandle)
  nameWithType: RuntimeHelpers.RunClassConstructor(RuntimeTypeHandle)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(RuntimeTypeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Runs a specified class constructor method.
  remarks: This method is used by compilers.
  syntax:
    content: public static void RunClassConstructor (RuntimeTypeHandle type);
    parameters:
    - id: type
      type: System.RuntimeTypeHandle
      description: A type handle that specifies the class constructor method to run.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor*
  exceptions:
  - type: System.TypeInitializationException
    commentId: T:System.TypeInitializationException
    description: The class initializer throws an exception.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)
  id: RunModuleConstructor(System.ModuleHandle)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  langs:
  - csharp
  name: RunModuleConstructor(ModuleHandle)
  nameWithType: RuntimeHelpers.RunModuleConstructor(ModuleHandle)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(ModuleHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.CompilerServices
  summary: Runs a specified module constructor method.
  remarks: This method is used by compilers.
  syntax:
    content: public static void RunModuleConstructor (ModuleHandle module);
    parameters:
    - id: module
      type: System.ModuleHandle
      description: A handle that specifies the module constructor method to run.
  overload: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor*
  exceptions:
  - type: System.TypeInitializationException
    commentId: T:System.TypeInitializationException
    description: The module constructor throws an exception.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InsufficientExecutionStackException
  parent: System
  isExternal: false
  name: InsufficientExecutionStackException
  nameWithType: InsufficientExecutionStackException
  fullName: System.InsufficientExecutionStackException
- uid: System.TypeInitializationException
  parent: System
  isExternal: false
  name: TypeInitializationException
  nameWithType: TypeInitializationException
  fullName: System.TypeInitializationException
- uid: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: EnsureSufficientExecutionStack()
  nameWithType: RuntimeHelpers.EnsureSufficientExecutionStack()
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack()
- uid: System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: Equals(Object,Object)
  nameWithType: RuntimeHelpers.Equals(Object,Object)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.Equals(Object,Object)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode,RuntimeHelpers+CleanupCode,Object)
  nameWithType: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode,RuntimeHelpers+CleanupCode,Object)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode,RuntimeHelpers+CleanupCode,Object)
- uid: System.Runtime.CompilerServices.RuntimeHelpers.TryCode
  parent: System.Runtime.CompilerServices
  isExternal: false
  name: RuntimeHelpers+TryCode
  nameWithType: RuntimeHelpers+TryCode
  fullName: System.Runtime.CompilerServices.RuntimeHelpers+TryCode
- uid: System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode
  parent: System.Runtime.CompilerServices
  isExternal: false
  name: RuntimeHelpers+CleanupCode
  nameWithType: RuntimeHelpers+CleanupCode
  fullName: System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode
- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: GetHashCode(Object)
  nameWithType: RuntimeHelpers.GetHashCode(Object)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(Object)
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: GetObjectValue(Object)
  nameWithType: RuntimeHelpers.GetObjectValue(Object)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(Object)
- uid: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: InitializeArray(Array,RuntimeFieldHandle)
  nameWithType: RuntimeHelpers.InitializeArray(Array,RuntimeFieldHandle)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(Array,RuntimeFieldHandle)
- uid: System.Array
  parent: System
  isExternal: false
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.RuntimeFieldHandle
  parent: System
  isExternal: false
  name: RuntimeFieldHandle
  nameWithType: RuntimeFieldHandle
  fullName: System.RuntimeFieldHandle
- uid: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: OffsetToStringData
  nameWithType: RuntimeHelpers.OffsetToStringData
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareConstrainedRegions()
  nameWithType: RuntimeHelpers.PrepareConstrainedRegions()
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions()
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareConstrainedRegionsNoOP()
  nameWithType: RuntimeHelpers.PrepareConstrainedRegionsNoOP()
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP()
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareContractedDelegate(Delegate)
  nameWithType: RuntimeHelpers.PrepareContractedDelegate(Delegate)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(Delegate)
- uid: System.Delegate
  parent: System
  isExternal: false
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareDelegate(Delegate)
  nameWithType: RuntimeHelpers.PrepareDelegate(Delegate)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(Delegate)
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareMethod(RuntimeMethodHandle)
  nameWithType: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(RuntimeMethodHandle)
- uid: System.RuntimeMethodHandle
  parent: System
  isExternal: false
  name: RuntimeMethodHandle
  nameWithType: RuntimeMethodHandle
  fullName: System.RuntimeMethodHandle
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareMethod(RuntimeMethodHandle,RuntimeTypeHandle[])
  nameWithType: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle,RuntimeTypeHandle[])
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(RuntimeMethodHandle,RuntimeTypeHandle[])
- uid: System.RuntimeTypeHandle[]
  parent: System
  isExternal: false
  name: RuntimeTypeHandle[]
  nameWithType: RuntimeTypeHandle[]
  fullName: System.RuntimeTypeHandle[]
  spec.csharp:
  - uid: System.RuntimeTypeHandle
    name: RuntimeTypeHandle
    nameWithType: RuntimeTypeHandle
    fullName: RuntimeTypeHandle[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: ProbeForSufficientStack()
  nameWithType: RuntimeHelpers.ProbeForSufficientStack()
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack()
- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: RunClassConstructor(RuntimeTypeHandle)
  nameWithType: RuntimeHelpers.RunClassConstructor(RuntimeTypeHandle)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(RuntimeTypeHandle)
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: false
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: RunModuleConstructor(ModuleHandle)
  nameWithType: RuntimeHelpers.RunModuleConstructor(ModuleHandle)
  fullName: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(ModuleHandle)
- uid: System.ModuleHandle
  parent: System
  isExternal: false
  name: ModuleHandle
  nameWithType: ModuleHandle
  fullName: System.ModuleHandle
- uid: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: EnsureSufficientExecutionStack
  nameWithType: RuntimeHelpers.EnsureSufficientExecutionStack
- uid: System.Runtime.CompilerServices.RuntimeHelpers.Equals*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: Equals
  nameWithType: RuntimeHelpers.Equals
- uid: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: ExecuteCodeWithGuaranteedCleanup
  nameWithType: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup
- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: GetHashCode
  nameWithType: RuntimeHelpers.GetHashCode
- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: GetObjectValue
  nameWithType: RuntimeHelpers.GetObjectValue
- uid: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: InitializeArray
  nameWithType: RuntimeHelpers.InitializeArray
- uid: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: OffsetToStringData
  nameWithType: RuntimeHelpers.OffsetToStringData
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareConstrainedRegions
  nameWithType: RuntimeHelpers.PrepareConstrainedRegions
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareConstrainedRegionsNoOP
  nameWithType: RuntimeHelpers.PrepareConstrainedRegionsNoOP
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareContractedDelegate
  nameWithType: RuntimeHelpers.PrepareContractedDelegate
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareDelegate
  nameWithType: RuntimeHelpers.PrepareDelegate
- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: PrepareMethod
  nameWithType: RuntimeHelpers.PrepareMethod
- uid: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: ProbeForSufficientStack
  nameWithType: RuntimeHelpers.ProbeForSufficientStack
- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: RunClassConstructor
  nameWithType: RuntimeHelpers.RunClassConstructor
- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor*
  parent: System.Runtime.CompilerServices.RuntimeHelpers
  isExternal: false
  name: RunModuleConstructor
  nameWithType: RuntimeHelpers.RunModuleConstructor
