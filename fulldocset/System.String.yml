### YamlMime:ManagedReference
items:
- uid: System.String
  id: String
  children:
  - System.String.#ctor(System.Char*)
  - System.String.#ctor(System.Char[])
  - System.String.#ctor(System.SByte*)
  - System.String.#ctor(System.Char,System.Int32)
  - System.String.#ctor(System.Char*,System.Int32,System.Int32)
  - System.String.#ctor(System.Char[],System.Int32,System.Int32)
  - System.String.#ctor(System.SByte*,System.Int32,System.Int32)
  - System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)
  - System.String.Chars(System.Int32)
  - System.String.Clone
  - System.String.Compare(System.String,System.String)
  - System.String.Compare(System.String,System.String,System.Boolean)
  - System.String.Compare(System.String,System.String,System.StringComparison)
  - System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)
  - System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)
  - System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)
  - System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)
  - System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)
  - System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)
  - System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)
  - System.String.CompareOrdinal(System.String,System.String)
  - System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)
  - System.String.CompareTo(System.Object)
  - System.String.CompareTo(System.String)
  - System.String.Concat(System.Collections.Generic.IEnumerable{System.String})
  - System.String.Concat(System.Object)
  - System.String.Concat(System.Object[])
  - System.String.Concat(System.String[])
  - System.String.Concat(System.Object,System.Object)
  - System.String.Concat(System.String,System.String)
  - System.String.Concat(System.Object,System.Object,System.Object)
  - System.String.Concat(System.String,System.String,System.String)
  - System.String.Concat(System.Object,System.Object,System.Object,System.Object)
  - System.String.Concat(System.String,System.String,System.String,System.String)
  - System.String.Concat``1(System.Collections.Generic.IEnumerable`1)
  - System.String.Contains(System.String)
  - System.String.Copy(System.String)
  - System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)
  - System.String.Empty
  - System.String.EndsWith(System.String)
  - System.String.EndsWith(System.String,System.StringComparison)
  - System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)
  - System.String.Equals(System.Object)
  - System.String.Equals(System.String)
  - System.String.Equals(System.String,System.String)
  - System.String.Equals(System.String,System.StringComparison)
  - System.String.Equals(System.String,System.String,System.StringComparison)
  - System.String.Format(System.String,System.Object)
  - System.String.Format(System.String,System.Object[])
  - System.String.Format(System.IFormatProvider,System.String,System.Object[])
  - System.String.Format(System.String,System.Object,System.Object)
  - System.String.Format(System.String,System.Object,System.Object,System.Object)
  - System.String.GetEnumerator
  - System.String.GetHashCode
  - System.String.GetTypeCode
  - System.String.IndexOf(System.Char)
  - System.String.IndexOf(System.String)
  - System.String.IndexOf(System.Char,System.Int32)
  - System.String.IndexOf(System.String,System.Int32)
  - System.String.IndexOf(System.String,System.StringComparison)
  - System.String.IndexOf(System.Char,System.Int32,System.Int32)
  - System.String.IndexOf(System.String,System.Int32,System.Int32)
  - System.String.IndexOf(System.String,System.Int32,System.StringComparison)
  - System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)
  - System.String.IndexOfAny(System.Char[])
  - System.String.IndexOfAny(System.Char[],System.Int32)
  - System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)
  - System.String.Insert(System.Int32,System.String)
  - System.String.Intern(System.String)
  - System.String.IsInterned(System.String)
  - System.String.IsNormalized
  - System.String.IsNormalized(System.Text.NormalizationForm)
  - System.String.IsNullOrEmpty(System.String)
  - System.String.IsNullOrWhiteSpace(System.String)
  - System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})
  - System.String.Join(System.String,System.Object[])
  - System.String.Join(System.String,System.String[])
  - System.String.Join(System.String,System.String[],System.Int32,System.Int32)
  - System.String.Join``1(System.String,System.Collections.Generic.IEnumerable`1)
  - System.String.LastIndexOf(System.Char)
  - System.String.LastIndexOf(System.String)
  - System.String.LastIndexOf(System.Char,System.Int32)
  - System.String.LastIndexOf(System.String,System.Int32)
  - System.String.LastIndexOf(System.String,System.StringComparison)
  - System.String.LastIndexOf(System.Char,System.Int32,System.Int32)
  - System.String.LastIndexOf(System.String,System.Int32,System.Int32)
  - System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)
  - System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)
  - System.String.LastIndexOfAny(System.Char[])
  - System.String.LastIndexOfAny(System.Char[],System.Int32)
  - System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)
  - System.String.Length
  - System.String.Normalize
  - System.String.Normalize(System.Text.NormalizationForm)
  - System.String.op_Equality(System.String,System.String)
  - System.String.op_Inequality(System.String,System.String)
  - System.String.PadLeft(System.Int32)
  - System.String.PadLeft(System.Int32,System.Char)
  - System.String.PadRight(System.Int32)
  - System.String.PadRight(System.Int32,System.Char)
  - System.String.Remove(System.Int32)
  - System.String.Remove(System.Int32,System.Int32)
  - System.String.Replace(System.Char,System.Char)
  - System.String.Replace(System.String,System.String)
  - System.String.Split(System.Char[])
  - System.String.Split(System.Char[],System.Int32)
  - System.String.Split(System.Char[],System.StringSplitOptions)
  - System.String.Split(System.String[],System.StringSplitOptions)
  - System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)
  - System.String.Split(System.String[],System.Int32,System.StringSplitOptions)
  - System.String.StartsWith(System.String)
  - System.String.StartsWith(System.String,System.StringComparison)
  - System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)
  - System.String.Substring(System.Int32)
  - System.String.Substring(System.Int32,System.Int32)
  - System.String.System#Collections#Generic#IEnumerable{System#Char}#GetEnumerator
  - System.String.System#Collections#IEnumerable#GetEnumerator
  - System.String.System#IConvertible#ToBoolean(System.IFormatProvider)
  - System.String.System#IConvertible#ToByte(System.IFormatProvider)
  - System.String.System#IConvertible#ToChar(System.IFormatProvider)
  - System.String.System#IConvertible#ToDateTime(System.IFormatProvider)
  - System.String.System#IConvertible#ToDecimal(System.IFormatProvider)
  - System.String.System#IConvertible#ToDouble(System.IFormatProvider)
  - System.String.System#IConvertible#ToInt16(System.IFormatProvider)
  - System.String.System#IConvertible#ToInt32(System.IFormatProvider)
  - System.String.System#IConvertible#ToInt64(System.IFormatProvider)
  - System.String.System#IConvertible#ToSByte(System.IFormatProvider)
  - System.String.System#IConvertible#ToSingle(System.IFormatProvider)
  - System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)
  - System.String.System#IConvertible#ToUInt16(System.IFormatProvider)
  - System.String.System#IConvertible#ToUInt32(System.IFormatProvider)
  - System.String.System#IConvertible#ToUInt64(System.IFormatProvider)
  - System.String.ToCharArray
  - System.String.ToCharArray(System.Int32,System.Int32)
  - System.String.ToLower
  - System.String.ToLower(System.Globalization.CultureInfo)
  - System.String.ToLowerInvariant
  - System.String.ToString
  - System.String.ToString(System.IFormatProvider)
  - System.String.ToUpper
  - System.String.ToUpper(System.Globalization.CultureInfo)
  - System.String.ToUpperInvariant
  - System.String.Trim
  - System.String.Trim(System.Char[])
  - System.String.TrimEnd(System.Char[])
  - System.String.TrimStart(System.Char[])
  langs:
  - csharp
  name: String
  nameWithType: String
  fullName: System.String
  type: Class
  summary: "Represents text as a sequence of UTF-16 code units.  \n  \n To browse the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c)."
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n A string is a sequential collection of characters that is used to represent text. A String object is a sequential collection of <xref:System.Char?displayProperty=fullName> objects that represent a string; a <xref:System.Char?displayProperty=fullName> object corresponds to a UTF-16 code unit. The value of the String object is the content of the sequential collection of <xref:System.Char?displayProperty=fullName> objects, and that value is immutable (that is, it is read-only). For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic. The maximum size of a String object in memory is 2GB, or about 1 billion characters.  \n  \n In this section:  \n  \n [Instantiating a String object](#Instantiation)   \n [Char objects and Unicode characters](#Characters)   \n [Strings and The Unicode Standard](#Unicode)   \n [Strings and embedded null characters](#EmbeddedNulls)   \n [Strings and indexes](#Indexes)   \n [Null strings and empty strings](#Nulls)   \n [Immutability and the StringBuilder class](#Immutability)   \n [Ordinal vs. culture-sensitive operations](#CultureSensitive)   \n [Normalization](#Normalization)   \n [String operations by category](#ByCategory)  \n  \n<a name=\"Instantiation\"></a>   \n## Instantiating a String object  \n You can instantiate a String object in the following ways:  \n  \n-   By assigning a string literal to a String variable. This is the most commonly used method for creating a string. The following example uses assignment to create several strings. Note that in C#, because the backslash (\\\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.  \n  \n     [!code-vb[System.String.Class.Instantiate#1](~/add/codesnippet/visualbasic/t-system.string_1.vb)]\n     [!code-cs[System.String.Class.Instantiate#1](~/add/codesnippet/csharp/instantiate1/program.cs#1)]\n     [!code-cpp[System.String.Class.Instantiate#1](~/add/codesnippet/cpp/t-system.string_1.cpp)]  \n  \n-   By calling a String class constructor. The following example instantiates strings by calling several class constructors. Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters. Visual Basic does not support calls to these constructors. For detailed information about String constructors, see the <xref:System.String.%23ctor%2A> constructor summary.  \n  \n     [!code-vb[System.String.Class.Instantiate#2](~/add/codesnippet/visualbasic/t-system.string_2.vb)]\n     [!code-cpp[System.String.Class.Instantiate#2](~/add/codesnippet/cpp/t-system.string_2.cpp)]\n     [!code-cs[System.String.Class.Instantiate#2](~/add/codesnippet/csharp/instantiate1/program.cs#2)]  \n  \n-   By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of String instances and string literals. The following example illustrates the use of the string concatenation operator.  \n  \n     [!code-vb[System.String.Class.Instantiate#3](~/add/codesnippet/visualbasic/t-system.string_3.vb)]\n     [!code-cs[System.String.Class.Instantiate#3](~/add/codesnippet/csharp/instantiate1/program.cs#3)]\n     [!code-cpp[System.String.Class.Instantiate#3](~/add/codesnippet/cpp/t-system.string_3.cpp)]  \n  \n-   By retrieving a property or calling a method that returns a string. The following example uses the methods of the String class to extract a substring from a larger string.  \n  \n     [!code-vb[System.String.Class.Instantiate#4](~/add/codesnippet/visualbasic/t-system.string_4.vb)]\n     [!code-cs[System.String.Class.Instantiate#4](~/add/codesnippet/csharp/instantiate1/program.cs#4)]\n     [!code-cpp[System.String.Class.Instantiate#4](~/add/codesnippet/cpp/t-system.string_4.cpp)]  \n  \n-   By calling a formatting method to convert a value or object to its string representation. The following example uses the                [composite formatting](~/add/includes/ajax-current-ext-md.md) feature to embed the string representation of two objects into a string.  \n  \n     [!code-vb[System.String.Class.Instantiate#5](~/add/codesnippet/visualbasic/t-system.string_5.vb)]\n     [!code-cs[System.String.Class.Instantiate#5](~/add/codesnippet/csharp/instantiate1/program.cs#5)]\n     [!code-cpp[System.String.Class.Instantiate#5](~/add/codesnippet/cpp/t-system.string_5.cpp)]  \n  \n<a name=\"Characters\"></a>   \n## Char objects and Unicode characters  \n Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character. Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.  \n  \n> [!NOTE]\n>  Note that, because a String instance consists of a sequential collection of UTF-16 code units, it is possible to create a String object that is not a well-formed Unicode string. For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate. Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, String class members do not ensure that a string is well-formed.  \n  \n A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point. For example, the code point for the character \"a\" is U+0061. However, a code point might require more than one encoded element (more than one <xref:System.Char> object). The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.  \n  \n-   A grapheme is represented by a base character followed by one or more combining characters. For example, the character ä is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308. This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4. As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not. However, if the two strings are normalized, an ordinal comparison also indicates that they are equal. (For more information on normalizing strings, see the [Normalization](#Normalization) section.)  \n  \n     [!code-cpp[System.String.Class#2](~/add/codesnippet/cpp/t-system.string_6.cpp)]\n     [!code-cs[System.String.Class#2](~/add/codesnippet/csharp/t-system.string_6.cs)]\n     [!code-vb[System.String.Class#2](~/add/codesnippet/visualbasic/t-system.string_6.vb)]  \n  \n-   A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate. The code units of high surrogates range from U+D800 to U+DBFF. The code units of low surrogates range from U+DC00 to U+DFFF. Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes. The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=fullName> method to determine whether it is a surrogate pair.  \n  \n     [!code-cpp[System.String.Class#3](~/add/codesnippet/cpp/t-system.string_7.cpp)]\n     [!code-cs[System.String.Class#3](~/add/codesnippet/csharp/t-system.string_7.cs)]\n     [!code-vb[System.String.Class#3](~/add/codesnippet/visualbasic/t-system.string_7.vb)]  \n  \n<a name=\"Unicode\"></a>   \n## Strings and The Unicode Standard  \n Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.  \n  \n Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <xref:System.Globalization.UnicodeCategory> enumeration. The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=fullName> method.  \n  \n The .NET Framework maintains its own table of characters and their corresponding categories, which ensures that a version of the .NET Framework running on different platforms returns identical character category information. The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which their character categories are based.  \n  \n|.NET Framework version|Version of the Unicode Standard|  \n|----------------------------|-------------------------------------|  \n|[!INCLUDE[net_v11_long](~/add/includes/net-v11-long-md.md)]|[The Unicode Standard, Version 4.0.0](http://www.unicode.org/versions/Unicode4.0.0/)|  \n|The .NET Framework 2.0|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  \n|[!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  \n|[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  \n|[!INCLUDE[net_v45](~/add/includes/net-v45-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  \n|[!INCLUDE[net_v451](~/add/includes/net-v451-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  \n|[!INCLUDE[net_v452](~/add/includes/net-v452-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  \n|[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  \n|[!INCLUDE[net_v461](~/add/includes/net-v461-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  \n|[!INCLUDE[net_v462](~/add/includes/net-v462-md.md)]|[The Unicode Standard, Version 8.0.0](http://www.unicode.org/versions/Unicode8.0.0/)|  \n  \n In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard. In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data. This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] running on Windows 7. Starting with the [!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system. The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.  \n  \n|.NET Framework version|Version of the Unicode Standard|  \n|----------------------------|-------------------------------------|  \n|[!INCLUDE[net_v11_long](~/add/includes/net-v11-long-md.md)]|[The Unicode Standard, Version 4.0.0](http://www.unicode.org/versions/Unicode4.0.0/)|  \n|The .NET Framework 2.0|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  \n|[!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  \n|[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  \n|[!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] and later on Windows 7|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  \n|[!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] and later on Windows 8 and later Windows operating systems|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  \n  \n<a name=\"EmbeddedNulls\"></a>   \n## Strings and embedded null characters  \n In the .NET Framework, a String object can include embedded null characters, which count as a part of the string's length. However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length. This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to String objects:  \n  \n-   The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=fullName>.  \n  \n-   The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=fullName> method.  \n  \n You should ensure that native C and C++ code that instantiates String objects, and code that is passed String objects through platform invoke, do not assume that an embedded null character marks the end of the string.  \n  \n Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched. Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture. They are considered only for ordinal or case-insensitive ordinal comparisons. On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.  \n  \n<a name=\"Indexes\"></a>   \n## Strings and indexes  \n An index is the position of a <xref:System.Char> object (not a Unicode character) in a String. An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero. A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.  \n  \n The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string. Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following. This code looks for white space or punctuation characters in a string to determine how many words the string contains.  \n  \n [!code-cpp[System.String.Class#4](~/add/codesnippet/cpp/t-system.string_8.cpp)]\n [!code-cs[System.String.Class#4](~/add/codesnippet/csharp/t-system.string_8.cs)]\n [!code-vb[System.String.Class#4](~/add/codesnippet/visualbasic/t-system.string_8.vb)]  \n  \n Because the String class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.  \n  \n [!code-cpp[System.String.Class#5](~/add/codesnippet/cpp/t-system.string_9.cpp)]\n [!code-cs[System.String.Class#5](~/add/codesnippet/csharp/t-system.string_9.cs)]\n [!code-vb[System.String.Class#5](~/add/codesnippet/visualbasic/t-system.string_9.vb)]  \n  \n Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object. In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs. To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=fullName> and <xref:System.Globalization.TextElementEnumerator> classes. The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters. It compares the number of characters or text elements in each word of a sentence. The string includes two sequences of a base character followed by a combining character.  \n  \n [!code-cpp[System.String.Class#6](~/add/codesnippet/cpp/t-system.string_10.cpp)]\n [!code-cs[System.String.Class#6](~/add/codesnippet/csharp/t-system.string_10.cs)]\n [!code-vb[System.String.Class#6](~/add/codesnippet/visualbasic/t-system.string_10.vb)]  \n  \n This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=fullName> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string. You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=fullName> method.  \n  \n For more information about working with units of text rather than individual <xref:System.Char> values, see the <xref:System.Globalization.StringInfo> class.  \n  \n<a name=\"Nulls\"></a>   \n## Null strings and empty strings  \n A string that has been declared but has not been assigned a value is `null`. Attempting to call methods on that string throws a <xref:System.NullReferenceException>. A null string is different from an empty string, which is a string whose value is \"\" or <xref:System.String.Empty?displayProperty=fullName>. In some cases, passing either a null string or an empty string as an argument in a method call throws an exception. For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=fullName> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>. In other cases, a method argument can be either a null string or an empty string. For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general (\"G\") format specifier.  \n  \n The String class includes the following two convenience methods that enable you to test whether a string is `null` or empty:  \n  \n-   <xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=fullName>. This method eliminates the need to use code such as the following:  \n  \n     [!code-vb[System.String.Class.Null#1](~/add/codesnippet/visualbasic/t-system.string_11.vb)]\n     [!code-cs[System.String.Class.Null#1](~/add/codesnippet/csharp/t-system.string_11.cs)]\n     [!code-cpp[System.String.Class.Null#1](~/add/codesnippet/cpp/t-system.string_11.cpp)]  \n  \n-   <xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=fullName>, or consists exclusively of white-space characters. This method eliminates the need to use code such as the following:  \n  \n     [!code-vb[System.String.Class.Null#2](~/add/codesnippet/visualbasic/t-system.string_12.vb)]\n     [!code-cs[System.String.Class.Null#2](~/add/codesnippet/csharp/t-system.string_12.cs)]\n     [!code-cpp[System.String.Class.Null#2](~/add/codesnippet/cpp/t-system.string_12.cpp)]  \n  \n The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=fullName> implementation of a custom `Temperature` class. The method supports the \"G\", \"C\", \"F\", and \"K\" format strings. If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the \"G\" format string.  \n  \n [!code-vb[System.String.Class.Null#3](~/add/codesnippet/visualbasic/t-system.string_13.vb)]\n [!code-cs[System.String.Class.Null#3](~/add/codesnippet/csharp/t-system.string_13.cs)]\n [!code-cpp[System.String.Class.Null#3](~/add/codesnippet/cpp/t-system.string_13.cpp)]  \n  \n<a name=\"Immutability\"></a>   \n## Immutability and the StringBuilder class  \n A String object is called immutable (read-only), because its value cannot be modified after it has been created. Methods that appear to modify a String object actually return a new String object that contains the modification.  \n  \n Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty. For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F. Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new String object for each concatenation operation.  \n  \n [!code-cs[System.String.Class#15](~/add/codesnippet/csharp/t-system.string_14.cs)]\n [!code-cpp[System.String.Class#15](~/add/codesnippet/cpp/t-system.string_14.cpp)]\n [!code-vb[System.String.Class#15](~/add/codesnippet/visualbasic/t-system.string_14.vb)]  \n  \n You can use the <xref:System.Text.StringBuilder> class instead of the String class for operations that make multiple changes to the value of a string. Unlike instances of the String class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string. When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=fullName> method to convert it to a string. The following example replaces the String used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.  \n  \n [!code-cpp[System.String.Class#16](~/add/codesnippet/cpp/t-system.string_15.cpp)]\n [!code-cs[System.String.Class#16](~/add/codesnippet/csharp/t-system.string_15.cs)]\n [!code-vb[System.String.Class#16](~/add/codesnippet/visualbasic/t-system.string_15.vb)]  \n  \n<a name=\"CultureSensitive\"></a>   \n## Ordinal vs. culture-sensitive operations  \n Members of the String class perform either ordinal or culture-sensitive (linguistic) operations on a String object. An ordinal operation acts on the numeric value of each <xref:System.Char> object. A culture-sensitive operation acts on the value of the Stringobject, and takes culture-specific casing, sorting, formatting, and parsing rules into account. Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture. The two kinds of operations can produce very different results when they are performed on the same string.  \n  \n The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>), which is loosely based on the culture settings of the English language independent of region. Unlike other <xref:System.Globalization.CultureInfo?displayProperty=fullName> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework. The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.  \n  \n> [!IMPORTANT]\n>  If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison. This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.  \n  \n> [!IMPORTANT]\n>  Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation. In general, you should call this overload to make the intent of your method call clear. For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](~/add/includes/ajax-current-ext-md.md).  \n  \n Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive. The following sections discuss each category of operation.  \n  \n> [!TIP]\n>  You should always call a method overload that makes the intent of your method call clear. For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison?displayProperty=fullName> for the `comparisonType` argument. For more information, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  \n  \n<a name=\"casing\"></a>   \n### Casing  \n Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase. Often, a casing operation is performed before a string comparison. For example, a string might be converted to uppercase so that it can be compared with another uppercase string. You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method. In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=fullName> method to convert a string to title case.  \n  \n Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture. Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture. The actual differences in casing are of three kinds:  \n  \n-   Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131). In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE. In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.  \n  \n     The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison. (The casing conventions of the invariant culture should have been used.)  \n  \n     [!code-cs[System.String.Class#17](~/add/codesnippet/csharp/t-system.string_16.cs)]\n     [!code-vb[System.String.Class#17](~/add/codesnippet/visualbasic/t-system.string_16.vb)]  \n  \n-   Differences in case mappings between the invariant culture and all other cultures. In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character. For all other cultures, it returns a different character. Some of the affected characters are listed in the following table.  \n  \n    |Character|If changed to|Returns|  \n    |---------------|-------------------|-------------|  \n    |MICRON SIGN (U+00B5)|Uppercase|GREEK CAPITAL LETTER MU (U+-39C)|  \n    |LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)|Lowercase|LATIN SMALL LETTER I (U+0069)|  \n    |LATIN SMALL LETTER DOTLESS I (U+0131)|Uppercase|LATIN CAPITAL LETTER I (U+0049)|  \n    |LATIN SMALL LETTER LONG S (U+017F)|Uppercase|LATIN CAPITAL LETTER S (U+0053)|  \n    |LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)|Lowercase|LATIN SMALL LETTER DZ WITH CARON (U+01C6)|  \n    |COMBINING GREEK YPOGEGRAMMENI (U+0345)|Uppercase|GREEK CAPITAL LETTER IOTA (U+0399)|  \n  \n-   Differences in case mappings of two-letter mixed-case pairs in the ASCII character range. In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair. This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:  \n  \n    -   \"lJ\" and \"nJ\" in the hr-HR (Croatian (Croatia)) culture.  \n  \n    -   \"cH\" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.  \n  \n    -   \"aA\" in the da-DK (Danish (Denmark)) culture.  \n  \n    -   \"cS\", \"dZ\", \"dZS\", \"nY\", \"sZ\", \"tY\", and \"zS\" in the hu-HU (Hungarian (Hungary)) culture.  \n  \n    -   \"cH\" and \"lL\" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.  \n  \n    -   \"cH\", \"gI\", \"kH\", \"nG\" \"nH\", \"pH\", \"qU', \"tH\", and \"tR\" in the vi-VN (Vietnamese (Vietnam)) culture.  \n  \n     However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.  \n  \n The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.  \n  \n [!code-cpp[System.String.Class#7](~/add/codesnippet/cpp/t-system.string_17.cpp)]\n [!code-cs[System.String.Class#7](~/add/codesnippet/csharp/t-system.string_17.cs)]\n [!code-vb[System.String.Class#7](~/add/codesnippet/visualbasic/t-system.string_17.vb)]  \n  \n<a name=\"parsing\"></a>   \n### Parsing and formatting  \n Formatting and parsing are inverse operations. Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time. Both formatting and parsing rules are dependent on cultural conventions. The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string. Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.  \n  \n [!code-cpp[System.String.Class#8](~/add/codesnippet/cpp/t-system.string_18.cpp)]\n [!code-cs[System.String.Class#8](~/add/codesnippet/csharp/t-system.string_18.cs)]\n [!code-vb[System.String.Class#8](~/add/codesnippet/visualbasic/t-system.string_18.vb)]  \n  \n Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.  \n  \n [!code-vb[System.String.Class#9](~/add/codesnippet/visualbasic/t-system.string_19.vb)]\n [!code-cpp[System.String.Class#9](~/add/codesnippet/cpp/t-system.string_19.cpp)]\n [!code-cs[System.String.Class#9](~/add/codesnippet/csharp/t-system.string_19.cs)]  \n  \n<a name=\"comparison\"></a>   \n### String comparison and sorting  \n Conventions for comparing and sorting strings vary from culture to culture. For example, the sort order may be based on phonetics or on the visual representation of characters. In East Asian languages, characters are sorted by the stroke and radical of ideographs. Sorting also depends on the order languages and cultures use for the alphabet. For example, the Danish language has an \"Æ\" character that it sorts after \"Z\" in the alphabet. In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture. Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.  \n  \n Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other. For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName> method compares two strings based on the <xref:System.StringComparison> parameter. If the parameter value is <xref:System.StringComparison?displayProperty=fullName>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison?displayProperty=fullName>, the method performs an ordinal comparison. Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName> method (using culture-sensitive comparison) considers \"a\" less than \"A\", but the second call to the same method (using ordinal comparison) considers \"a\" greater than \"A\".  \n  \n [!code-cpp[System.String.Class#10](~/add/codesnippet/cpp/t-system.string_20.cpp)]\n [!code-vb[System.String.Class#10](~/add/codesnippet/visualbasic/t-system.string_20.vb)]\n [!code-cs[System.String.Class#10](~/add/codesnippet/csharp/t-system.string_20.cs)]  \n  \n The .NET Framework supports word, string, and ordinal sort rules:  \n  \n-   A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them. For example, the hyphen (-) might have a very small weight assigned to it so that \"coop\" and \"co-op\" appear next to each other in a sorted list. For a list of the Stringmethods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.  \n  \n-   A string sort also performs a culture-sensitive comparison. It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters. Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=fullName> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions?displayProperty=fullName>. Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.  \n  \n-   An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string. An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points. However, if case is not important, you can specify an ordinal comparison that ignores case. This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result. For a list of the String methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.  \n  \n A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> property. The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=fullName> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName> properties. There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=fullName> property returns `true`) across cultures. You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison?displayProperty=fullName>, <xref:System.StringComparison?displayProperty=fullName>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions?displayProperty=fullName> or <xref:System.Globalization.CompareOptions?displayProperty=fullName> to an appropriate overload of the <xref:System.String.Compare%2A> method. A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not. An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.  \n  \n The following example illustrates the difference between culture-sensitive and ordinal comparison. The example evaluates three strings, \"Apple\", \"Æble\", and \"AEble\", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called). Because the Danish language treats the character \"Æ\" as an individual letter and sorts it after \"Z\" in the alphabet, the string \"Æble\" is greater than \"Apple\". However, \"Æble\" is not considered equivalent to \"AEble\", so \"Æble\" is also greater than \"AEble\". The en-US culture doesn't include the letter\"Æ\" but treats it as equivalent to \"AE\", which explains why  \"Æble\" is less than \"Apple\" but equal to \"AEble\". Ordinal comparison, on the other hand, considers \"Apple\" to be less than \"Æble\", and \"Æble\" to be greater than \"AEble\".  \n  \n [!code-vb[System.String.Class#21](~/add/codesnippet/visualbasic/t-system.string_21.vb)]\n [!code-cs[System.String.Class#21](~/add/codesnippet/csharp/t-system.string_21.cs)]  \n  \n Use the following general guidelines to choose an appropriate sorting or string comparison method:  \n  \n-   If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture. If the user's culture changes, the order of sorted strings will also change accordingly. For example, a thesaurus application should always sort words based on the user's culture.  \n  \n-   If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method. For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.  \n  \n-   If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison. For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.  \n  \n-   For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.  \n  \n> [!NOTE]\n>  The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework. In the [!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] running on the [!INCLUDE[win8](~/add/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard. On other operating systems, it conforms to the Unicode 5.0 standard.  \n  \n For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> topic. For additional recommendations on when to use each rule, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  \n  \n Ordinarily, you do not call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings. Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=fullName> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=fullName>. The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use. Note that each type of sort produces a unique ordering of strings in its array.  \n  \n [!code-cpp[System.String.Class#12](~/add/codesnippet/cpp/t-system.string_22.cpp)]\n [!code-cs[System.String.Class#12](~/add/codesnippet/csharp/t-system.string_22.cs)]\n [!code-vb[System.String.Class#12](~/add/codesnippet/visualbasic/t-system.string_22.vb)]  \n  \n> [!TIP]\n>  Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison. Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic. A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string. If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses. When a sort or comparison operation is required, you use the sort keys instead of the strings. For more information, see the <xref:System.Globalization.SortKey> class.  \n  \n If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=fullName> perform a culture-sensitive, case-sensitive sort on strings. The following example illustrates how changing the current culture affects the order of sorted strings in an array. It creates an array of three strings. First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=fullName> method. The resulting sort order is based on sorting conventions for the English (United States) culture. Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=fullName> method again. Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).  \n  \n [!code-cs[Conceptual.Strings.Comparing#3](~/add/codesnippet/csharp/t-system.string_23.cs)]\n [!code-vb[Conceptual.Strings.Comparing#3](~/add/codesnippet/visualbasic/t-system.string_23.vb)]  \n  \n> [!WARNING]\n>  If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=fullName> method. Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison. The <xref:System.String.Compare%2A?displayProperty=fullName> method is intended primarily to sort strings.  \n  \n String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=fullName> and <xref:System.String.IndexOf%2A?displayProperty=fullName>, also can perform culture-sensitive or ordinal string comparisons. The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method. A culture-sensitive search in which the current culture is English (United States) considers the substring \"oe\" to match the ligature \"œ\". Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty> and finds a match at the beginning of the string. An ordinal search, on the other hand, does not find a match in either case.  \n  \n [!code-cpp[System.String.Class#13](~/add/codesnippet/cpp/t-system.string_24.cpp)]\n [!code-vb[System.String.Class#13](~/add/codesnippet/visualbasic/t-system.string_24.vb)]\n [!code-cs[System.String.Class#13](~/add/codesnippet/csharp/t-system.string_24.cs)]  \n  \n### Searching Strings  \n String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=fullName> and <xref:System.String.IndexOf%2A?displayProperty=fullName>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.  \n  \n The search methods in the String class that search for an individual character, such as the<xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search. To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName>. Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different. For example, a search for a precomposed Unicode character such as the ligature \"Æ\" (U+00C6) might match any occurrence of its components in the correct sequence, such as \"AE\" (U+041U+0045), depending on the culture. The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=fullName> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName> methods when searching for an individual character. The ligature \"æ\" (U+00E6) is found in the string \"aerial\" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.  \n  \n [!code-cs[System.String.Class#22](~/add/codesnippet/csharp/t-system.string_25.cs)]\n [!code-vb[System.String.Class#22](~/add/codesnippet/visualbasic/t-system.string_25.vb)]  \n  \n On the other hand, String class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>. The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.  \n  \n<a name=\"equality\"></a>   \n### Testing for equality  \n Use the <xref:System.String.Compare%2A?displayProperty=fullName> method to determine the relationship of two strings in the sort order. Typically, this is a culture-sensitive operation. In contrast, call the <xref:System.String.Equals%2A?displayProperty=fullName> method to test for equality. Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.  \n  \n> [!WARNING]\n>  It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=fullName> method and determining whether the return value is zero. However, this practice is not recommended. To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=fullName> method. The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=fullName> parameter that explicitly specifies the type of comparison.  \n  \n The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead. In this case, the intent of the code is to prohibit file system access from URLs that begin with \"FILE://\" or \"file://\" by performing a case-insensitive comparison of the beginning of a URL with the string \"FILE://\". However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with \"file://\", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase \"i\" is \"İ\" instead of \"I\". As a result, file system access is inadvertently permitted. On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.  \n  \n [!code-cpp[System.String.Class#11](~/add/codesnippet/cpp/t-system.string_26.cpp)]\n [!code-cs[System.String.Class#11](~/add/codesnippet/csharp/t-system.string_26.cs)]\n [!code-vb[System.String.Class#11](~/add/codesnippet/visualbasic/t-system.string_26.vb)]  \n  \n<a name=\"Normalization\"></a>   \n## Normalization  \n Some Unicode characters have multiple representations. For example, any of the following code points can represent the letter \"ắ\":  \n  \n-   U+1EAF  \n  \n-   U+0103 U+0301  \n  \n-   U+0061 U+0306 U+0301  \n  \n Multiple representations for a single character complicate searching, sorting, matching, and other string operations.  \n  \n The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations. Normalization can use several algorithms, called normalization forms, that follow different rules. The .NET Framework supports Unicode normalization forms C, D, KC, and KD. When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.  \n  \n An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string. TheString class includes a number of methods that can perform an ordinal comparison, including the following:  \n  \n-   Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>,and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter. The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison?displayProperty=fullName> or <xref:System.StringComparison> for this parameter.  \n  \n-   The overloads of the <xref:System.String.CompareOrdinal%2A> method.  \n  \n-   Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.  \n  \n-   Methods that search for a <xref:System.Char>value or for the elements in a <xref:System.Char> arrayin a string instance. Such methods include <xref:System.String.IndexOf%28System.Char%29> and [Split(Char\\[\\])](assetId:///M:System.String.Split(System.Char[])?qualifyHint=False&autoUpgrade=False).  \n  \n You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=fullName> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=fullName> method to determine whether a string is normalized to a specified normalization form. You can also call the <xref:System.String.Normalize?displayProperty=fullName> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=fullName> method to convert a string to a specified normalization form. For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.  \n  \n The following simple example illustrates string normalization. It defines the letter \"ố\" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings. It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form. In each case, the second test for equality shows that the strings are equal.  \n  \n [!code-cpp[System.String.Class#14](~/add/codesnippet/cpp/t-system.string_27.cpp)]\n [!code-cs[System.String.Class#14](~/add/codesnippet/csharp/t-system.string_27.cs)]\n [!code-vb[System.String.Class#14](~/add/codesnippet/visualbasic/t-system.string_27.vb)]  \n  \n For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](http://unicode.org/reports/tr15/) and the [Normalization FAQ](http://www.unicode.org/faq/normalization.html) on the unicode.org website.  \n  \n<a name=\"ByCategory\"></a>   \n## String operations by category  \n The String class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.  \n  \n### Comparing strings  \n You can compare strings to determine their relative position in the sort order by using the following Stringmethods:  \n  \n-   <xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.  \n  \n-   <xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.  \n  \n-   <xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order. The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the String class.  \n  \n### Testing strings for equality  \n You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal. The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored. Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.  \n  \n### Finding characters in a string  \n The String class includes two kinds of search methods:  \n  \n-   Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance. These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.  \n  \n-   Methods that indicate the starting position of a substring in a string instance. These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.  \n  \n> [!WARNING]\n>  If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions. For more information, see [.NET Framework Regular Expressions](~/add/includes/ajax-current-ext-md.md).  \n  \n### Modifying a string  \n The String class includes the following methods that appear to modify the value of a string:  \n  \n-   <xref:System.String.Insert%2A> inserts a string into the current String instance.  \n  \n-   <xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.  \n  \n-   <xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the beginning of a string.  \n  \n-   <xref:System.String.Remove%2A> deletes a substring from the current String instance.  \n  \n-   <xref:System.String.Replace%2A> replaces a substring with another substring in the current String instance.  \n  \n-   <xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.  \n  \n-   <xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.  \n  \n-   <xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.  \n  \n-   <xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.  \n  \n-   <xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.  \n  \n> [!IMPORTANT]\n>  All string modification methods return a new String object. They do not modify the value of the current instance.  \n  \n### Extracting substrings from a string  \n The <xref:System.String.Split%2A?displayProperty=fullName> method separates a single string into multiple strings. Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.  \n  \n### Combining strings  \n The following String methods can be used for string concatenation:  \n  \n-   <xref:System.String.Concat%2A> combines one or more substrings into a single string.  \n  \n-   <xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.  \n  \n### Formatting values  \n The <xref:System.String.Format%2A?displayProperty=fullName> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value. The <xref:System.String.Format%2A> method is often used to do the following:  \n  \n-   To embed the string representation of a numeric value in a string.  \n  \n-   To embed the string representation of a date and time value in a string.  \n  \n-   To embed the string representation of an enumeration value in a string.  \n  \n-   To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.  \n  \n-   To right-justify or left-justify a substring in a field within a larger string.  \n  \n For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.  \n  \n### Copying a string  \n You can call the following String methods to make a copy of a string:  \n  \n-   <xref:System.String.Clone%2A> returns a reference to an existing String object.  \n  \n-   <xref:System.String.Copy%2A> creates a copy of an existing string.  \n  \n-   <xref:System.String.CopyTo%2A> copies a portion of a string to a character array.  \n  \n### Normalizing a string  \n In Unicode, a single character can have multiple code points. Normalization converts these equivalent characters into the same binary representation. The <xref:System.String.Normalize%2A?displayProperty=fullName> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=fullName> method determines whether a string is normalized.  \n  \n For more information and an example, see the [Normalization](#Normalization) section earlier in this topic."
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class String : ICloneable, IComparable, IComparable<string>, IConvertible, IEquatable<string>, System.Collections.Generic.IEnumerable<char>
  inheritance:
  - System.Object
  implements:
  - System.Collections.Generic.IEnumerable<System.Char>
  - System.ICloneable
  - System.IComparable
  - System.IComparable<System.String>
  - System.IConvertible
  - System.IEquatable<System.String>
  inheritedMembers:
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.#ctor(System.Char*)
  id: '#ctor(System.Char*)'
  parent: System.String
  langs:
  - csharp
  name: String(Char*)
  nameWithType: String.String(Char*)
  fullName: System.String.String(Char*)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: Initializes a new instance of the <xref href="System.String"></xref> class to the value indicated by a specified pointer to an array of Unicode characters.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other `String`constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.
  syntax:
    content: public String (char* value);
    parameters:
    - id: value
      type: System.Char*
      description: A pointer to a null-terminated array of Unicode characters.
  overload: System.String.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: The current process does not have read access to all the addressed characters.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>value</code> specifies an array that contains an invalid Unicode character, or <code>value</code> specifies an address less than 64000.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.#ctor(System.Char[])
  id: '#ctor(System.Char[])'
  parent: System.String
  langs:
  - csharp
  name: String(Char[])
  nameWithType: String.String(Char[])
  fullName: System.String.String(Char[])
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: Initializes a new instance of the <xref href="System.String"></xref> class to the value indicated by an array of Unicode characters.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.
  syntax:
    content: public String (char[] value);
    parameters:
    - id: value
      type: System.Char[]
      description: An array of Unicode characters.
  overload: System.String.#ctor*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.#ctor(System.SByte*)
  id: '#ctor(System.SByte*)'
  parent: System.String
  langs:
  - csharp
  name: String(SByte*)
  nameWithType: String.String(SByte*)
  fullName: System.String.String(SByte*)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: Initializes a new instance of the <xref href="System.String"></xref> class to the value indicated by a pointer to an array of 8-bit signed integers.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.
  syntax:
    content: public String (sbyte* value);
    parameters:
    - id: value
      type: System.SByte*
      description: A pointer to a null-terminated array of 8-bit signed integers. The integers are interpreted using the current system code page encoding (that is, the encoding specified by <xref:System.Text.Encoding.Default*?displayProperty=fullName>).
  overload: System.String.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: A new instance of <xref href="System.String"></xref> could not be initialized using <code>value</code>, assuming <code>value</code> is encoded in ANSI.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: The length of the new string to initialize, which is determined by the null termination character of <code>value</code>, is too large to allocate.
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: <code>value</code> specifies an invalid address.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.#ctor(System.Char,System.Int32)
  id: '#ctor(System.Char,System.Int32)'
  parent: System.String
  langs:
  - csharp
  name: String(Char,Int32)
  nameWithType: String.String(Char,Int32)
  fullName: System.String.String(Char,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: Initializes a new instance of the <xref href="System.String"></xref> class to the value indicated by a specified Unicode character repeated a specified number of times.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.
  syntax:
    content: public String (char c, int count);
    parameters:
    - id: c
      type: System.Char
      description: A Unicode character.
    - id: count
      type: System.Int32
      description: The number of times `c` occurs.
  overload: System.String.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>count</code> is less than zero.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.#ctor(System.Char*,System.Int32,System.Int32)
  id: '#ctor(System.Char*,System.Int32,System.Int32)'
  parent: System.String
  langs:
  - csharp
  name: String(Char*,Int32,Int32)
  nameWithType: String.String(Char*,Int32,Int32)
  fullName: System.String.String(Char*,Int32,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: Initializes a new instance of the <xref href="System.String"></xref> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.
  syntax:
    content: public String (char* value, int startIndex, int length);
    parameters:
    - id: value
      type: System.Char*
      description: A pointer to an array of Unicode characters.
    - id: startIndex
      type: System.Int32
      description: The starting position within `value`.
    - id: length
      type: System.Int32
      description: The number of characters within `value` to use.
  overload: System.String.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>startIndex</code> or <code>length</code> is less than zero, <code>value</code> + <code>startIndex</code> cause a pointer overflow, or the current process does not have read access to all the addressed characters.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>value</code> specifies an array that contains an invalid Unicode character, or <code>value</code> + <code>startIndex</code> specifies an address less than 64000.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.#ctor(System.Char[],System.Int32,System.Int32)
  id: '#ctor(System.Char[],System.Int32,System.Int32)'
  parent: System.String
  langs:
  - csharp
  name: String(Char[],Int32,Int32)
  nameWithType: String.String(Char[],Int32,Int32)
  fullName: System.String.String(Char[],Int32,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: Initializes a new instance of the <xref href="System.String"></xref> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.
  syntax:
    content: public String (char[] value, int startIndex, int length);
    parameters:
    - id: value
      type: System.Char[]
      description: An array of Unicode characters.
    - id: startIndex
      type: System.Int32
      description: The starting position within `value`.
    - id: length
      type: System.Int32
      description: The number of characters within `value` to use.
  overload: System.String.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code> or <code>length</code> is less than zero.  \n  \n -or-  \n  \n The sum of <code>startIndex</code> and <code>length</code> is greater than the number of elements in <code>value</code>."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.#ctor(System.SByte*,System.Int32,System.Int32)
  id: '#ctor(System.SByte*,System.Int32,System.Int32)'
  parent: System.String
  langs:
  - csharp
  name: String(SByte*,Int32,Int32)
  nameWithType: String.String(SByte*,Int32,Int32)
  fullName: System.String.String(SByte*,Int32,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: Initializes a new instance of the <xref href="System.String"></xref> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.
  syntax:
    content: public String (sbyte* value, int startIndex, int length);
    parameters:
    - id: value
      type: System.SByte*
      description: A pointer to an array of 8-bit signed integers. The integers are interpreted using the current system code page encoding (that is, the encoding specified by <xref:System.Text.Encoding.Default*?displayProperty=fullName>).
    - id: startIndex
      type: System.Int32
      description: The starting position within `value`.
    - id: length
      type: System.Int32
      description: The number of characters within `value` to use.
  overload: System.String.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code> or <code>length</code> is less than zero.  \n  \n -or-  \n  \n The address specified by <code>value</code> + <code>startIndex</code> is too large for the current platform; that is, the address calculation overflowed.  \n  \n -or-  \n  \n The length of the new string to initialize is too large to allocate."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The address specified by <code>value</code> + <code>startIndex</code> is less than 64K.  \n  \n -or-  \n  \n A new instance of <xref href=\"System.String\"></xref> could not be initialized using <code>value</code>, assuming <code>value</code> is encoded in ANSI."
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: <code>value</code>, <code>startIndex</code>, and <code>length</code> collectively specify an invalid address.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)
  id: '#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)'
  parent: System.String
  langs:
  - csharp
  name: String(SByte*,Int32,Int32,Encoding)
  nameWithType: String.String(SByte*,Int32,Int32,Encoding)
  fullName: System.String.String(SByte*,Int32,Int32,Encoding)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: Initializes a new instance of the <xref href="System.String"></xref> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref href="System.Text.Encoding"></xref> object.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.
  syntax:
    content: public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);
    parameters:
    - id: value
      type: System.SByte*
      description: A pointer to an array of 8-bit signed integers.
    - id: startIndex
      type: System.Int32
      description: The starting position within `value`.
    - id: length
      type: System.Int32
      description: The number of characters within `value` to use.
    - id: enc
      type: System.Text.Encoding
      description: An object that specifies how the array referenced by `value` is encoded. If `enc` is `null`, ANSI encoding is assumed.
  overload: System.String.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code> or <code>length</code> is less than zero.  \n  \n -or-  \n  \n The address specified by <code>value</code> + <code>startIndex</code> is too large for the current platform; that is, the address calculation overflowed.  \n  \n -or-  \n  \n The length of the new string to initialize is too large to allocate."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The address specified by <code>value</code> + <code>startIndex</code> is less than 64K.  \n  \n -or-  \n  \n A new instance of <xref href=\"System.String\"></xref> could not be initialized using <code>value</code>, assuming <code>value</code> is encoded as specified by <code>enc</code>."
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: <code>value</code>, <code>startIndex</code>, and <code>length</code> collectively specify an invalid address.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Chars(System.Int32)
  id: Chars(System.Int32)
  parent: System.String
  langs:
  - csharp
  name: Chars(Int32)
  nameWithType: String.Chars(Int32)
  fullName: System.String.Chars(Int32)
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: Gets the <xref href="System.Char"></xref> object at a specified position in the current <xref href="System.String"></xref> object.
  remarks: "The `index` parameter is zero-based.  \n  \n This property returns the <xref:System.Char> object at the position specified by the `index` parameter. However, a Unicode character might be represented by more than one <xref:System.Char>. Use the <xref:System.Globalization.StringInfo?displayProperty=fullName> class to work with Unicode characters instead of <xref:System.Char> objects. For more information, see the \"Char Objects and Unicode Characters\" section in the <xref:System.String> class overview.  \n  \n In C#, the Chars property is an indexer. In Visual Basic, it is the default property of the <xref:System.String> class. Each <xref:System.Char> object in the string can be accessed by using code such as the following.  \n  \n [!code-cs[System.String.Chars#1](~/add/codesnippet/csharp/p-system.string.chars-sy_1.cs)]\n [!code-vb[System.String.Chars#1](~/add/codesnippet/visualbasic/p-system.string.chars-sy_1.vb)]"
  example:
  - "The following example demonstrates how you can use this indexer in a routine to validate a string.  \n  \n [!code-vb[Uri_IsHexDigit#1](~/add/codesnippet/visualbasic/p-system.string.chars-sy_2.vb)]\n [!code-cpp[Uri_IsHexDigit#1](~/add/codesnippet/cpp/p-system.string.chars-sy_2.cpp)]\n [!code-cs[Uri_IsHexDigit#1](~/add/codesnippet/csharp/p-system.string.chars-sy_2.cs)]"
  syntax:
    content: public char this[int index] { get; }
    parameters:
    - id: index
      type: System.Int32
      description: A position in the current string.
    return:
      type: System.Char
      description: The object at position <code>index</code>.
  overload: System.String.Chars*
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: <code>index</code> is greater than or equal to the length of this object or less than zero.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Clone
  id: Clone
  parent: System.String
  langs:
  - csharp
  name: Clone()
  nameWithType: String.Clone()
  fullName: System.String.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a reference to this instance of <xref href="System.String"></xref>.
  remarks: "The return value is not an independent copy of this instance; it is simply another view of the same data. Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.  \n  \n Because the Clone method simply returns the existing string instance, there is little reason to call it directly."
  syntax:
    content: public object Clone ();
    parameters: []
    return:
      type: System.Object
      description: This instance of <xref href="System.String"></xref>.
  overload: System.String.Clone*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.String)
  id: Compare(System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,String)
  nameWithType: String.Compare(String,String)
  fullName: System.String.Compare(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares two specified <xref href="System.String"></xref> objects and returns an integer that indicates their relative position in the sort order.
  remarks: "The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  \n  \n The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  \n  \n> [!WARNING]\n>  When comparing strings, you should call the<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see [Best Practices for Using Strings](~/add/includes/ajax-current-ext-md.md).  \n  \n One or both comparands can be `null`. By definition, any string, including the empty string (\"\"), compares greater than a null reference; and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  \n  \n Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter \"i\" in \"file\".  \n  \n [!code-cpp[System.String.Compare#10](~/add/codesnippet/cpp/m-system.string.compare-_1_1.cpp)]\n [!code-cs[System.String.Compare#10](~/add/codesnippet/csharp/m-system.string.compare-_1_1.cs)]\n [!code-vb[System.String.Compare#10](~/add/codesnippet/visualbasic/m-system.string.compare-_1_1.vb)]  \n  \n Compare the path name to \"file\" using an ordinal comparison. The correct code to do this is as follows:  \n  \n [!code-cpp[System.String.Compare#11](~/add/codesnippet/cpp/m-system.string.compare-_1_2.cpp)]\n [!code-cs[System.String.Compare#11](~/add/codesnippet/csharp/m-system.string.compare-_1_2.cs)]\n [!code-vb[System.String.Compare#11](~/add/codesnippet/visualbasic/m-system.string.compare-_1_2.vb)]"
  example:
  - "The following example calls the Compare method to compare three sets of strings.  \n  \n [!code-cpp[System.String.Compare#18](~/add/codesnippet/cpp/m-system.string.compare-_1_3.cpp)]\n [!code-vb[System.String.Compare#18](~/add/codesnippet/visualbasic/m-system.string.compare-_1_3.vb)]\n [!code-cs[System.String.Compare#18](~/add/codesnippet/csharp/m-system.string.compare-_1_3.cs)]  \n  \n In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the Compare method.  \n  \n [!code-cs[ArrayList#7](~/add/codesnippet/csharp/m-system.string.compare-_1_4.cs)]\n [!code-cpp[ArrayList#7](~/add/codesnippet/cpp/m-system.string.compare-_1_4.cpp)]\n [!code-vb[ArrayList#7](~/add/codesnippet/visualbasic/m-system.string.compare-_1_4.vb)]"
  syntax:
    content: public static int Compare (string strA, string strB);
    parameters:
    - id: strA
      type: System.String
      description: The first string to compare.
    - id: strB
      type: System.String
      description: The second string to compare.
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|<code>strA</code> precedes <code>strB</code> in the sort order.|  \n|Zero|<code>strA</code> occurs in the same position as <code>strB</code> in the sort order.|  \n|Greater than zero|<code>strA</code> follows <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.String,System.Boolean)
  id: Compare(System.String,System.String,System.Boolean)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,String,Boolean)
  nameWithType: String.Compare(String,String,Boolean)
  fullName: System.String.Compare(String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares two specified <xref href="System.String"></xref> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.
  remarks: "The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  \n  \n The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  \n  \n> [!WARNING]\n>  When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see [Best Practices for Using Strings](~/add/includes/ajax-current-ext-md.md).  \n  \n One or both comparands can be `null`. By definition, any string, including the empty string (\"\"), compares greater than a null reference; and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  \n  \n Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter \"i\" in \"file\".  \n  \n [!code-cpp[System.String.Compare#12](~/add/codesnippet/cpp/m-system.string.compare-_2_1.cpp)]\n [!code-cs[System.String.Compare#12](~/add/codesnippet/csharp/m-system.string.compare-_2_1.cs)]\n [!code-vb[System.String.Compare#12](~/add/codesnippet/visualbasic/m-system.string.compare-_2_1.vb)]  \n  \n Compare the path name to \"file\" using an ordinal comparison. The correct code to do this is as follows:  \n  \n [!code-cpp[System.String.Compare#13](~/add/codesnippet/cpp/m-system.string.compare-_2_2.cpp)]\n [!code-cs[System.String.Compare#13](~/add/codesnippet/csharp/m-system.string.compare-_2_2.cs)]\n [!code-vb[System.String.Compare#13](~/add/codesnippet/visualbasic/m-system.string.compare-_2_2.vb)]"
  example:
  - "The following example demonstrates that the Compare method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.  \n  \n [!code-cpp[System.String.Compare#18](~/add/codesnippet/cpp/m-system.string.compare-_2_3.cpp)]\n [!code-vb[System.String.Compare#18](~/add/codesnippet/visualbasic/m-system.string.compare-_2_3.vb)]\n [!code-cs[System.String.Compare#18](~/add/codesnippet/csharp/m-system.string.compare-_2_3.cs)]"
  syntax:
    content: public static int Compare (string strA, string strB, bool ignoreCase);
    parameters:
    - id: strA
      type: System.String
      description: The first string to compare.
    - id: strB
      type: System.String
      description: The second string to compare.
    - id: ignoreCase
      type: System.Boolean
      description: '`true` to ignore case during the comparison; otherwise, `false`.'
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|<code>strA</code> precedes <code>strB</code> in the sort order.|  \n|Zero|<code>strA</code> occurs in the same position as <code>strB</code> in the sort order.|  \n|Greater than zero|<code>strA</code> follows <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.String,System.StringComparison)
  id: Compare(System.String,System.String,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,String,StringComparison)
  nameWithType: String.Compare(String,String,StringComparison)
  fullName: System.String.Compare(String,String,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares two specified <xref href="System.String"></xref> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.
  remarks: "The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.  \n  \n One or both comparands can be `null`. By definition, any string, including the empty string (\"\"), compares greater than a null reference; and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  \n  \n Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter \"i\" in \"file\".  \n  \n [!code-cpp[System.String.Compare#16](~/add/codesnippet/cpp/m-system.string.compare-_0_1.cpp)]\n [!code-cs[System.String.Compare#16](~/add/codesnippet/csharp/m-system.string.compare-_0_1.cs)]\n [!code-vb[System.String.Compare#16](~/add/codesnippet/visualbasic/m-system.string.compare-_0_1.vb)]  \n  \n Compare the path name to \"file\" using an ordinal comparison. The correct code to do this is as follows:  \n  \n [!code-cpp[System.String.Compare#17](~/add/codesnippet/cpp/m-system.string.compare-_0_2.cpp)]\n [!code-cs[System.String.Compare#17](~/add/codesnippet/csharp/m-system.string.compare-_0_2.cs)]\n [!code-vb[System.String.Compare#17](~/add/codesnippet/visualbasic/m-system.string.compare-_0_2.vb)]"
  example:
  - "The following example compares three versions of the letter \"I\". The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.  \n  \n [!code-cs[System.String.CompareCmp#1](~/add/codesnippet/csharp/m-system.string.compare-_0_3.cs)]\n [!code-cpp[System.String.CompareCmp#1](~/add/codesnippet/cpp/m-system.string.compare-_0_3.cpp)]\n [!code-vb[System.String.CompareCmp#1](~/add/codesnippet/visualbasic/m-system.string.compare-_0_3.vb)]"
  syntax:
    content: public static int Compare (string strA, string strB, StringComparison comparisonType);
    parameters:
    - id: strA
      type: System.String
      description: The first string to compare.
    - id: strB
      type: System.String
      description: The second string to compare.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules to use in the comparison.
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|<code>strA</code> precedes <code>strB</code> in the sort order.|  \n|Zero|<code>strA</code> is in the same position as <code>strB</code> in the sort order.|  \n|Greater than zero|<code>strA</code> follows <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a <xref href="System.StringComparison"></xref> value.
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: <xref href="System.StringComparison"></xref> is not supported.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)
  id: Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,String,Boolean,CultureInfo)
  nameWithType: String.Compare(String,String,Boolean,CultureInfo)
  fullName: System.String.Compare(String,String,Boolean,CultureInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares two specified <xref href="System.String"></xref> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.
  remarks: "The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  \n  \n The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  \n  \n One or both comparands can be `null`. By definition, any string, including the empty string (\"\"), compares greater than a null reference; and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  \n  \n Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter \"i\" in \"file\".  \n  \n [!code-cpp[System.String.Compare#14](~/add/codesnippet/cpp/ad8a53ca-9e37-4bd2-aed7-_1.cpp)]\n [!code-cs[System.String.Compare#14](~/add/codesnippet/csharp/ad8a53ca-9e37-4bd2-aed7-_1.cs)]\n [!code-vb[System.String.Compare#14](~/add/codesnippet/visualbasic/ad8a53ca-9e37-4bd2-aed7-_1.vb)]  \n  \n Compare the path name to \"file\" using an ordinal comparison. The correct code to do this is as follows:  \n  \n [!code-cpp[System.String.Compare#15](~/add/codesnippet/cpp/ad8a53ca-9e37-4bd2-aed7-_2.cpp)]\n [!code-cs[System.String.Compare#15](~/add/codesnippet/csharp/ad8a53ca-9e37-4bd2-aed7-_2.cs)]\n [!code-vb[System.String.Compare#15](~/add/codesnippet/visualbasic/ad8a53ca-9e37-4bd2-aed7-_2.vb)]"
  example:
  - "The following example demonstrates how culture can affect a comparison. In Czech - Czech Republic culture, \"ch\" is a single character that is greater than \"d\". However, in English - United States culture, \"ch\" consists of two characters, and \"c\" is less than \"d\".  \n  \n [!code-cs[string.comp4#1](~/add/codesnippet/csharp/ad8a53ca-9e37-4bd2-aed7-_3.cs)]\n [!code-vb[string.comp4#1](~/add/codesnippet/visualbasic/ad8a53ca-9e37-4bd2-aed7-_3.vb)]\n [!code-cpp[string.comp4#1](~/add/codesnippet/cpp/ad8a53ca-9e37-4bd2-aed7-_3.cpp)]"
  syntax:
    content: public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);
    parameters:
    - id: strA
      type: System.String
      description: The first string to compare.
    - id: strB
      type: System.String
      description: The second string to compare.
    - id: ignoreCase
      type: System.Boolean
      description: '`true` to ignore case during the comparison; otherwise, `false`.'
    - id: culture
      type: System.Globalization.CultureInfo
      description: An object that supplies culture-specific comparison information.
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|<code>strA</code> precedes <code>strB</code> in the sort order.|  \n|Zero|<code>strA</code> occurs in the same position as <code>strB</code> in the sort order.|  \n|Greater than zero|<code>strA</code> follows <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>culture</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)
  id: Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,String,CultureInfo,CompareOptions)
  nameWithType: String.Compare(String,String,CultureInfo,CompareOptions)
  fullName: System.String.Compare(String,String,CultureInfo,CompareOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares two specified <xref href="System.String"></xref> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.
  remarks: "The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters. For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.  \n  \n> [!CAUTION]\n>  The Compare method is designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero). To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.  \n  \n The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration. However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions?displayProperty=fullName> and <xref:System.Globalization.CompareOptions?displayProperty=fullName> values have no effect.  \n  \n Either or both comparands can be `null`. By definition, any string, including <xref:System.String.Empty?displayProperty=fullName>, compares greater than a null reference, and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater."
  example:
  - "The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison. It illustrates how the three methods of comparison produce three different results.  \n  \n [!code-cs[System.String.Compare#1](~/add/codesnippet/csharp/320b2dff-7f26-42ad-8954-_1.cs)]\n [!code-cpp[System.String.Compare#1](~/add/codesnippet/cpp/320b2dff-7f26-42ad-8954-_1.cpp)]\n [!code-vb[System.String.Compare#1](~/add/codesnippet/visualbasic/320b2dff-7f26-42ad-8954-_1.vb)]"
  syntax:
    content: public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
    parameters:
    - id: strA
      type: System.String
      description: The first string to compare.
    - id: strB
      type: System.String
      description: The second string to compare.
    - id: culture
      type: System.Globalization.CultureInfo
      description: The culture that supplies culture-specific comparison information.
    - id: options
      type: System.Globalization.CompareOptions
      description: Options to use when performing the comparison (such as ignoring case or symbols).
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates the lexical relationship between <code>strA</code> and <code>strB</code>, as shown in the following table  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|<code>strA</code> precedes <code>strB</code> in the sort order.|  \n|Zero|<code>strA</code> occurs in the same position as <code>strB</code> in the sort order.|  \n|Greater than zero|<code>strA</code> follows <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>options</code> is not a <xref href="System.Globalization.CompareOptions"></xref> value.
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>culture</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)
  id: Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,Int32,String,Int32,Int32)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares substrings of two specified <xref href="System.String"></xref> objects and returns an integer that indicates their relative position in the sort order.
  remarks: "The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`. Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero. The length of the first substring is equal to the length of `strA` minus `indexA` plus one. The length of the second substring is equal to the length of `strB` minus `indexB` plus one.  \n  \n The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  \n  \n The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  \n  \n The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  \n  \n> [!WARNING]\n>  When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see [Best Practices for Using Strings](~/add/includes/ajax-current-ext-md.md).  \n  \n One or both comparands can be `null`. By definition, any string, including the empty string (\"\"), compares greater than a null reference; and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  \n  \n Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter \"i\" in \"file\".  \n  \n [!code-cpp[System.String.Compare#2](~/add/codesnippet/cpp/8c5c93c7-7358-46af-8568-_1.cpp)]\n [!code-cs[System.String.Compare#2](~/add/codesnippet/csharp/8c5c93c7-7358-46af-8568-_1.cs)]\n [!code-vb[System.String.Compare#2](~/add/codesnippet/visualbasic/8c5c93c7-7358-46af-8568-_1.vb)]  \n  \n Compare the path name to \"file\" using an ordinal comparison. The correct code to do this is as follows:  \n  \n [!code-cpp[System.String.Compare#3](~/add/codesnippet/cpp/8c5c93c7-7358-46af-8568-_2.cpp)]\n [!code-cs[System.String.Compare#3](~/add/codesnippet/csharp/8c5c93c7-7358-46af-8568-_2.cs)]\n [!code-vb[System.String.Compare#3](~/add/codesnippet/visualbasic/8c5c93c7-7358-46af-8568-_2.vb)]"
  example:
  - "The following example compares two substrings.  \n  \n [!code-cs[string.compare3#1](~/add/codesnippet/csharp/8c5c93c7-7358-46af-8568-_3.cs)]\n [!code-vb[string.compare3#1](~/add/codesnippet/visualbasic/8c5c93c7-7358-46af-8568-_3.vb)]\n [!code-cpp[string.compare3#1](~/add/codesnippet/cpp/8c5c93c7-7358-46af-8568-_3.cpp)]"
  syntax:
    content: public static int Compare (string strA, int indexA, string strB, int indexB, int length);
    parameters:
    - id: strA
      type: System.String
      description: The first string to use in the comparison.
    - id: indexA
      type: System.Int32
      description: The position of the substring within `strA`.
    - id: strB
      type: System.String
      description: The second string to use in the comparison.
    - id: indexB
      type: System.Int32
      description: The position of the substring within `strB`.
    - id: length
      type: System.Int32
      description: The maximum number of characters in the substrings to compare.
    return:
      type: System.Int32
      description: "A 32-bit signed integer indicating the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|The substring in <code>strA</code> precedes the substring in <code>strB</code> in the sort order.|  \n|Zero|The substrings occur in the same position in the sort order, or <code>length</code> is zero.|  \n|Greater than zero|The substring in <code>strA</code> follows the substring in <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>indexA</code> is greater than <code>strA</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexB</code> is greater than <code>strB</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexA</code>, <code>indexB</code>, or <code>length</code> is negative.  \n  \n -or-  \n  \n Either <code>indexA</code> or <code>indexB</code> is `null`, and <code>length</code> is greater than zero."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)
  id: Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,Int32,String,Int32,Int32,Boolean)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32,Boolean)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares substrings of two specified <xref href="System.String"></xref> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.
  remarks: "The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`. Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero. The length of the first substring is equal to the length of `strA` minus `indexA` plus one. The length of the second substring is equal to the length of `strB` minus `indexB` plus one.  \n  \n The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  \n  \n The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  \n  \n The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  \n  \n> [!WARNING]\n>  When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see [Best Practices for Using Strings](~/add/includes/ajax-current-ext-md.md).  \n  \n One or both comparands can be `null`. By definition, any string, including the empty string (\"\"), compares greater than a null reference; and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  \n  \n Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter \"i\" in \"file\".  \n  \n [!code-cpp[System.String.Compare#4](~/add/codesnippet/cpp/77bf3f9a-3a96-4da3-94d4-_1.cpp)]\n [!code-cs[System.String.Compare#4](~/add/codesnippet/csharp/77bf3f9a-3a96-4da3-94d4-_1.cs)]\n [!code-vb[System.String.Compare#4](~/add/codesnippet/visualbasic/77bf3f9a-3a96-4da3-94d4-_1.vb)]  \n  \n The path name needs to be compared in an invariant manner. The correct code to do this is as follows.  \n  \n [!code-cpp[System.String.Compare#5](~/add/codesnippet/cpp/77bf3f9a-3a96-4da3-94d4-_2.cpp)]\n [!code-cs[System.String.Compare#5](~/add/codesnippet/csharp/77bf3f9a-3a96-4da3-94d4-_2.cs)]\n [!code-vb[System.String.Compare#5](~/add/codesnippet/visualbasic/77bf3f9a-3a96-4da3-94d4-_2.vb)]"
  example:
  - "The following example performs two comparisons of two substrings that only differ in case. The first comparison ignores case and the second comparison considers case.  \n  \n [!code-cs[string.compare4#1](~/add/codesnippet/csharp/77bf3f9a-3a96-4da3-94d4-_3.cs)]\n [!code-cpp[string.compare4#1](~/add/codesnippet/cpp/77bf3f9a-3a96-4da3-94d4-_3.cpp)]\n [!code-vb[string.compare4#1](~/add/codesnippet/visualbasic/77bf3f9a-3a96-4da3-94d4-_3.vb)]"
  syntax:
    content: public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    parameters:
    - id: strA
      type: System.String
      description: The first string to use in the comparison.
    - id: indexA
      type: System.Int32
      description: The position of the substring within `strA`.
    - id: strB
      type: System.String
      description: The second string to use in the comparison.
    - id: indexB
      type: System.Int32
      description: The position of the substring within `strB`.
    - id: length
      type: System.Int32
      description: The maximum number of characters in the substrings to compare.
    - id: ignoreCase
      type: System.Boolean
      description: '`true` to ignore case during the comparison; otherwise, `false`.'
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|The substring in <code>strA</code> precedes the substring in <code>strB</code> in the sort order.|  \n|Zero|The substrings occur in the same position in the sort order, or <code>length</code> is zero.|  \n|Greater than zero|The substring in <code>strA</code> follows the substring in <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>indexA</code> is greater than <code>strA</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexB</code> is greater than <code>strB</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexA</code>, <code>indexB</code>, or <code>length</code> is negative.  \n  \n -or-  \n  \n Either <code>indexA</code> or <code>indexB</code> is `null`, and <code>length</code> is greater than zero."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)
  id: Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,Int32,String,Int32,Int32,StringComparison)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32,StringComparison)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares substrings of two specified <xref href="System.String"></xref> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.
  remarks: "The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`. Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one. The length of the first substring is equal to the length of `strA` minus `indexA` plus one. The length of the second substring is equal to the length of `strB` minus `indexB` plus one.  \n  \n The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  \n  \n The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.  \n  \n One or both comparands can be `null`. By definition, any string, including the empty string (\"\"), compares greater than a null reference; and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  \n  \n Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter \"i\" in \"file\".  \n  \n [!code-cpp[System.String.Compare#8](~/add/codesnippet/cpp/5ade3071-47e0-44d8-8163-_1.cpp)]\n [!code-cs[System.String.Compare#8](~/add/codesnippet/csharp/5ade3071-47e0-44d8-8163-_1.cs)]\n [!code-vb[System.String.Compare#8](~/add/codesnippet/visualbasic/5ade3071-47e0-44d8-8163-_1.vb)]  \n  \n Compare the path name to \"file\" using an ordinal comparison. The correct code to do this is as follows:  \n  \n [!code-cpp[System.String.Compare#9](~/add/codesnippet/cpp/5ade3071-47e0-44d8-8163-_2.cpp)]\n [!code-cs[System.String.Compare#9](~/add/codesnippet/csharp/5ade3071-47e0-44d8-8163-_2.cs)]\n [!code-vb[System.String.Compare#9](~/add/codesnippet/visualbasic/5ade3071-47e0-44d8-8163-_2.vb)]"
  example:
  - "The following example compares two substrings.  \n  \n [!code-cs[string.compare3#1](~/add/codesnippet/csharp/5ade3071-47e0-44d8-8163-_3.cs)]\n [!code-vb[string.compare3#1](~/add/codesnippet/visualbasic/5ade3071-47e0-44d8-8163-_3.vb)]\n [!code-cpp[string.compare3#1](~/add/codesnippet/cpp/5ade3071-47e0-44d8-8163-_3.cpp)]"
  syntax:
    content: public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    parameters:
    - id: strA
      type: System.String
      description: The first string to use in the comparison.
    - id: indexA
      type: System.Int32
      description: The position of the substring within `strA`.
    - id: strB
      type: System.String
      description: The second string to use in the comparison.
    - id: indexB
      type: System.Int32
      description: The position of the substring within `strB`.
    - id: length
      type: System.Int32
      description: The maximum number of characters in the substrings to compare.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules to use in the comparison.
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|The substring in <code>strA</code> precedes the substring in <code>strB</code> in the sort order.|  \n|Zero|The substrings occur in the same position in the sort order, or the <code>length</code> parameter is zero.|  \n|Greater than zero|The substring in <code>strA</code> follllows the substring in <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>indexA</code> is greater than <code>strA</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexB</code> is greater than <code>strB</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexA</code>, <code>indexB</code>, or <code>length</code> is negative.  \n  \n -or-  \n  \n Either <code>indexA</code> or <code>indexB</code> is `null`, and <code>length</code> is greater than zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)
  id: Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,Int32,String,Int32,Int32,Boolean,CultureInfo)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32,Boolean,CultureInfo)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32,Boolean,CultureInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares substrings of two specified <xref href="System.String"></xref> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.
  remarks: "The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`. Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one. The length of the first substring is equal to the length of `strA` minus `indexA` plus one. The length of the second substring is equal to the length of `strB` minus `indexB` plus one.  \n  \n The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  \n  \n The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  \n  \n The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  \n  \n One or both comparands can be `null`. By definition, any string, including the empty string (\"\"), compares greater than a null reference; and two null references compare equal to each other.  \n  \n The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  \n  \n Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter \"i\" in \"file\".  \n  \n [!code-cpp[System.String.Compare#6](~/add/codesnippet/cpp/1eeafd1b-4faf-4e9a-972f-_1.cpp)]\n [!code-cs[System.String.Compare#6](~/add/codesnippet/csharp/1eeafd1b-4faf-4e9a-972f-_1.cs)]\n [!code-vb[System.String.Compare#6](~/add/codesnippet/visualbasic/1eeafd1b-4faf-4e9a-972f-_1.vb)]  \n  \n Compare the path name to \"file\" using an ordinal comparison. The correct code to do this is as follows:  \n  \n [!code-cpp[System.String.Compare#7](~/add/codesnippet/cpp/1eeafd1b-4faf-4e9a-972f-_2.cpp)]\n [!code-cs[System.String.Compare#7](~/add/codesnippet/csharp/1eeafd1b-4faf-4e9a-972f-_2.cs)]\n [!code-vb[System.String.Compare#7](~/add/codesnippet/visualbasic/1eeafd1b-4faf-4e9a-972f-_2.vb)]"
  example:
  - "The following example compares two substrings using different cultures and ignoring the case of the substrings. The choice of culture affects how the letter \"I\" is compared.  \n  \n [!code-cs[string.compare5#1](~/add/codesnippet/csharp/1eeafd1b-4faf-4e9a-972f-_3.cs)]\n [!code-cpp[string.compare5#1](~/add/codesnippet/cpp/1eeafd1b-4faf-4e9a-972f-_3.cpp)]\n [!code-vb[string.compare5#1](~/add/codesnippet/visualbasic/1eeafd1b-4faf-4e9a-972f-_3.vb)]"
  syntax:
    content: public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);
    parameters:
    - id: strA
      type: System.String
      description: The first string to use in the comparison.
    - id: indexA
      type: System.Int32
      description: The position of the substring within `strA`.
    - id: strB
      type: System.String
      description: The second string to use in the comparison.
    - id: indexB
      type: System.Int32
      description: The position of the substring within `strB`.
    - id: length
      type: System.Int32
      description: The maximum number of characters in the substrings to compare.
    - id: ignoreCase
      type: System.Boolean
      description: '`true` to ignore case during the comparison; otherwise, `false`.'
    - id: culture
      type: System.Globalization.CultureInfo
      description: An object that supplies culture-specific comparison information.
    return:
      type: System.Int32
      description: "An integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|The substring in <code>strA</code> precedes the substring in <code>strB</code> in the sort order.|  \n|Zero|The substrings occur in the same position in the sort order, or <code>length</code> is zero.|  \n|Greater than zero|The substring in <code>strA</code> follows the substring in <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>indexA</code> is greater than <code>strA</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexB</code> is greater than <code>strB</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexA</code>, <code>indexB</code>, or <code>length</code> is negative.  \n  \n -or-  \n  \n Either <code>strA</code> or <code>strB</code> is `null`, and <code>length</code> is greater than zero."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>culture</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)
  id: Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)
  parent: System.String
  langs:
  - csharp
  name: Compare(String,Int32,String,Int32,Int32,CultureInfo,CompareOptions)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32,CultureInfo,CompareOptions)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32,CultureInfo,CompareOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares substrings of two specified <xref href="System.String"></xref> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.
  remarks: "The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`. The length of the first substring is the length of `strA` minus `indexA`. The length of the second substring is the length of `strB` minus `indexB`.  \n  \n The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  \n  \n The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters. For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.  \n  \n> [!CAUTION]\n>  The Compare method is designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero). To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.  \n  \n One or both of `strA` and `strB` can be `null`. By definition, any string, including <xref:System.String.Empty?displayProperty=fullName>, compares greater than a null reference, and two null references compare equal to each other.  \n  \n The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration. However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions?displayProperty=fullName> and <xref:System.Globalization.CompareOptions?displayProperty=fullName> values have no effect.  \n  \n The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater. The return value is the result of the last comparison performed."
  example:
  - "The following example uses the Compare method to compare the last names of two people. It then lists them in alphabetical order.  \n  \n [!code-cs[System.String.Compare5#1](~/add/codesnippet/csharp/f9ec89fd-0371-40d1-89b2-_1.cs)]\n [!code-vb[System.String.Compare5#1](~/add/codesnippet/visualbasic/f9ec89fd-0371-40d1-89b2-_1.vb)]"
  syntax:
    content: public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
    parameters:
    - id: strA
      type: System.String
      description: The first string to use in the comparison.
    - id: indexA
      type: System.Int32
      description: The starting position of the substring within `strA`.
    - id: strB
      type: System.String
      description: The second string to use in the comparison.
    - id: indexB
      type: System.Int32
      description: The starting position of the substring within `strB`.
    - id: length
      type: System.Int32
      description: The maximum number of characters in the substrings to compare.
    - id: culture
      type: System.Globalization.CultureInfo
      description: An object that supplies culture-specific comparison information.
    - id: options
      type: System.Globalization.CompareOptions
      description: Options to use when performing the comparison (such as ignoring case or symbols).
    return:
      type: System.Int32
      description: "An integer that indicates the lexical relationship between the two substrings, as shown in the following table.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|The substring in <code>strA</code> precedes the substring in <code>strB</code> in the sort order.|  \n|Zero|The substrings occur in the same position in the sort order, or <code>length</code> is zero.|  \n|Greater than zero|The substring in <code>strA</code> follows the substring in <code>strB</code> in the sort order.|"
  overload: System.String.Compare*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>options</code> is not a <xref href="System.Globalization.CompareOptions"></xref> value.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>indexA</code> is greater than <code>strA</code>`.Length`.  \n  \n -or-  \n  \n <code>indexB</code> is greater than <code>strB</code>`.Length`.  \n  \n -or-  \n  \n <code>indexA</code>, <code>indexB</code>, or <code>length</code> is negative.  \n  \n -or-  \n  \n Either <code>strA</code> or <code>strB</code> is `null`, and <code>length</code> is greater than zero."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>culture</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.CompareOrdinal(System.String,System.String)
  id: CompareOrdinal(System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: CompareOrdinal(String,String)
  nameWithType: String.CompareOrdinal(String,String)
  fullName: System.String.CompareOrdinal(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares two specified <xref href="System.String"></xref> objects by evaluating the numeric values of the corresponding <xref href="System.Char"></xref> objects in each string.
  remarks: "This method performs a case-sensitive comparison using ordinal sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>. To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison?displayProperty=fullName>.  \n  \n Because CompareOrdinalis a static method, `strA` and `strB` can be `null`. If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal. If only one of the values is `null`, the method considers the non-null value to be greater."
  example:
  - "The following example performs and ordinal comparison of two strings that only differ in case.  \n  \n [!code-cpp[string.compareordinal#1](~/add/codesnippet/cpp/m-system.string.compareo_1.cpp)]\n [!code-cs[string.compareordinal#1](~/add/codesnippet/csharp/m-system.string.compareo_1.cs)]\n [!code-vb[string.compareordinal#1](~/add/codesnippet/visualbasic/m-system.string.compareo_1.vb)]"
  syntax:
    content: public static int CompareOrdinal (string strA, string strB);
    parameters:
    - id: strA
      type: System.String
      description: The first string to compare.
    - id: strB
      type: System.String
      description: The second string to compare.
    return:
      type: System.Int32
      description: "An integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|<code>strA</code> is less than <code>strB</code>.|  \n|Zero|<code>strA</code> and <code>strB</code> are equal.|  \n|Greater than zero|<code>strA</code> is greater than <code>strB</code>.|"
  overload: System.String.CompareOrdinal*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)
  id: CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: CompareOrdinal(String,Int32,String,Int32,Int32)
  nameWithType: String.CompareOrdinal(String,Int32,String,Int32,Int32)
  fullName: System.String.CompareOrdinal(String,Int32,String,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares substrings of two specified <xref href="System.String"></xref> objects by evaluating the numeric values of the corresponding <xref href="System.Char"></xref> objects in each substring.
  remarks: "The `indexA`, `indexB`, and `length` parameters must be nonnegative.  \n  \n The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.  \n  \n This method performs a case-sensitive comparison using ordinal sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>. To perform a case-insensitive comparison using ordinal sort rules, call the<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>method with the `comparisonType` argument set to<xref:System.StringComparison?displayProperty=fullName>.  \n  \n Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`. If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal. If only one of the values is `null`, the method considers the non-null value to be greater."
  example:
  - "This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.  \n  \n [!code-cs[StringCompareOrdinal#1](~/add/codesnippet/csharp/37bd9916-be02-4e9b-a383-_1.cs)]\n [!code-vb[StringCompareOrdinal#1](~/add/codesnippet/visualbasic/37bd9916-be02-4e9b-a383-_1.vb)]\n [!code-cpp[StringCompareOrdinal#1](~/add/codesnippet/cpp/37bd9916-be02-4e9b-a383-_1.cpp)]"
  syntax:
    content: public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);
    parameters:
    - id: strA
      type: System.String
      description: The first string to use in the comparison.
    - id: indexA
      type: System.Int32
      description: The starting index of the substring in `strA`.
    - id: strB
      type: System.String
      description: The second string to use in the comparison.
    - id: indexB
      type: System.Int32
      description: The starting index of the substring in `strB`.
    - id: length
      type: System.Int32
      description: The maximum number of characters in the substrings to compare.
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates the lexical relationship between the two comparands.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|The substring in <code>strA</code> is less than the substring in <code>strB</code>.|  \n|Zero|The substrings are equal, or <code>length</code> is zero.|  \n|Greater than zero|The substring in <code>strA</code> is greater than the substring in <code>strB</code>.|"
  overload: System.String.CompareOrdinal*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>strA</code> is not `null` and <code>indexA</code> is greater than <code>strA</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>strB</code> is not `null` and<code>indexB</code> is greater than <code>strB</code>.<xref:System.String.Length*>.  \n  \n -or-  \n  \n <code>indexA</code>, <code>indexB</code>, or <code>length</code> is negative."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.CompareTo(System.Object)
  id: CompareTo(System.Object)
  parent: System.String
  langs:
  - csharp
  name: CompareTo(Object)
  nameWithType: String.CompareTo(Object)
  fullName: System.String.CompareTo(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares this instance with a specified <xref href="System.Object"></xref> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <xref href="System.Object"></xref>.
  remarks: "`value` must be a <xref:System.String> object.  \n  \n> [!CAUTION]\n>  The CompareTo method was designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent. To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.  \n  \n This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  \n  \n For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=fullName> method."
  example:
  - "The following example uses the CompareTo method with an <xref:System.Object>. Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.  \n  \n [!code-cpp[ExToString#1](~/add/codesnippet/cpp/m-system.string.comparet_0_1.cpp)]\n [!code-cs[ExToString#1](~/add/codesnippet/csharp/m-system.string.comparet_0_1.cs)]\n [!code-vb[ExToString#1](~/add/codesnippet/visualbasic/m-system.string.comparet_0_1.vb)]"
  syntax:
    content: public int CompareTo (object value);
    parameters:
    - id: value
      type: System.Object
      description: An object that evaluates to a <xref href="System.String"></xref>.
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <code>value</code> parameter.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|This instance precedes <code>value</code>.|  \n|Zero|This instance has the same position in the sort order as <code>value</code>.|  \n|Greater than zero|This instance follows <code>value</code>.<br /><br /> -or-<br /><br /><code>value</code> is `null`.|"
  overload: System.String.CompareTo*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>value</code> is not a <xref href="System.String"></xref>.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.CompareTo(System.String)
  id: CompareTo(System.String)
  parent: System.String
  langs:
  - csharp
  name: CompareTo(String)
  nameWithType: String.CompareTo(String)
  fullName: System.String.CompareTo(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Compares this instance with a specified <xref href="System.String"></xref> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.
  remarks: "This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  \n  \n> [!CAUTION]\n>  The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent. To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.  \n  \n For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.  \n  \n This method implements the <xref:System.IComparable%601?displayProperty=fullName> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=fullName> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object>to a<xref:System.String>."
  example:
  - "The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.  \n  \n [!code-cpp[stringcompareto#1](~/add/codesnippet/cpp/m-system.string.comparet_1_1.cpp)]\n [!code-cs[stringcompareto#1](~/add/codesnippet/csharp/m-system.string.comparet_1_1.cs)]\n [!code-vb[stringcompareto#1](~/add/codesnippet/visualbasic/m-system.string.comparet_1_1.vb)]  \n  \n The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.  \n  \n [!code-vb[T.CompareTo#1](~/add/codesnippet/visualbasic/m-system.string.comparet_1_2.vb)]\n [!code-cpp[T.CompareTo#1](~/add/codesnippet/cpp/m-system.string.comparet_1_2.cpp)]\n [!code-cs[T.CompareTo#1](~/add/codesnippet/csharp/m-system.string.comparet_1_2.cs)]"
  syntax:
    content: public int CompareTo (string strB);
    parameters:
    - id: strB
      type: System.String
      description: The string to compare with this instance.
    return:
      type: System.Int32
      description: "A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <code>strB</code> parameter.  \n  \n|Value|Condition|  \n|-----------|---------------|  \n|Less than zero|This instance precedes <code>strB</code>.|  \n|Zero|This instance has the same position in the sort order as <code>strB</code>.|  \n|Greater than zero|This instance follows <code>strB</code>.<br /><br /> -or-<br /><br /><code>strB</code> is `null`.|"
  overload: System.String.CompareTo*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.Collections.Generic.IEnumerable{System.String})
  id: Concat(System.Collections.Generic.IEnumerable{System.String})
  parent: System.String
  langs:
  - csharp
  name: Concat(IEnumerable<String>)
  nameWithType: String.Concat(IEnumerable<String>)
  fullName: System.String.Concat(IEnumerable<String>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the members of a constructed <xref:System.Collections.Generic.IEnumerable`1> collection of type <xref href="System.String"></xref>.
  remarks: "The method concatenates each object in `values`; it does not add any delimiters. To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.  \n  \n An <xref:System.String.Empty> string is used in place of any null element in `values`.  \n  \n If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=fullName>. If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.  \n  \n Concat is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array. It is particularly useful with Language-Integrated Query (LINQ) query expressions. The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is \"M\"). The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName> method is passed to the Concat method to display the result as a single string.  \n  \n [!code-cs[System.String.Concat#3](~/add/codesnippet/csharp/m-system.string.concat-s_7_1.cs)]\n [!code-vb[System.String.Concat#3](~/add/codesnippet/visualbasic/m-system.string.concat-s_7_1.vb)]"
  example:
  - "The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the Concat method.  \n  \n [!code-cs[System.String.Concat#2](~/add/codesnippet/csharp/m-system.string.concat-s_7_2.cs)]\n [!code-vb[System.String.Concat#2](~/add/codesnippet/visualbasic/m-system.string.concat-s_7_2.vb)]"
  syntax:
    content: public static string Concat (System.Collections.Generic.IEnumerable<string> values);
    parameters:
    - id: values
      type: System.Collections.Generic.IEnumerable{System.String}
      description: A collection object that implements <xref:System.Collections.Generic.IEnumerable`1> and whose generic type argument is <xref href="System.String"></xref>.
    return:
      type: System.String
      description: The concatenated strings in <code>values</code>, or <xref href="System.String"></xref> if <code>values</code> is an empty `IEnumerable(Of String)`.
  overload: System.String.Concat*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>values</code> is `null`.
  version:
  - netframework-40
- uid: System.String.Concat(System.Object)
  id: Concat(System.Object)
  parent: System.String
  langs:
  - csharp
  name: Concat(Object)
  nameWithType: String.Concat(Object)
  fullName: System.String.Concat(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Creates the string  representation of a specified object.
  remarks: The Concat method represents `arg0` as a string by calling its parameterless `ToString` method.
  example:
  - "The following example demonstrates the Concat method.  \n  \n [!code-cs[string.concat5#1](~/add/codesnippet/csharp/m-system.string.concat-s_9_1.cs)]\n [!code-vb[string.concat5#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_9_1.vb)]\n [!code-cpp[string.concat5#1](~/add/codesnippet/cpp/m-system.string.concat-s_9_1.cpp)]"
  syntax:
    content: public static string Concat (object arg0);
    parameters:
    - id: arg0
      type: System.Object
      description: The object to represent, or `null`.
    return:
      type: System.String
      description: The string representation of the value of <code>arg0</code>, or <xref href="System.String"></xref> if <code>arg0</code> is `null`.
  overload: System.String.Concat*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.Object[])
  id: Concat(System.Object[])
  parent: System.String
  langs:
  - csharp
  name: Concat(Object[])
  nameWithType: String.Concat(Object[])
  fullName: System.String.Concat(Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the string representations of the elements in a specified <xref href="System.Object"></xref> array.
  remarks: "The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.  \n  \n <xref:System.String?displayProperty=fullName> is used in place of any null object in the array."
  example:
  - "The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.  \n  \n [!code-cs[stringconcat1#1](~/add/codesnippet/csharp/m-system.string.concat-s_6_1.cs)]\n [!code-vb[stringconcat1#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_6_1.vb)]"
  syntax:
    content: public static string Concat (object[] args);
    parameters:
    - id: args
      type: System.Object[]
      description: An object array that contains the elements to concatenate.
    return:
      type: System.String
      description: The concatenated string representations of the values of the elements in <code>args</code>.
  overload: System.String.Concat*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>args</code> is `null`.
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: Out of memory.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.String[])
  id: Concat(System.String[])
  parent: System.String
  langs:
  - csharp
  name: Concat(String[])
  nameWithType: String.Concat(String[])
  fullName: System.String.Concat(String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the elements of a specified <xref href="System.String"></xref> array.
  remarks: "The method concatenates each object in `values`; it does not add any delimiters.  \n  \n An <xref:System.String> string is used in place of any null object in the array."
  example:
  - "The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.  \n  \n [!code-vb[stringconcat3#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_5_1.vb)]\n [!code-cs[stringconcat3#1](~/add/codesnippet/csharp/m-system.string.concat-s_5_1.cs)]\n [!code-cpp[stringconcat3#1](~/add/codesnippet/cpp/m-system.string.concat-s_5_1.cpp)]"
  syntax:
    content: public static string Concat (string[] values);
    parameters:
    - id: values
      type: System.String[]
      description: An array of string instances.
    return:
      type: System.String
      description: The concatenated elements of <code>values</code>.
  overload: System.String.Concat*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>values</code> is `null`.
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: Out of memory.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.Object,System.Object)
  id: Concat(System.Object,System.Object)
  parent: System.String
  langs:
  - csharp
  name: Concat(Object,Object)
  nameWithType: String.Concat(Object,Object)
  fullName: System.String.Concat(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the string representations of two specified objects.
  remarks: "The method concatenates `arg0` and `arg1`by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.  \n  \n <xref:System.String?displayProperty=fullName> is used in place of any null argument.  \n  \n If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, \"System.String[]\")."
  example:
  - "The following example demonstrates the <xref:System.String.Concat%2A> method.  \n  \n [!code-cs[string.concat5#1](~/add/codesnippet/csharp/m-system.string.concat-s_2_1.cs)]\n [!code-vb[string.concat5#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_2_1.vb)]\n [!code-cpp[string.concat5#1](~/add/codesnippet/cpp/m-system.string.concat-s_2_1.cpp)]"
  syntax:
    content: public static string Concat (object arg0, object arg1);
    parameters:
    - id: arg0
      type: System.Object
      description: The first object to concatenate.
    - id: arg1
      type: System.Object
      description: The second object to concatenate.
    return:
      type: System.String
      description: The concatenated string representations of the values of <code>arg0</code> and <code>arg1</code>.
  overload: System.String.Concat*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.String,System.String)
  id: Concat(System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: Concat(String,String)
  nameWithType: String.Concat(String,String)
  fullName: System.String.Concat(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates two specified instances of <xref href="System.String"></xref>.
  remarks: "The method concatenates `str0` and `str1`; it does not add any delimiters.  \n  \n> [!NOTE]\n>  You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)  \n>   \n>  , to concatenate strings.  \n  \n An <xref:System.String> string is used in place of any null argument."
  example:
  - "The following example concatenates a person's first, middle, and last name.  \n  \n [!code-cpp[stringconcat4#1](~/add/codesnippet/cpp/m-system.string.concat-s_8_1.cpp)]\n [!code-cs[stringconcat4#1](~/add/codesnippet/csharp/m-system.string.concat-s_8_1.cs)]\n [!code-vb[stringconcat4#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_8_1.vb)]"
  syntax:
    content: public static string Concat (string str0, string str1);
    parameters:
    - id: str0
      type: System.String
      description: The first string to concatenate.
    - id: str1
      type: System.String
      description: The second string to concatenate.
    return:
      type: System.String
      description: The concatenation of <code>str0</code> and <code>str1</code>.
  overload: System.String.Concat*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.Object,System.Object,System.Object)
  id: Concat(System.Object,System.Object,System.Object)
  parent: System.String
  langs:
  - csharp
  name: Concat(Object,Object,Object)
  nameWithType: String.Concat(Object,Object,Object)
  fullName: System.String.Concat(Object,Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the string representations of three specified objects.
  remarks: "The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.  \n  \n <xref:System.String?displayProperty=fullName> is used in place of any null argument."
  example:
  - "The following example demonstrates the <xref:System.String.Concat%2A> method.  \n  \n [!code-cs[string.concat5#1](~/add/codesnippet/csharp/m-system.string.concat-s_1_1.cs)]\n [!code-vb[string.concat5#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_1_1.vb)]\n [!code-cpp[string.concat5#1](~/add/codesnippet/cpp/m-system.string.concat-s_1_1.cpp)]"
  syntax:
    content: public static string Concat (object arg0, object arg1, object arg2);
    parameters:
    - id: arg0
      type: System.Object
      description: The first object to concatenate.
    - id: arg1
      type: System.Object
      description: The second object to concatenate.
    - id: arg2
      type: System.Object
      description: The third object to concatenate.
    return:
      type: System.String
      description: The concatenated string representations of the values of <code>arg0</code>, <code>arg1</code>, and <code>arg2</code>.
  overload: System.String.Concat*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.String,System.String,System.String)
  id: Concat(System.String,System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: Concat(String,String,String)
  nameWithType: String.Concat(String,String,String)
  fullName: System.String.Concat(String,String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates three specified instances of <xref href="System.String"></xref>.
  remarks: "The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.  \n  \n> [!NOTE]\n>  You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)  \n>   \n>  , to concatenate strings.  \n  \n An <xref:System.String> string is used in place of any null argument."
  example:
  - "The following example uses the Concat method to concatenate three strings and displays the result.  \n  \n [!code-cs[System.String.Concat#6](~/add/codesnippet/csharp/m-system.string.concat-s_3_1.cs)]\n [!code-cpp[System.String.Concat#6](~/add/codesnippet/cpp/m-system.string.concat-s_3_1.cpp)]\n [!code-vb[System.String.Concat#6](~/add/codesnippet/visualbasic/m-system.string.concat-s_3_1.vb)]"
  syntax:
    content: public static string Concat (string str0, string str1, string str2);
    parameters:
    - id: str0
      type: System.String
      description: The first string to concatenate.
    - id: str1
      type: System.String
      description: The second string to concatenate.
    - id: str2
      type: System.String
      description: The third string to concatenate.
    return:
      type: System.String
      description: The concatenation of <code>str0</code>, <code>str1</code>, and <code>str2</code>.
  overload: System.String.Concat*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.Object,System.Object,System.Object,System.Object)
  id: Concat(System.Object,System.Object,System.Object,System.Object)
  parent: System.String
  langs:
  - csharp
  name: Concat(Object,Object,Object,Object)
  nameWithType: String.Concat(Object,Object,Object,Object)
  fullName: System.String.Concat(Object,Object,Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.
  remarks: "> [!NOTE]\n>  This API is not CLS-compliant. The CLS-compliant alternative is [String.Concat(Object\\[\\])](assetId:///M:System.String.Concat(System.Object[])?qualifyHint=True&autoUpgrade=False). The C# and Visual Basic compilers automatically resolve a call to this method as a call to [String.Concat(Object\\[\\])](assetId:///M:System.String.Concat(System.Object[])?qualifyHint=True&autoUpgrade=False).  \n  \n The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.  \n  \n <xref:System.String.Empty?displayProperty=fullName> is used in place of any null argument.  \n  \n> [!NOTE]\n>  The last parameter of the  Concat method is an optional comma-delimited list of one or more additional objects to concatenate."
  example:
  - "The following example illustrates the use of the Concat method to concatenate a list of variable parameters. In this case, the method is called with nine parameters.  \n  \n [!code-cs[System.String.Concat#1](~/add/codesnippet/csharp/m-system.string.concat-s_0_1.cs)]\n [!code-vb[System.String.Concat#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_0_1.vb)]"
  syntax:
    content: public static string Concat (object arg0, object arg1, object arg2, object arg3);
    parameters:
    - id: arg0
      type: System.Object
      description: The first object to concatenate.
    - id: arg1
      type: System.Object
      description: The second object to concatenate.
    - id: arg2
      type: System.Object
      description: The third object to concatenate.
    - id: arg3
      type: System.Object
      description: The fourth object to concatenate.
    return:
      type: System.String
      description: The concatenated string representation of each value in the parameter list.
  overload: System.String.Concat*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat(System.String,System.String,System.String,System.String)
  id: Concat(System.String,System.String,System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: Concat(String,String,String,String)
  nameWithType: String.Concat(String,String,String,String)
  fullName: System.String.Concat(String,String,String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates four specified instances of <xref href="System.String"></xref>.
  remarks: "The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.  \n  \n> [!NOTE]\n>  You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)  \n>   \n>  , to concatenate strings.  \n  \n An <xref:System.String> string is used in place of any null object in the array."
  example:
  - "The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them. It then calls the Concat method to reassemble the scrambled words.  \n  \n [!code-cs[System.String.Concat#1](~/add/codesnippet/csharp/m-system.string.concat-s_4_1.cs)]\n [!code-vb[System.String.Concat#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_4_1.vb)]"
  syntax:
    content: public static string Concat (string str0, string str1, string str2, string str3);
    parameters:
    - id: str0
      type: System.String
      description: The first string to concatenate.
    - id: str1
      type: System.String
      description: The second string to concatenate.
    - id: str2
      type: System.String
      description: The third string to concatenate.
    - id: str3
      type: System.String
      description: The fourth string to concatenate.
    return:
      type: System.String
      description: The concatenation of <code>str0</code>, <code>str1</code>, <code>str2</code>, and <code>str3</code>.
  overload: System.String.Concat*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Concat``1(System.Collections.Generic.IEnumerable`1)
  id: Concat``1(System.Collections.Generic.IEnumerable`1)
  parent: System.String
  langs:
  - csharp
  name: Concat(IEnumerable<T>)
  nameWithType: String.Concat(IEnumerable<T>)
  fullName: System.String.Concat(IEnumerable<T>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  syntax:
    content: public static string Concat<T> (System.Collections.Generic.IEnumerable<T> values);
    parameters:
    - id: values
      type: System.Collections.Generic.IEnumerable`1
      description: To be added.
    return:
      type: System.String
      description: To be added.
  overload: System.String.Concat<T>*
  exceptions: []
  version:
  - netframework-40
- uid: System.String.Contains(System.String)
  id: Contains(System.String)
  parent: System.String
  langs:
  - csharp
  name: Contains(String)
  nameWithType: String.Contains(String)
  fullName: System.String.Contains(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a value indicating whether a specified substring occurs within this string.
  remarks: "This method performs an ordinal (case-sensitive and culture-insensitive) comparison. The search begins at the first character position of this string and continues through the last character position.  \n  \n To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method. The following example illustrates one such approach. It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.  \n  \n [!code-cs[System.String.Contains#1](~/add/codesnippet/csharp/m-system.string.contains_1.cs)]\n [!code-vb[System.String.Contains#1](~/add/codesnippet/visualbasic/m-system.string.contains_1.vb)]  \n  \n The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.  \n  \n [!code-cs[System.String.Contains#2](~/add/codesnippet/csharp/m-system.string.contains_2.cs)]\n [!code-vb[System.String.Contains#2](~/add/codesnippet/visualbasic/m-system.string.contains_2.vb)]  \n  \n If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence. The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance."
  example:
  - "The following example determines whether the string \"fox\" is a substring of a familiar quotation. If \"fox\" is found in the string, it also displays its starting position.  \n  \n [!code-vb[String.Contains#1](~/add/codesnippet/visualbasic/m-system.string.contains_3.vb)]\n [!code-cs[String.Contains#1](~/add/codesnippet/csharp/m-system.string.contains_3.cs)]\n [!code-cpp[String.Contains#1](~/add/codesnippet/cpp/m-system.string.contains_3.cpp)]"
  syntax:
    content: public bool Contains (string value);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    return:
      type: System.Boolean
      description: '`true` if the <code>value</code> parameter occurs within this string, or if <code>value</code> is the empty string (""); otherwise, `false`.'
  overload: System.String.Contains*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Copy(System.String)
  id: Copy(System.String)
  parent: System.String
  langs:
  - csharp
  name: Copy(String)
  nameWithType: String.Copy(String)
  fullName: System.String.Copy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Creates a new instance of <xref href="System.String"></xref> with the same value as a specified <xref href="System.String"></xref>.
  remarks: TheCopy method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference. It differs from an assignment operation, which assigns an existing string reference to an additional object variable. The example illustrates the difference.
  example:
  - "The following example creates two string objects with different values. When it calls the Copy method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal. On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.  \n  \n [!code-vb[System.String.Copy#1](~/add/codesnippet/visualbasic/m-system.string.copy-sys_1.vb)]\n [!code-cs[System.String.Copy#1](~/add/codesnippet/csharp/m-system.string.copy-sys_1.cs)]"
  syntax:
    content: public static string Copy (string str);
    parameters:
    - id: str
      type: System.String
      description: The string to copy.
    return:
      type: System.String
      description: A new string with the same value as <code>str</code>.
  overload: System.String.Copy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>str</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)
  id: CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: CopyTo(Int32,Char[],Int32,Int32)
  nameWithType: String.CopyTo(Int32,Char[],Int32,Int32)
  fullName: System.String.CopyTo(Int32,Char[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.
  remarks: "This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array. This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.  \n  \n `sourceIndex` and `destinationIndex` are zero-based."
  example:
  - "The following example demonstrates the CopyTo method.  \n  \n [!code-cpp[stringcopyto#1](~/add/codesnippet/cpp/m-system.string.copyto-s_1.cpp)]\n [!code-cs[stringcopyto#1](~/add/codesnippet/csharp/m-system.string.copyto-s_1.cs)]\n [!code-vb[stringcopyto#1](~/add/codesnippet/visualbasic/m-system.string.copyto-s_1.vb)]"
  syntax:
    content: public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);
    parameters:
    - id: sourceIndex
      type: System.Int32
      description: The index of the first character in this instance to copy.
    - id: destination
      type: System.Char[]
      description: An array of Unicode characters to which characters in this instance are copied.
    - id: destinationIndex
      type: System.Int32
      description: The index in `destination` at which the copy operation begins.
    - id: count
      type: System.Int32
      description: The number of characters in this instance to copy to `destination`.
  overload: System.String.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>destination</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sourceIndex</code>, <code>destinationIndex</code>, or <code>count</code> is negative  \n  \n -or-  \n  \n <code>sourceIndex</code> does not identify a position in the current instance.  \n  \n -or-  \n  \n <code>destinationIndex</code> does not identify a valid index in the <code>destination</code> array.  \n  \n -or-  \n  \n <code>count</code> is greater than the length of the substring from <code>startIndex</code> to the end of this instance  \n  \n -or-  \n  \n <code>count</code> is greater than the length of the subarray from <code>destinationIndex</code> to the end of the <code>destination</code> array."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Empty
  id: Empty
  parent: System.String
  langs:
  - csharp
  name: Empty
  nameWithType: String.Empty
  fullName: System.String.Empty
  type: Field
  assemblies:
  - mscorlib
  namespace: System
  summary: Represents the empty string. This field is read-only.
  remarks: "The value of this field is the zero-length string, \"\".  \n  \n In application code, this field is most commonly used in assignments to initialize a string variable to an empty string. To test whether the value of a string is either `null` or Empty, use the <xref:System.String.IsNullOrEmpty%2A> method."
  syntax:
    content: public static readonly string Empty;
    return:
      type: System.String
      description: To be added.
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.EndsWith(System.String)
  id: EndsWith(System.String)
  parent: System.String
  langs:
  - csharp
  name: EndsWith(String)
  nameWithType: String.EndsWith(String)
  fullName: System.String.EndsWith(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether the end of this string instance matches the specified string.
  remarks: "This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal. To be equal, `value` must be a reference to this same instance or match the end of this instance.  \n  \n This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture."
  example:
  - "The following example indicates whether each string in an array ends with a period (\".\").  \n  \n [!code-vb[System.String.EndsWith#1](~/add/codesnippet/visualbasic/m-system.string.endswith_0_1.vb)]\n [!code-cs[System.String.EndsWith#1](~/add/codesnippet/csharp/m-system.string.endswith_0_1.cs)]  \n  \n The following example defines a `StripEndTags` method that uses the EndsWith method to remove HTML end tags from the end of a line. Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.  \n  \n [!code-vb[stringendswith#1](~/add/codesnippet/visualbasic/m-system.string.endswith_0_2.vb)]\n [!code-cpp[stringendswith#1](~/add/codesnippet/cpp/m-system.string.endswith_0_2.cpp)]\n [!code-cs[stringendswith#1](~/add/codesnippet/csharp/m-system.string.endswith_0_2.cs)]"
  syntax:
    content: public bool EndsWith (string value);
    parameters:
    - id: value
      type: System.String
      description: The string to compare to the substring at the end of this instance.
    return:
      type: System.Boolean
      description: '`true` if <code>value</code> matches the end of this instance; otherwise, `false`.'
  overload: System.String.EndsWith*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.EndsWith(System.String,System.StringComparison)
  id: EndsWith(System.String,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: EndsWith(String,StringComparison)
  nameWithType: String.EndsWith(String,StringComparison)
  fullName: System.String.EndsWith(String,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.
  remarks: The EndsWith method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal. To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string. The type of comparison performed by the EndsWith method depends on the value of the `comparisonType`parameter.
  example:
  - "The following example determines whether a string ends with a particular substring. The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.  \n  \n [!code-cpp[System.String.EndsWithCmp#1](~/add/codesnippet/cpp/m-system.string.endswith_1_1.cpp)]\n [!code-vb[System.String.EndsWithCmp#1](~/add/codesnippet/visualbasic/m-system.string.endswith_1_1.vb)]\n [!code-cs[System.String.EndsWithCmp#1](~/add/codesnippet/csharp/m-system.string.endswith_1_1.cs)]"
  syntax:
    content: public bool EndsWith (string value, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to compare to the substring at the end of this instance.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that determines how this string and `value` are compared.
    return:
      type: System.Boolean
      description: '`true` if the <code>value</code> parameter matches the end of this string; otherwise, `false`.'
  overload: System.String.EndsWith*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)
  id: EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)
  parent: System.String
  langs:
  - csharp
  name: EndsWith(String,Boolean,CultureInfo)
  nameWithType: String.EndsWith(String,Boolean,CultureInfo)
  fullName: System.String.EndsWith(String,Boolean,CultureInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether the end of this string instance matches the specified string when compared using the specified culture.
  remarks: "This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal. To be equal, `value` must be a reference to this same instance or match the end of this string.  \n  \n This method performs a word (culture-sensitive) comparison using the specified casing and culture."
  example:
  - "The following example determines whether a string occurs at the end of another string. The EndsWith method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.  \n  \n [!code-cs[system.string.EndsWithCI#1](~/add/codesnippet/csharp/5ef3fc0c-83c9-48eb-8138-_1.cs)]\n [!code-vb[system.string.EndsWithCI#1](~/add/codesnippet/visualbasic/5ef3fc0c-83c9-48eb-8138-_1.vb)]"
  syntax:
    content: public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);
    parameters:
    - id: value
      type: System.String
      description: The string to compare to the substring at the end of this instance.
    - id: ignoreCase
      type: System.Boolean
      description: '`true` to ignore case during the comparison; otherwise, `false`.'
    - id: culture
      type: System.Globalization.CultureInfo
      description: Cultural information that determines how this instance and `value` are compared. If `culture` is `null`, the current culture is used.
    return:
      type: System.Boolean
      description: '`true` if the <code>value</code> parameter matches the end of this string; otherwise, `false`.'
  overload: System.String.EndsWith*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.String
  langs:
  - csharp
  name: Equals(Object)
  nameWithType: String.Equals(Object)
  fullName: System.String.Equals(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether this instance and a specified object, which must also be a <xref href="System.String"></xref> object, have the same value.
  remarks: This method performs an ordinal (case-sensitive and culture-insensitive) comparison.
  example:
  - "The following example demonstrates the Equals method.  \n  \n [!code-cpp[string.equals#1](~/add/codesnippet/cpp/m-system.string.equals-s_1_1.cpp)]\n [!code-cs[string.equals#1](~/add/codesnippet/csharp/m-system.string.equals-s_1_1.cs)]\n [!code-vb[string.equals#1](~/add/codesnippet/visualbasic/m-system.string.equals-s_1_1.vb)]"
  syntax:
    content: public override bool Equals (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: The string to compare to this instance.
    return:
      type: System.Boolean
      description: '`true` if <code>obj</code> is a <xref href="System.String"></xref> and its value is the same as this instance; otherwise, `false`.  If <code>obj</code> is `null`, the method returns `false`.'
  overload: System.String.Equals*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Equals(System.String)
  id: Equals(System.String)
  parent: System.String
  langs:
  - csharp
  name: Equals(String)
  nameWithType: String.Equals(String)
  fullName: System.String.Equals(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether this instance and another specified <xref href="System.String"></xref> object have the same value.
  remarks: This method performs an ordinal (case-sensitive and culture-insensitive) comparison.
  example:
  - "The following example demonstrates the <xref:System.String.Equals%2A> method.It compares the title-cased word \"File\" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069). Because the Equals method performs an ordinal comparison, only the comparison with an identical word returns `true`.  \n  \n [!code-vb[System.String.Equals#2](~/add/codesnippet/visualbasic/m-system.string.equals-s_3_1.vb)]\n [!code-cs[System.String.Equals#2](~/add/codesnippet/csharp/m-system.string.equals-s_3_1.cs)]"
  syntax:
    content: public bool Equals (string value);
    parameters:
    - id: value
      type: System.String
      description: The string to compare to this instance.
    return:
      type: System.Boolean
      description: '`true` if the value of the <code>value</code> parameter is the same as the value of this instance; otherwise, `false`. If <code>value</code> is `null`, the method returns `false`.'
  overload: System.String.Equals*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Equals(System.String,System.String)
  id: Equals(System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: Equals(String,String)
  nameWithType: String.Equals(String,String)
  fullName: System.String.Equals(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether two specified <xref href="System.String"></xref> objects have the same value.
  remarks: This method performs an ordinal (case-sensitive and culture-insensitive) comparison.
  example:
  - "The following example demonstrates the <xref:System.String.Equals%2A> method.  \n  \n [!code-cpp[string.equals#1](~/add/codesnippet/cpp/m-system.string.equals-s_4_1.cpp)]\n [!code-cs[string.equals#1](~/add/codesnippet/csharp/m-system.string.equals-s_4_1.cs)]\n [!code-vb[string.equals#1](~/add/codesnippet/visualbasic/m-system.string.equals-s_4_1.vb)]"
  syntax:
    content: public static bool Equals (string a, string b);
    parameters:
    - id: a
      type: System.String
      description: The first string to compare, or `null`.
    - id: b
      type: System.String
      description: The second string to compare, or `null`.
    return:
      type: System.Boolean
      description: '`true` if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, `false`. If both <code>a</code> and <code>b</code> are `null`, the method returns `true`.'
  overload: System.String.Equals*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Equals(System.String,System.StringComparison)
  id: Equals(System.String,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: Equals(String,StringComparison)
  nameWithType: String.Equals(String,StringComparison)
  fullName: System.String.Equals(String,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether this string and a specified <xref href="System.String"></xref> object have the same value. A parameter specifies the culture, case, and sort rules used in the comparison.
  remarks: The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.
  example:
  - "The following example creates a string array that consists of an uppercase \"I\", a lowercase \"i\", and a dotless \"ı\". It then calls the Equals method to compare them by using each possible <xref:System.StringComparison> enumeration value.  \n  \n [!code-cs[System.String.Equals#1](~/add/codesnippet/csharp/m-system.string.equals-s_2_1.cs)]\n [!code-vb[System.String.Equals#1](~/add/codesnippet/visualbasic/m-system.string.equals-s_2_1.vb)]  \n  \n The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.  The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures. Note that the strings \"encyclopædia\" and \"encyclopedia\" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.  \n  \n [!code-cs[System.String.Equals#4](~/add/codesnippet/csharp/m-system.string.equals-s_2_2.cs)]\n [!code-vb[System.String.Equals#4](~/add/codesnippet/visualbasic/m-system.string.equals-s_2_2.vb)]"
  syntax:
    content: public bool Equals (string value, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to compare to this instance.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies how the strings will be compared.
    return:
      type: System.Boolean
      description: '`true` if the value of the <code>value</code> parameter is the same as this string; otherwise, `false`.'
  overload: System.String.Equals*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Equals(System.String,System.String,System.StringComparison)
  id: Equals(System.String,System.String,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: Equals(String,String,StringComparison)
  nameWithType: String.Equals(String,String,StringComparison)
  fullName: System.String.Equals(String,String,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether two specified <xref href="System.String"></xref> objects have the same value. A parameter specifies the culture, case, and sort rules used in the comparison.
  remarks: The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.
  example:
  - "The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.  The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures. Note that the strings \"encyclopædia\" and \"encyclopedia\" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.  \n  \n [!code-vb[System.String.Equals#3](~/add/codesnippet/visualbasic/m-system.string.equals-s_0_1.vb)]\n [!code-cs[System.String.Equals#3](~/add/codesnippet/csharp/m-system.string.equals-s_0_1.cs)]"
  syntax:
    content: public static bool Equals (string a, string b, StringComparison comparisonType);
    parameters:
    - id: a
      type: System.String
      description: The first string to compare, or `null`.
    - id: b
      type: System.String
      description: The second string to compare, or `null`.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules for the comparison.
    return:
      type: System.Boolean
      description: '`true` if the value of the <code>a</code> parameter is equal to the value of the <code>b</code> parameter; otherwise, `false`.'
  overload: System.String.Equals*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Format(System.String,System.Object)
  id: Format(System.String,System.Object)
  parent: System.String
  langs:
  - csharp
  name: Format(String,Object)
  nameWithType: String.Format(String,Object)
  fullName: System.String.Format(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Replaces one or more format items in a specified string with the string representation of a specified object.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.
  syntax:
    content: public static string Format (string format, object arg0);
    parameters:
    - id: format
      type: System.String
      description: A [composite format string](~/add/includes/ajax-current-ext-md.md).
    - id: arg0
      type: System.Object
      description: The object to format.
    return:
      type: System.String
      description: A copy of <code>format</code> in which any format items are replaced by the string representation of <code>arg0</code>.
  overload: System.String.Format*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>format</code> is `null`.
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "The format item in <code>format</code> is invalid.  \n  \n -or-  \n  \n The index of a format item is not zero."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Format(System.String,System.Object[])
  id: Format(System.String,System.Object[])
  parent: System.String
  langs:
  - csharp
  name: Format(String,Object[])
  nameWithType: String.Format(String,Object[])
  fullName: System.String.Format(String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.
  syntax:
    content: public static string Format (string format, object[] args);
    parameters:
    - id: format
      type: System.String
      description: A [composite format string](~/add/includes/ajax-current-ext-md.md).
    - id: args
      type: System.Object[]
      description: An object array that contains zero or more objects to format.
    return:
      type: System.String
      description: A copy of <code>format</code> in which the format items have been replaced by the string representation of the corresponding objects in <code>args</code>.
  overload: System.String.Format*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>format</code> or <code>args</code> is `null`.
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "<code>format</code> is invalid.  \n  \n -or-  \n  \n The index of a format item is less than zero, or greater than or equal to the length of the <code>args</code> array."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Format(System.IFormatProvider,System.String,System.Object[])
  id: Format(System.IFormatProvider,System.String,System.Object[])
  parent: System.String
  langs:
  - csharp
  name: Format(IFormatProvider,String,Object[])
  nameWithType: String.Format(IFormatProvider,String,Object[])
  fullName: System.String.Format(IFormatProvider,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Replaces the format items in a specified string with the string representations of corresponding objects in a specified array. A parameter supplies culture-specific formatting information.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.
  syntax:
    content: public static string Format (IFormatProvider provider, string format, object[] args);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that supplies culture-specific formatting information.
    - id: format
      type: System.String
      description: A [composite format string](~/add/includes/ajax-current-ext-md.md).
    - id: args
      type: System.Object[]
      description: An object array that contains zero or more objects to format.
    return:
      type: System.String
      description: A copy of <code>format</code> in which the format items have been replaced by the string representation of the corresponding objects in <code>args</code>.
  overload: System.String.Format*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>format</code> or <code>args</code> is `null`.
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "<code>format</code> is invalid.  \n  \n -or-  \n  \n The index of a format item is less than zero, or greater than or equal to the length of the <code>args</code> array."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Format(System.String,System.Object,System.Object)
  id: Format(System.String,System.Object,System.Object)
  parent: System.String
  langs:
  - csharp
  name: Format(String,Object,Object)
  nameWithType: String.Format(String,Object,Object)
  fullName: System.String.Format(String,Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Replaces the format items in a specified string with the string representation of two specified objects.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.
  syntax:
    content: public static string Format (string format, object arg0, object arg1);
    parameters:
    - id: format
      type: System.String
      description: A [composite format string](~/add/includes/ajax-current-ext-md.md).
    - id: arg0
      type: System.Object
      description: The first object to format.
    - id: arg1
      type: System.Object
      description: The second object to format.
    return:
      type: System.String
      description: A copy of <code>format</code> in which format items are replaced by the string representations of <code>arg0</code> and <code>arg1</code>.
  overload: System.String.Format*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>format</code> is `null`.
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "<code>format</code> is invalid.  \n  \n -or-  \n  \n The index of a format item is not zero or one."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Format(System.String,System.Object,System.Object,System.Object)
  id: Format(System.String,System.Object,System.Object,System.Object)
  parent: System.String
  langs:
  - csharp
  name: Format(String,Object,Object,Object)
  nameWithType: String.Format(String,Object,Object,Object)
  fullName: System.String.Format(String,Object,Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Replaces the format items in a specified string with the string representation of three specified objects.
  remarks: >-
    > [!NOTE]

    >  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.
  syntax:
    content: public static string Format (string format, object arg0, object arg1, object arg2);
    parameters:
    - id: format
      type: System.String
      description: A [composite format string](~/add/includes/ajax-current-ext-md.md).
    - id: arg0
      type: System.Object
      description: The first object to format.
    - id: arg1
      type: System.Object
      description: The second object to format.
    - id: arg2
      type: System.Object
      description: The third object to format.
    return:
      type: System.String
      description: A copy of <code>format</code> in which the format items have been replaced by the string representations of <code>arg0</code>, <code>arg1</code>, and <code>arg2</code>.
  overload: System.String.Format*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>format</code> is `null`.
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "<code>format</code> is invalid.  \n  \n -or-  \n  \n The index of a format item is less than zero, or greater than two."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.GetEnumerator
  id: GetEnumerator
  parent: System.String
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: String.GetEnumerator()
  fullName: System.String.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Retrieves an object that can iterate through the individual characters in this string.
  remarks: "> [!TIP]\n>  Rather than calling the GetEnumerator method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).                  [foreach](~/add/includes/ajax-current-ext-md.md) in C#,                  [for each](~/add/includes/ajax-current-ext-md.md) in C++/CLR, and                  [For Each](~/add/includes/ajax-current-ext-md.md) in Visual Basic).  \n  \n This method enables you to iterate the individual characters in a string. For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance."
  example:
  - "The following example iterates the characters in several strings and displays information about their individual characters. It uses the language iteration construct rather than a call to the GetEnumerator method.  \n  \n [!code-cs[system.string.getenumerator#1](~/add/codesnippet/csharp/m-system.string.getenume_1.cs)]\n [!code-cpp[system.string.getenumerator#1](~/add/codesnippet/cpp/m-system.string.getenume_1.cpp)]\n [!code-vb[system.string.getenumerator#1](~/add/codesnippet/visualbasic/m-system.string.getenume_1.vb)]"
  syntax:
    content: public CharEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.CharEnumerator
      description: An enumerator object.
  overload: System.String.GetEnumerator*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.GetHashCode
  id: GetHashCode
  parent: System.String
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: String.GetHashCode()
  fullName: System.String.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns the hash code for this string.
  remarks: "The behavior of GetHashCode is dependent on its implementation, which might change from one version of the common language runtime to another. A reason why this might happen is to improve the performance of GetHashCode.  \n  \n> [!IMPORTANT]\n>  If two string objects are equal, the GetHashCode method returns identical values. However, there is not a unique hash code value for each unique string value. Different strings can return the same hash code.  \n>   \n>  The hash code itself is not guaranteed to be stable. Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework. In some cases, they can even differ by application domain.  \n>   \n>  As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.  \n>   \n>  Finally, do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash. For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName> class.  \n>   \n>  For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.  \n  \n In desktop apps, you can use the             [\\<UseRandomizedStringHashAlgorithm> element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md) to generate unique hash codes on a per application domain basis. This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables. The following example shows how to use the                [\\<UseRandomizedStringHashAlgorithm> element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md). It defines a  to generate unique hash codes on a per application domain basis. This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables. The following example shows how to use the . It defines a `DisplayString` class that includes a private string constant, `s`, whose value is \"This is a string.\" It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.  \n  \n [!code-cs[System.String.GetHashCode#2](~/add/codesnippet/csharp/m-system.string.gethashc_1.cs)]\n [!code-vb[System.String.GetHashCode#2](~/add/codesnippet/visualbasic/m-system.string.gethashc_1.vb)]  \n  \n When you run the example without supplying a configuration file, it displays output similar to the following. Note that the hash codes for the string are identical in the two application domains.  \n  \n```  \n  \nString 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  \nString 'This is a string.' in domain 'NewDomain': 941BCEAC  \n  \n```  \n  \n However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.  \n  \n```  \n  \n<?xml version =\"1.0\"?>  \n<configuration>  \n   <runtime>  \n      <UseRandomizedStringHashAlgorithm enabled=\"1\" />  \n   </runtime>  \n</configuration>  \n  \n```  \n  \n When the configuration file is present, the example displays the following output:  \n  \n```  \n  \nString 'This is a string.' in domain 'PerDomain.exe': 5435776D  \nString 'This is a string.' in domain 'NewDomain': 75CC8236  \n  \n```  \n  \n> [!IMPORTANT]\n>  Hash codes are used to insert and retrieve keyed objects from hash tables efficiently. However, hash codes do not uniquely identify strings. Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings. In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain. Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.  \n  \n For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=fullName>."
  example:
  - "The following example demonstrates the GetHashCode method using various input strings.  \n  \n [!code-cpp[system.string.gethashcode#1](~/add/codesnippet/cpp/m-system.string.gethashc_2.cpp)]\n [!code-vb[system.string.gethashcode#1](~/add/codesnippet/visualbasic/m-system.string.gethashc_2.vb)]\n [!code-cs[system.string.gethashcode#1](~/add/codesnippet/csharp/m-system.string.gethashc_2.cs)]"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: A 32-bit signed integer hash code.
  overload: System.String.GetHashCode*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.GetTypeCode
  id: GetTypeCode
  parent: System.String
  langs:
  - csharp
  name: GetTypeCode()
  nameWithType: String.GetTypeCode()
  fullName: System.String.GetTypeCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns the <xref href="System.TypeCode"></xref> for class <xref href="System.String"></xref>.
  remarks: ''
  example:
  - "The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.  \n  \n [!code-cs[string.gettypecode#1](~/add/codesnippet/csharp/m-system.string.gettypec_1.cs)]\n [!code-vb[string.gettypecode#1](~/add/codesnippet/visualbasic/m-system.string.gettypec_1.vb)]\n [!code-cpp[string.gettypecode#1](~/add/codesnippet/cpp/m-system.string.gettypec_1.cpp)]"
  syntax:
    content: public TypeCode GetTypeCode ();
    parameters: []
    return:
      type: System.TypeCode
      description: The enumerated constant, <xref href="System.TypeCode"></xref>.
  overload: System.String.GetTypeCode*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.Char)
  id: IndexOf(System.Char)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(Char)
  nameWithType: String.IndexOf(Char)
  fullName: System.String.IndexOf(Char)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified Unicode character in this string.
  remarks: "Index numbering starts from zero.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example demonstrates how you can search a <xref:System.String> for a character using the IndexOf method.  \n  \n [!code-cpp[System.String.IndexOf#5](~/add/codesnippet/cpp/m-system.string.indexof-_2_1.cpp)]\n [!code-vb[System.String.IndexOf#5](~/add/codesnippet/visualbasic/m-system.string.indexof-_2_1.vb)]\n [!code-cs[System.String.IndexOf#5](~/add/codesnippet/csharp/m-system.string.indexof-_2_1.cs)]"
  syntax:
    content: public int IndexOf (char value);
    parameters:
    - id: value
      type: System.Char
      description: A Unicode character to seek.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> if that character is found, or -1 if it is not.
  overload: System.String.IndexOf*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.String)
  id: IndexOf(System.String)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(String)
  nameWithType: String.IndexOf(String)
  fullName: System.String.IndexOf(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified string in this instance.
  remarks: "Index numbering starts from zero.  \n  \n This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at the first character position of this instance and continues until the last character position.  \n  \n Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, theIndexOf method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance. In the following example, the IndexOf method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by \"n\", and a soft hyphen followed by \"m\") in two strings. Only one of the strings contains a soft hyphen. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`. When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.  \n  \n [!code-vb[System.String.IndexOf#21](~/add/codesnippet/visualbasic/m-system.string.indexof-_3_1.vb)]\n [!code-cs[System.String.IndexOf#21](~/add/codesnippet/csharp/m-system.string.indexof-_3_1.cs)]"
  example:
  - "The following example searches for the \"n\" in \"animal\". Because string indexes begin at zero rather than one, the IndexOf method indicates that the \"n\" is at position 1.  \n  \n [!code-cpp[System.String.IndexOf#12](~/add/codesnippet/cpp/m-system.string.indexof-_3_2.cpp)]\n [!code-vb[System.String.IndexOf#12](~/add/codesnippet/visualbasic/m-system.string.indexof-_3_2.vb)]\n [!code-cs[System.String.IndexOf#12](~/add/codesnippet/csharp/m-system.string.indexof-_3_2.cs)]  \n  \n The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence. It then uses this position to insert an adjective that describes the animal into the sentence.  \n  \n [!code-cpp[stringinsert#1](~/add/codesnippet/cpp/m-system.string.indexof-_3_3.cpp)]\n [!code-vb[stringinsert#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_3_3.vb)]\n [!code-cs[stringinsert#1](~/add/codesnippet/csharp/m-system.string.indexof-_3_3.cs)]"
  syntax:
    content: public int IndexOf (string value);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> if that string is found, or -1 if it is not. If <code>value</code> is <xref href="System.String"></xref>, the return value is 0.
  overload: System.String.IndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.Char,System.Int32)
  id: IndexOf(System.Char,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(Char,Int32)
  nameWithType: String.IndexOf(Char,Int32)
  fullName: System.String.IndexOf(Char,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified Unicode character in this string. The search starts at a specified character position.
  remarks: "Index numbering starts from 0. The `startIndex` parameter can range from 0 to the length of the string instance. If `startIndex` equals the length of the string instance, the method returns -1.  \n  \n The search ranges from `startIndex` to the end of the string.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example demonstrates the <xref:System.String.IndexOf%2A> method.  \n  \n [!code-cpp[string.indexof1#1](~/add/codesnippet/cpp/m-system.string.indexof-_1_1.cpp)]\n [!code-cs[string.indexof1#1](~/add/codesnippet/csharp/m-system.string.indexof-_1_1.cs)]\n [!code-vb[string.indexof1#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_1_1.vb)]"
  syntax:
    content: public int IndexOf (char value, int startIndex);
    parameters:
    - id: value
      type: System.Char
      description: A Unicode character to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> from the start of the string if that character is found, or -1 if it is not.
  overload: System.String.IndexOf*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>startIndex</code> is less than 0 (zero) or greater than the length of the string.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.String,System.Int32)
  id: IndexOf(System.String,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(String,Int32)
  nameWithType: String.IndexOf(String,Int32)
  fullName: System.String.IndexOf(String,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified string in this instance. The search starts at a specified character position.
  remarks: "Index numbering starts from 0. The `startIndex` parameter can range from 0 to the length of the string instance. If `startIndex` equals the length of the string instance, the method returns -1.  \n  \n This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at the `startIndex` character position of this instance and continues until the last character position.  \n  \n Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the IndexOf method always returns `startIndex`, which is the character position at which the search begins. In the following example, the IndexOf method is used to find the position of a soft hyphen (U+00AD) followed by an \"m\" in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of \"m\" in the string. Note that in the case of the first string, which includes the soft hyphen followed by an \"m\", the method fails to return the index of the soft hyphen but instead returns the index of the \"m\".  \n  \n [!code-vb[System.String.IndexOf#22](~/add/codesnippet/visualbasic/m-system.string.indexof-_5_1.vb)]\n [!code-cs[System.String.IndexOf#22](~/add/codesnippet/csharp/m-system.string.indexof-_5_1.cs)]"
  example:
  - "The following example searches for all occurrences of a specified string within a target string.  \n  \n [!code-cs[stringindexof4#1](~/add/codesnippet/csharp/m-system.string.indexof-_5_2.cs)]\n [!code-cpp[stringindexof4#1](~/add/codesnippet/cpp/m-system.string.indexof-_5_2.cpp)]\n [!code-vb[stringindexof4#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_5_2.vb)]"
  syntax:
    content: public int IndexOf (string value, int startIndex);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> from the start of the current instance if that string is found, or -1 if it is not. If <code>value</code> is <xref href="System.String"></xref>, the return value is <code>startIndex</code>.
  overload: System.String.IndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>startIndex</code> is less than 0 (zero) or greater than the length of this string.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.String,System.StringComparison)
  id: IndexOf(System.String,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(String,StringComparison)
  nameWithType: String.IndexOf(String,StringComparison)
  fullName: System.String.IndexOf(String,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified string in the current <xref href="System.String"></xref> object. A parameter specifies the type of search to use for the specified string.
  remarks: "Index numbering starts from zero.  \n  \n The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules."
  example:
  - "The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  \n  \n [!code-vb[system.string.IndexOfCmp#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_7_1.vb)]\n [!code-cs[system.string.IndexOfCmp#1](~/add/codesnippet/csharp/m-system.string.indexof-_7_1.cs)]"
  syntax:
    content: public int IndexOf (string value, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules for the search.
    return:
      type: System.Int32
      description: The index position of the <code>value</code> parameter if that string is found, or -1 if it is not. If <code>value</code> is <xref href="System.String"></xref>, the return value is 0.
  overload: System.String.IndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a valid <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.Char,System.Int32,System.Int32)
  id: IndexOf(System.Char,System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(Char,Int32,Int32)
  nameWithType: String.IndexOf(Char,Int32,Int32)
  fullName: System.String.IndexOf(Char,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified character in this instance. The search starts at a specified character position and examines a specified number of character positions.
  remarks: "The search begins at `startIndex` and continues to `startIndex` + `count` -1. The character at `startIndex` + `count` is not included in the search.  \n  \n Index numbering starts from 0 (zero). The `startIndex` parameter can range from 0 to the length of the string instance.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example demonstrates the <xref:System.String.IndexOf%2A> method.  \n  \n [!code-cpp[system.string.indexof#1](~/add/codesnippet/cpp/m-system.string.indexof-_6_1.cpp)]\n [!code-cs[system.string.indexof#1](~/add/codesnippet/csharp/m-system.string.indexof-_6_1.cs)]\n [!code-vb[system.string.indexof#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_6_1.vb)]"
  syntax:
    content: public int IndexOf (char value, int startIndex, int count);
    parameters:
    - id: value
      type: System.Char
      description: A Unicode character to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position.
    - id: count
      type: System.Int32
      description: The number of character positions to examine.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> from the start of the string if that character is found, or -1 if it is not.
  overload: System.String.IndexOf*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>count</code> or <code>startIndex</code> is negative.  \n  \n -or-  \n  \n <code>startIndex</code> is greater than the length of this string.  \n  \n -or-  \n  \n <code>count</code> is greater than the length of this string minus <code>startIndex</code>."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.String,System.Int32,System.Int32)
  id: IndexOf(System.String,System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(String,Int32,Int32)
  nameWithType: String.IndexOf(String,Int32,Int32)
  fullName: System.String.IndexOf(String,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified string in this instance. The search starts at a specified character position and examines a specified number of character positions.
  remarks: "Index numbering starts from 0 (zero). The `startIndex` parameter can range from 0 to the length of the string instance.  \n  \n This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at `startIndex` and continues to `startIndex` + `count` -1. The character at `startIndex` + `count` is not included in the search.  \n  \n Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the IndexOf method always returns `startIndex`, which is the character position at which the search begins. In the following example, the IndexOf method is used to find the position of a soft hyphen (U+00AD) followed by an \"m\" starting in the third through sixth character positions in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of \"m\" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an \"m\", the method fails to return the index of the soft hyphen but instead returns the index of the \"m\".  \n  \n [!code-cs[System.String.IndexOf#23](~/add/codesnippet/csharp/m-system.string.indexof-_0_1.cs)]\n [!code-vb[System.String.IndexOf#23](~/add/codesnippet/visualbasic/m-system.string.indexof-_0_1.vb)]"
  example:
  - "The following example finds the index of all occurrences of the string \"he\" within a substring of another string. Note that the number of characters to be searched must be recalculated for each search iteration.  \n  \n [!code-cs[string.indexof8#1](~/add/codesnippet/csharp/m-system.string.indexof-_0_2.cs)]\n [!code-cpp[string.indexof8#1](~/add/codesnippet/cpp/m-system.string.indexof-_0_2.cpp)]\n [!code-vb[string.indexof8#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_0_2.vb)]"
  syntax:
    content: public int IndexOf (string value, int startIndex, int count);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position.
    - id: count
      type: System.Int32
      description: The number of character positions to examine.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> from the start of the current instance if that string is found, or -1 if it is not. If <code>value</code> is <xref href="System.String"></xref>, the return value is <code>startIndex</code>.
  overload: System.String.IndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>count</code> or <code>startIndex</code> is negative.  \n  \n -or-  \n  \n <code>startIndex</code> is greater than the length of this string.  \n  \n -or-  \n  \n <code>count</code> is greater than the length of this string minus <code>startIndex</code>."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.String,System.Int32,System.StringComparison)
  id: IndexOf(System.String,System.Int32,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(String,Int32,StringComparison)
  nameWithType: String.IndexOf(String,Int32,StringComparison)
  fullName: System.String.IndexOf(String,Int32,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified string in the current <xref href="System.String"></xref> object. Parameters specify the starting search position in the current string and the type of search to use for the specified string.
  remarks: "Index numbering starts from 0. The `startIndex` parameter can range from 0 to the length of the string instance. If `startIndex` equals the length of the string instance, the method returns -1.  \n  \n The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules."
  example:
  - "The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  \n  \n [!code-vb[system.string.IndexOfCmp#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_4_1.vb)]\n [!code-cs[system.string.IndexOfCmp#1](~/add/codesnippet/csharp/m-system.string.indexof-_4_1.cs)]"
  syntax:
    content: public int IndexOf (string value, int startIndex, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules for the search.
    return:
      type: System.Int32
      description: The zero-based index position of the <code>value</code> parameter from the start of the current instance if that string is found, or -1 if it is not. If <code>value</code> is <xref href="System.String"></xref>, the return value is <code>startIndex</code>.
  overload: System.String.IndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>startIndex</code> is less than 0 (zero) or greater than the length of this string.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a valid <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)
  id: IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: IndexOf(String,Int32,Int32,StringComparison)
  nameWithType: String.IndexOf(String,Int32,Int32,StringComparison)
  fullName: System.String.IndexOf(String,Int32,Int32,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence of the specified string in the current <xref href="System.String"></xref> object. Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.
  remarks: "Index numbering starts from 0 (zero). The `startIndex` parameter can range from 0 to the length of the string instance.  \n  \n The search begins at `startIndex` and continues to `startIndex` + `count` -1. The character at `startIndex` + `count` is not included in the search.  \n  \n The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules."
  example:
  - "The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  \n  \n [!code-vb[system.string.IndexOfCmp#1](~/add/codesnippet/visualbasic/fca1aed1-8a88-406c-8a0a-_1.vb)]\n [!code-cs[system.string.IndexOfCmp#1](~/add/codesnippet/csharp/fca1aed1-8a88-406c-8a0a-_1.cs)]"
  syntax:
    content: public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position.
    - id: count
      type: System.Int32
      description: The number of character positions to examine.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules for the search.
    return:
      type: System.Int32
      description: The zero-based index position of the <code>value</code> parameter from the start of the current instance if that string is found, or -1 if it is not. If <code>value</code> is <xref href="System.String"></xref>, the return value is <code>startIndex</code>.
  overload: System.String.IndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>count</code> or <code>startIndex</code> is negative.  \n  \n -or-  \n  \n <code>startIndex</code> is greater than the length of this instance.  \n  \n -or-  \n  \n <code>count</code> is greater than the length of this string minus <code>startIndex</code>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a valid <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOfAny(System.Char[])
  id: IndexOfAny(System.Char[])
  parent: System.String
  langs:
  - csharp
  name: IndexOfAny(Char[])
  nameWithType: String.IndexOfAny(Char[])
  fullName: System.String.IndexOfAny(Char[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.
  remarks: "Index numbering starts from zero.  \n  \n The search for `anyOf` is case-sensitive. If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example finds the first vowel in a string.  \n  \n [!code-cs[System.String.IndexOfAny#1](~/add/codesnippet/csharp/m-system.string.indexofa_0_1.cs)]\n [!code-vb[System.String.IndexOfAny#1](~/add/codesnippet/visualbasic/m-system.string.indexofa_0_1.vb)]"
  syntax:
    content: public int IndexOfAny (char[] anyOf);
    parameters:
    - id: anyOf
      type: System.Char[]
      description: A Unicode character array containing one or more characters to seek.
    return:
      type: System.Int32
      description: The zero-based index position of the first occurrence in this instance where any character in <code>anyOf</code> was found; -1 if no character in <code>anyOf</code> was found.
  overload: System.String.IndexOfAny*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>anyOf</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOfAny(System.Char[],System.Int32)
  id: IndexOfAny(System.Char[],System.Int32)
  parent: System.String
  langs:
  - csharp
  name: IndexOfAny(Char[],Int32)
  nameWithType: String.IndexOfAny(Char[],Int32)
  fullName: System.String.IndexOfAny(Char[],Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters. The search starts at a specified character position.
  remarks: "Index numbering starts from zero. The `startIndex` parameter can range from 0 to one less than the length of the string instance.  \n  \n The search ranges from `startIndex` to the end of the string.  \n  \n The search for `anyOf` is case-sensitive.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example finds the index of the occurrence of any character of the string \"is\" within a substring of another string.  \n  \n [!code-cpp[string.indexofany2#1](~/add/codesnippet/cpp/m-system.string.indexofa_1_1.cpp)]\n [!code-vb[string.indexofany2#1](~/add/codesnippet/visualbasic/m-system.string.indexofa_1_1.vb)]\n [!code-cs[string.indexofany2#1](~/add/codesnippet/csharp/m-system.string.indexofa_1_1.cs)]"
  syntax:
    content: public int IndexOfAny (char[] anyOf, int startIndex);
    parameters:
    - id: anyOf
      type: System.Char[]
      description: A Unicode character array containing one or more characters to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position.
    return:
      type: System.Int32
      description: The zero-based index position of the first occurrence in this instance where any character in <code>anyOf</code> was found; -1 if no character in <code>anyOf</code> was found.
  overload: System.String.IndexOfAny*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>anyOf</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code> is negative.  \n  \n -or-  \n  \n <code>startIndex</code> is greater than the number of characters in this instance."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)
  id: IndexOfAny(System.Char[],System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: IndexOfAny(Char[],Int32,Int32)
  nameWithType: String.IndexOfAny(Char[],Int32,Int32)
  fullName: System.String.IndexOfAny(Char[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters. The search starts at a specified character position and examines a specified number of character positions.
  remarks: "The search begins at `startIndex` and continues to `startIndex` + `count` -1. The character at `startIndex` + `count` is not included in the search.  \n  \n Index numbering starts from zero. The `startIndex` parameter can range from 0 to one less than the length of the string instance.  \n  \n The search for `anyOf` is case-sensitive.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example finds the index of the occurrence of any character of the string \"aid\" within a substring of another string.  \n  \n [!code-cpp[string.indexofany3#1](~/add/codesnippet/cpp/m-system.string.indexofa_2_1.cpp)]\n [!code-cs[string.indexofany3#1](~/add/codesnippet/csharp/m-system.string.indexofa_2_1.cs)]\n [!code-vb[string.indexofany3#1](~/add/codesnippet/visualbasic/m-system.string.indexofa_2_1.vb)]"
  syntax:
    content: public int IndexOfAny (char[] anyOf, int startIndex, int count);
    parameters:
    - id: anyOf
      type: System.Char[]
      description: A Unicode character array containing one or more characters to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position.
    - id: count
      type: System.Int32
      description: The number of character positions to examine.
    return:
      type: System.Int32
      description: The zero-based index position of the first occurrence in this instance where any character in <code>anyOf</code> was found; -1 if no character in <code>anyOf</code> was found.
  overload: System.String.IndexOfAny*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>anyOf</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>count</code> or <code>startIndex</code> is negative.  \n  \n -or-  \n  \n <code>count</code> + <code>startIndex</code> is greater than the number of characters in this instance."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Insert(System.Int32,System.String)
  id: Insert(System.Int32,System.String)
  parent: System.String
  langs:
  - csharp
  name: Insert(Int32,String)
  nameWithType: String.Insert(Int32,String)
  fullName: System.String.Insert(Int32,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string in which a specified string is inserted at a specified index position in this instance.
  remarks: "If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which `value` is inserted into the current instance.  \n  \n For example, the return value of `\"abc\".Insert(2, \"XYZ\")` is \"abXYZc\"."
  example:
  - "The following example inserts a space character in the fourth character position (the character at index 3) of a string.  \n  \n [!code-cs[System.String.Insert#1](~/add/codesnippet/csharp/m-system.string.insert-s_1.cs)]\n [!code-vb[System.String.Insert#1](~/add/codesnippet/visualbasic/m-system.string.insert-s_1.vb)]  \n  \n The following console application prompts the users to enter one or more adjectives to describe two animals. It then calls the Insert method to insert the text entered by the user into a string.  \n  \n [!code-cpp[stringinsert#1](~/add/codesnippet/cpp/m-system.string.insert-s_2.cpp)]\n [!code-vb[stringinsert#1](~/add/codesnippet/visualbasic/m-system.string.insert-s_2.vb)]\n [!code-cs[stringinsert#1](~/add/codesnippet/csharp/m-system.string.insert-s_2.cs)]"
  syntax:
    content: public string Insert (int startIndex, string value);
    parameters:
    - id: startIndex
      type: System.Int32
      description: The zero-based index position of the insertion.
    - id: value
      type: System.String
      description: The string to insert.
    return:
      type: System.String
      description: A new string that is equivalent to this instance, but with <code>value</code> inserted at position <code>startIndex</code>.
  overload: System.String.Insert*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>startIndex</code> is negative or greater than the length of this instance.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Intern(System.String)
  id: Intern(System.String)
  parent: System.String
  langs:
  - csharp
  name: Intern(String)
  nameWithType: String.Intern(String)
  fullName: System.String.Intern(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Retrieves the system's reference to the specified <xref href="System.String"></xref>.
  remarks: "The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program. Consequently, an instance of a literal string with a particular value only exists once in the system.  \n  \n For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.  \n  \n The Intern method uses the intern pool to search for a string equal to the value of `str`. If such a string exists, its reference in the intern pool is returned. If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.  \n  \n In the following example, the string s1, which has a value of \"MyTest\", is already interned because it is a literal in the program. The <xref:System.Text.StringBuilder?displayProperty=fullName> class generates a new string object that has the same value as s1. A reference to that string is assigned to s2. The Intern method searches for a string that has the same value as s2. Because such a string exists, the method returns the same reference that is assigned to s1. That reference is then assigned to s3. References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.  \n  \n [!code-cs[System.String.Intern#1](~/add/codesnippet/csharp/m-system.string.intern-s_1.cs)]\n [!code-vb[System.String.Intern#1](~/add/codesnippet/visualbasic/m-system.string.intern-s_1.vb)]  \n  \n Compare this method to the <xref:System.String.IsInterned%2A> method.  \n  \n## Version Considerations  \n In the [!INCLUDE[net_v35SP1_long](~/add/includes/net-v35sp1-long-md.md)], the Intern method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string. In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty>, and the variable `str2` is assigned the reference to <xref:System.String.Empty> that is returned by calling the Intern method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty> to a string. Then the references contained in `str1` and `str2` are compared for equality.  \n  \n [!code-cs[System.String.Intern#2](~/add/codesnippet/csharp/m-system.string.intern-s_2.cs)]\n [!code-vb[System.String.Intern#2](~/add/codesnippet/visualbasic/m-system.string.intern-s_2.vb)]  \n  \n In the [!INCLUDE[net_v10_short](~/add/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/add/includes/net-v11-short-md.md)], and [!INCLUDE[net_v35SP1_short](~/add/includes/net-v35sp1-short-md.md)], `str1` and `str2` are equal. In the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/add/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.  \n  \n## Performance Considerations  \n If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects. First, the memory allocated for interned <xref:System.String> objects is not likely be released until the common language runtime (CLR) terminates. The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates. Second, to intern a string, you must first create the string. The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.  \n  \n The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations?displayProperty=fullName>enumeration member. The <xref:System.Runtime.CompilerServices.CompilationRelaxations> member marks an assembly as not requiring string-literal interning. You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute. Also, when you use the [Ngen.exe (Native Image Generator)](~/add/includes/ajax-current-ext-md.md) to compile an assembly in advance of run time, strings are not interned across modules."
  example:
  - "The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.  \n  \n [!code-cpp[string.intern#1](~/add/codesnippet/cpp/m-system.string.intern-s_3.cpp)]\n [!code-cs[string.intern#1](~/add/codesnippet/csharp/m-system.string.intern-s_3.cs)]\n [!code-vb[string.intern#1](~/add/codesnippet/visualbasic/m-system.string.intern-s_3.vb)]"
  syntax:
    content: public static string Intern (string str);
    parameters:
    - id: str
      type: System.String
      description: A string to search for in the intern pool.
    return:
      type: System.String
      description: The system's reference to <code>str</code>, if it is interned; otherwise, a new reference to a string with the value of <code>str</code>.
  overload: System.String.Intern*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>str</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IsInterned(System.String)
  id: IsInterned(System.String)
  parent: System.String
  langs:
  - csharp
  name: IsInterned(String)
  nameWithType: String.IsInterned(String)
  fullName: System.String.IsInterned(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Retrieves a reference to a specified <xref href="System.String"></xref>.
  remarks: "The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.  \n  \n The intern pool conserves string storage. If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.  \n  \n This method looks up `str` in the intern pool. If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.  \n  \n Compare this method to the <xref:System.String.Intern%2A> method.  \n  \n This method does not return a Boolean value. If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.  \n  \n [!code-vb[System.String.IsInterned#1](~/add/codesnippet/visualbasic/m-system.string.isintern_1.vb)]\n [!code-cs[System.String.IsInterned#1](~/add/codesnippet/csharp/m-system.string.isintern_1.cs)]  \n  \n> [!NOTE]\n>  Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](~/add/includes/ajax-current-ext-md.md) to install an assembly to the native image cache on a local computer. For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property."
  example:
  - "The following example demonstrates that literal strings are interned automatically by the compiler.  \n  \n [!code-cs[string.isinterned#1](~/add/codesnippet/csharp/m-system.string.isintern_2.cs)]\n [!code-vb[string.isinterned#1](~/add/codesnippet/visualbasic/m-system.string.isintern_2.vb)]\n [!code-cpp[string.isinterned#1](~/add/codesnippet/cpp/m-system.string.isintern_2.cpp)]"
  syntax:
    content: public static string IsInterned (string str);
    parameters:
    - id: str
      type: System.String
      description: The string to search for in the intern pool.
    return:
      type: System.String
      description: A reference to <code>str</code> if it is in the common language runtime intern pool; otherwise, `null`.
  overload: System.String.IsInterned*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>str</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IsNormalized
  id: IsNormalized
  parent: System.String
  langs:
  - csharp
  name: IsNormalized()
  nameWithType: String.IsNormalized()
  fullName: System.String.IsNormalized()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Indicates whether this string is in Unicode normalization form C.
  remarks: "Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.  \n  \n The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework currently supports normalization forms C, D, KC, and KD.  \n  \n For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>."
  example:
  - "The following example determines whether a string is successfully normalized to various normalization forms.  \n  \n [!code-vb[string.normalize#1](~/add/codesnippet/visualbasic/m-system.string.isnormal_0_1.vb)]\n [!code-cpp[string.normalize#1](~/add/codesnippet/cpp/m-system.string.isnormal_0_1.cpp)]\n [!code-cs[string.normalize#1](~/add/codesnippet/csharp/m-system.string.isnormal_0_1.cs)]"
  syntax:
    content: public bool IsNormalized ();
    parameters: []
    return:
      type: System.Boolean
      description: '`true` if this string is in normalization form C; otherwise, `false`.'
  overload: System.String.IsNormalized*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The current instance contains invalid Unicode characters.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IsNormalized(System.Text.NormalizationForm)
  id: IsNormalized(System.Text.NormalizationForm)
  parent: System.String
  langs:
  - csharp
  name: IsNormalized(NormalizationForm)
  nameWithType: String.IsNormalized(NormalizationForm)
  fullName: System.String.IsNormalized(NormalizationForm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Indicates whether this string is in the specified Unicode normalization form.
  remarks: "Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.  \n  \n The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework currently supports normalization forms C, D, KC, and KD.  \n  \n For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>."
  example:
  - "The following example demonstrates the <xref:System.String.IsNormalized%2A> and <xref:System.String.Normalize%2A> methods.  \n  \n [!code-vb[string.normalize#1](~/add/codesnippet/visualbasic/m-system.string.isnormal_1_1.vb)]\n [!code-cpp[string.normalize#1](~/add/codesnippet/cpp/m-system.string.isnormal_1_1.cpp)]\n [!code-cs[string.normalize#1](~/add/codesnippet/csharp/m-system.string.isnormal_1_1.cs)]"
  syntax:
    content: public bool IsNormalized (System.Text.NormalizationForm normalizationForm);
    parameters:
    - id: normalizationForm
      type: System.Text.NormalizationForm
      description: A Unicode normalization form.
    return:
      type: System.Boolean
      description: '`true` if this string is in the normalization form specified by the <code>normalizationForm</code> parameter; otherwise, `false`.'
  overload: System.String.IsNormalized*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The current instance contains invalid Unicode characters.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IsNullOrEmpty(System.String)
  id: IsNullOrEmpty(System.String)
  parent: System.String
  langs:
  - csharp
  name: IsNullOrEmpty(String)
  nameWithType: String.IsNullOrEmpty(String)
  fullName: System.String.IsNullOrEmpty(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Indicates whether the specified string is `null` or an <xref href="System.String.Empty"></xref> string.
  remarks: "IsNullOrEmpty is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String>. It is equivalent to the following code:  \n  \n [!code-cpp[System.String.IsNullOrEmpty#1](~/add/codesnippet/cpp/m-system.string.isnullor_0_1.cpp)]\n [!code-cs[System.String.IsNullOrEmpty#1](~/add/codesnippet/csharp/m-system.string.isnullor_0_1.cs)]\n [!code-vb[System.String.IsNullOrEmpty#1](~/add/codesnippet/visualbasic/m-system.string.isnullor_0_1.vb)]  \n  \n You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=fullName>,  or it consists only of white-space characters.  \n  \n## What is a null string?  \n A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of `null`. Although the [composite formatting](~/add/includes/ajax-current-ext-md.md) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.  \n  \n [!code-cpp[System.String.IsNullOrEmpty#2](~/add/codesnippet/cpp/m-system.string.isnullor_0_2.cpp)]\n [!code-cs[System.String.IsNullOrEmpty#2](~/add/codesnippet/csharp/m-system.string.isnullor_0_2.cs)]\n [!code-vb[System.String.IsNullOrEmpty#2](~/add/codesnippet/visualbasic/m-system.string.isnullor_0_2.vb)]  \n  \n## What is an empty string?  \n A string is empty if it  is explicitly assigned an empty string (\"\") or <xref:System.String.Empty?displayProperty=fullName>. An empty string has a <xref:System.String.Length%2A> of 0.  The following example creates an empty string and displays its value and its length.  \n  \n [!code-cpp[System.String.IsNullOrEmpty#3](~/add/codesnippet/cpp/m-system.string.isnullor_0_3.cpp)]\n [!code-cs[System.String.IsNullOrEmpty#3](~/add/codesnippet/csharp/m-system.string.isnullor_0_3.cs)]\n [!code-vb[System.String.IsNullOrEmpty#3](~/add/codesnippet/visualbasic/m-system.string.isnullor_0_3.vb)]"
  example:
  - "The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.  \n  \n [!code-cs[String.IsNullOrEmpty#1](~/add/codesnippet/csharp/m-system.string.isnullor_0_4.cs)]\n [!code-cpp[String.IsNullOrEmpty#1](~/add/codesnippet/cpp/m-system.string.isnullor_0_4.cpp)]\n [!code-vb[String.IsNullOrEmpty#1](~/add/codesnippet/visualbasic/m-system.string.isnullor_0_4.vb)]"
  syntax:
    content: public static bool IsNullOrEmpty (string value);
    parameters:
    - id: value
      type: System.String
      description: The string to test.
    return:
      type: System.Boolean
      description: '`true` if the <code>value</code> parameter is `null` or an empty string (""); otherwise, `false`.'
  overload: System.String.IsNullOrEmpty*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.IsNullOrWhiteSpace(System.String)
  id: IsNullOrWhiteSpace(System.String)
  parent: System.String
  langs:
  - csharp
  name: IsNullOrWhiteSpace(String)
  nameWithType: String.IsNullOrWhiteSpace(String)
  fullName: System.String.IsNullOrWhiteSpace(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Indicates whether a specified string is `null`, empty, or consists only of white-space characters.
  remarks: "IsNullOrWhiteSpace is a convenience method that is similar to the following  code, except that it offers superior performance:  \n  \n [!code-cs[System.String.IsNullOrWhitespace#2](~/add/codesnippet/csharp/m-system.string.isnullor_1_1.cs)]\n [!code-vb[System.String.IsNullOrWhitespace#2](~/add/codesnippet/visualbasic/m-system.string.isnullor_1_1.vb)]  \n  \n White-space characters are defined by the Unicode standard. The IsNullOrWhiteSpace method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method as a white-space character."
  example:
  - "The following example creates a string array, and then passes each element of the array to the IsNullOrWhiteSpace method.  \n  \n [!code-vb[System.String.IsNullOrWhiteSpace#1](~/add/codesnippet/visualbasic/m-system.string.isnullor_1_2.vb)]\n [!code-cs[System.String.IsNullOrWhiteSpace#1](~/add/codesnippet/csharp/m-system.string.isnullor_1_2.cs)]"
  syntax:
    content: public static bool IsNullOrWhiteSpace (string value);
    parameters:
    - id: value
      type: System.String
      description: The string to test.
    return:
      type: System.Boolean
      description: '`true` if the <code>value</code> parameter is `null` or <xref href="System.String"></xref>, or if <code>value</code> consists exclusively of white-space characters.'
  overload: System.String.IsNullOrWhiteSpace*
  exceptions: []
  version:
  - netframework-40
- uid: System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})
  id: Join(System.String,System.Collections.Generic.IEnumerable{System.String})
  parent: System.String
  langs:
  - csharp
  name: Join(String,IEnumerable<String>)
  nameWithType: String.Join(String,IEnumerable<String>)
  fullName: System.String.Join(String,IEnumerable<String>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the members of a constructed <xref:System.Collections.Generic.IEnumerable`1> collection of type <xref href="System.String"></xref>, using the specified separator between each member.
  remarks: "If `separator` is `null`, an empty string (<xref:System.String?displayProperty=fullName>) is used instead. If any member of `values` is `null`, an empty string is used instead.  \n  \n Join is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array. It is particularly useful with Language-Integrated Query (LINQ) query expressions. The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is \"M\"). The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName> method is passed to the Join method to display the result as a single string.  \n  \n [!code-cs[System.String.Join#4](~/add/codesnippet/csharp/b02d03ba-30d8-4b66-9fc1-_1.cs)]\n [!code-vb[System.String.Join#4](~/add/codesnippet/visualbasic/b02d03ba-30d8-4b66-9fc1-_1.vb)]"
  example:
  - "The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the Join method.  \n  \n [!code-cs[System.String.Join#3](~/add/codesnippet/csharp/b02d03ba-30d8-4b66-9fc1-_2.cs)]\n [!code-vb[System.String.Join#3](~/add/codesnippet/visualbasic/b02d03ba-30d8-4b66-9fc1-_2.vb)]"
  syntax:
    content: public static string Join (string separator, System.Collections.Generic.IEnumerable<string> values);
    parameters:
    - id: separator
      type: System.String
      description: The string to use as a separator.`separator` is included in the returned string only if `values` has more than one element.
    - id: values
      type: System.Collections.Generic.IEnumerable{System.String}
      description: A collection that contains the strings to concatenate.
    return:
      type: System.String
      description: A string that consists of the members of <code>values</code> delimited by the <code>separator</code> string. If <code>values</code> has no members, the method returns <xref href="System.String"></xref>.
  overload: System.String.Join*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>values</code> is `null`.
  version:
  - netframework-40
- uid: System.String.Join(System.String,System.Object[])
  id: Join(System.String,System.Object[])
  parent: System.String
  langs:
  - csharp
  name: Join(String,Object[])
  nameWithType: String.Join(String,Object[])
  fullName: System.String.Join(String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the elements of an object array, using the specified separator between each element.
  remarks: "If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String?displayProperty=fullName>) is used instead. See the Notes for Callers section if the first element of `values` is `null`.  \n  \n Join is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings. The string representation of each object in the array is derived by calling that object's `ToString` method."
  example:
  - "The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a integer array, which it then passes to the Join method.  \n  \n [!code-cs[System.String.Join#1](~/add/codesnippet/csharp/m-system.string.join-sys_2_1.cs)]\n [!code-vb[System.String.Join#1](~/add/codesnippet/visualbasic/m-system.string.join-sys_2_1.vb)]"
  syntax:
    content: public static string Join (string separator, object[] values);
    parameters:
    - id: separator
      type: System.String
      description: The string to use as a separator. `separator` is included in the returned string only if `values` has more than one element.
    - id: values
      type: System.Object[]
      description: An array that contains the elements to concatenate.
    return:
      type: System.String
      description: A string that consists of the elements of <code>values</code> delimited by the <code>separator</code> string. If <code>values</code> is an empty array, the method returns <xref href="System.String"></xref>.
  overload: System.String.Join*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>values</code> is `null`.
  version:
  - netframework-40
- uid: System.String.Join(System.String,System.String[])
  id: Join(System.String,System.String[])
  parent: System.String
  langs:
  - csharp
  name: Join(String,String[])
  nameWithType: String.Join(String,String[])
  fullName: System.String.Join(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates all the elements of a string array, using the specified separator between each element.
  remarks: "For example, if `separator` is \", \" and the elements of `value` are \"apple\", \"orange\", \"grape\", and \"pear\", `Join(separator, value)` returns \"apple, orange, grape, pear\".  \n  \n If `separator` is `null`, an empty string (<xref:System.String?displayProperty=fullName>) is used instead. If any element in `value` is `null`, an empty string is used instead."
  example:
  - "The following example demonstrates the Join method.  \n  \n [!code-vb[stringjoin#1](~/add/codesnippet/visualbasic/m-system.string.join-sys_1_1.vb)]\n [!code-cs[stringjoin#1](~/add/codesnippet/csharp/m-system.string.join-sys_1_1.cs)]\n [!code-cpp[stringjoin#1](~/add/codesnippet/cpp/m-system.string.join-sys_1_1.cpp)]"
  syntax:
    content: public static string Join (string separator, string[] value);
    parameters:
    - id: separator
      type: System.String
      description: The string to use as a separator. `separator` is included in the returned string only if `value` has more than one element.
    - id: value
      type: System.String[]
      description: An array that contains the elements to concatenate.
    return:
      type: System.String
      description: A string that consists of the elements in <code>value</code> delimited by the <code>separator</code> string. If <code>value</code> is an empty array, the method returns <xref href="System.String"></xref>.
  overload: System.String.Join*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Join(System.String,System.String[],System.Int32,System.Int32)
  id: Join(System.String,System.String[],System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: Join(String,String[],Int32,Int32)
  nameWithType: String.Join(String,String[],Int32,Int32)
  fullName: System.String.Join(String,String[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Concatenates the specified elements of a string array, using the specified separator between each element.
  remarks: "For example, if `separator` is \", \" and the elements of `value` are \"apple\", \"orange\", \"grape\", and \"pear\", `Join(separator, value, 1, 2)` returns \"orange, grape\".  \n  \n If `separator` is `null`, an empty string (<xref:System.String?displayProperty=fullName>) is used instead. If any element in `value` is `null`, an empty string is used instead."
  example:
  - "The following example concatenates two elements from an array of names of fruit.  \n  \n [!code-cs[string.join2#1](~/add/codesnippet/csharp/m-system.string.join-sys_0_1.cs)]\n [!code-vb[string.join2#1](~/add/codesnippet/visualbasic/m-system.string.join-sys_0_1.vb)]\n [!code-cpp[string.join2#1](~/add/codesnippet/cpp/m-system.string.join-sys_0_1.cpp)]"
  syntax:
    content: public static string Join (string separator, string[] value, int startIndex, int count);
    parameters:
    - id: separator
      type: System.String
      description: The string to use as a separator. `separator` is included in the returned string only if `value` has more than one element.
    - id: value
      type: System.String[]
      description: An array that contains the elements to concatenate.
    - id: startIndex
      type: System.Int32
      description: The first element in `value` to use.
    - id: count
      type: System.Int32
      description: The number of elements of `value` to use.
    return:
      type: System.String
      description: "A string that consists of the strings in <code>value</code> delimited by the <code>separator</code> string.  \n  \n -or-  \n  \n <xref href=\"System.String\"></xref> if <code>count</code> is zero, <code>value</code> has no elements, or <code>separator</code> and all the elements of <code>value</code> are <xref href=\"System.String\"></xref>."
  overload: System.String.Join*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code> or <code>count</code> is less than 0.  \n  \n -or-  \n  \n <code>startIndex</code> plus <code>count</code> is greater than the number of elements in <code>value</code>."
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: Out of memory.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Join``1(System.String,System.Collections.Generic.IEnumerable`1)
  id: Join``1(System.String,System.Collections.Generic.IEnumerable`1)
  parent: System.String
  langs:
  - csharp
  name: Join(String,IEnumerable<T>)
  nameWithType: String.Join(String,IEnumerable<T>)
  fullName: System.String.Join(String,IEnumerable<T>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  syntax:
    content: public static string Join<T> (string separator, System.Collections.Generic.IEnumerable<T> values);
    parameters:
    - id: separator
      type: System.String
      description: To be added.
    - id: values
      type: System.Collections.Generic.IEnumerable`1
      description: To be added.
    return:
      type: System.String
      description: To be added.
  overload: System.String.Join<T>*
  exceptions: []
  version:
  - netframework-40
- uid: System.String.LastIndexOf(System.Char)
  id: LastIndexOf(System.Char)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(Char)
  nameWithType: String.LastIndexOf(Char)
  fullName: System.String.LastIndexOf(Char)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  \n  \n This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined. The search is case-sensitive.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example defines an `ExtractFilename` method that uses the LastIndexOf method to find the last directory separator character in a string and to extract the string's file name. If the file exists, the method returns the file name without its path.  \n  \n [!code-cs[System.String.LastIndexOf#1](~/add/codesnippet/csharp/m-system.string.lastinde_8_1.cs)]\n [!code-vb[System.String.LastIndexOf#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_8_1.vb)]"
  syntax:
    content: public int LastIndexOf (char value);
    parameters:
    - id: value
      type: System.Char
      description: The Unicode character to seek.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> if that character is found, or -1 if it is not.
  overload: System.String.LastIndexOf*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOf(System.String)
  id: LastIndexOf(System.String)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(String)
  nameWithType: String.LastIndexOf(String)
  fullName: System.String.LastIndexOf(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence of a specified string within this instance.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  \n  \n The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.  \n  \n This method performs a word (case-sensitive and culture-sensitive) search using the current culture.  \n  \n Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the LastIndexOf method always returns <xref:System.String.Length%2A?displayProperty=fullName> – 1, which represents the last index position in the current instance. In the following example, the LastIndexOf method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by \"n\", and a soft hyphen followed by \"m\") in two strings. Only one of the strings contains a soft hyphen. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`. When searching for a soft hyphen only, the method returns 6 and 5. These values correspond to the index of the last character in the two strings.  \n  \n [!code-cs[System.String.LastIndexOf#21](~/add/codesnippet/csharp/m-system.string.lastinde_10_1.cs)]\n [!code-vb[System.String.LastIndexOf#21](~/add/codesnippet/visualbasic/m-system.string.lastinde_10_1.vb)]"
  example:
  - "The following example removes opening and closing HTML tags from a string if the tags begin and end the string. If a string ends with a closing bracket character (\">\"), the example uses the LastIndexOf method to locate the start of the end tag.  \n  \n [!code-cs[System.String.LastIndexOf#2](~/add/codesnippet/csharp/m-system.string.lastinde_10_2.cs)]\n [!code-vb[System.String.LastIndexOf#2](~/add/codesnippet/visualbasic/m-system.string.lastinde_10_2.vb)]"
  syntax:
    content: public int LastIndexOf (string value);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    return:
      type: System.Int32
      description: The zero-based starting index position of <code>value</code> if that string is found, or -1 if it is not. If <code>value</code> is <xref href="System.String"></xref>, the return value is the last index position in this instance.
  overload: System.String.LastIndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOf(System.Char,System.Int32)
  id: LastIndexOf(System.Char,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(Char,Int32)
  nameWithType: String.LastIndexOf(Char,Int32)
  fullName: System.String.LastIndexOf(Char,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning. The search is case-sensitive.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.  \n  \n [!code-cs[string.lastindexof1#1](~/add/codesnippet/csharp/m-system.string.lastinde_4_1.cs)]\n [!code-cpp[string.lastindexof1#1](~/add/codesnippet/cpp/m-system.string.lastinde_4_1.cpp)]\n [!code-vb[string.lastindexof1#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_4_1.vb)]"
  syntax:
    content: public int LastIndexOf (char value, int startIndex);
    parameters:
    - id: value
      type: System.Char
      description: The Unicode character to seek.
    - id: startIndex
      type: System.Int32
      description: The starting position of the search. The search proceeds from `startIndex` toward the beginning of this instance.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> if that character is found, or -1 if it is not found or if the current instance equals <xref href="System.String.Empty"></xref>.
  overload: System.String.LastIndexOf*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: The current instance does not equal <xref href="System.String.Empty"></xref>, and <code>startIndex</code> is less than zero or greater than or equal to the length of this instance.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOf(System.String,System.Int32)
  id: LastIndexOf(System.String,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(String,Int32)
  nameWithType: String.LastIndexOf(String,Int32)
  fullName: System.String.LastIndexOf(String,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  \n  \n The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.  \n  \n This method performs a word (case-sensitive and culture-sensitive) search using the current culture.  \n  \n Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the LastIndexOf method always returns `startIndex`, which is the character position at which the search begins. In the following example, the LastIndexOf method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final \"m\" in a string. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and \"m\" returns the position of the \"m\" in the string, whereas calling it to find a substring that consists of the soft hyphen and \"n\" returns the position of the \"n\". When the search string contains only the soft hyphen, the method returns the index of the \"m\", which represents the value of `startIndex`.  \n  \n [!code-cs[System.String.LastIndexOf#22](~/add/codesnippet/csharp/m-system.string.lastinde_0_1.cs)]\n [!code-vb[System.String.LastIndexOf#22](~/add/codesnippet/visualbasic/m-system.string.lastinde_0_1.vb)]"
  example:
  - "The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.  \n  \n [!code-cpp[string.lastindexof7#1](~/add/codesnippet/cpp/m-system.string.lastinde_0_2.cpp)]\n [!code-vb[string.lastindexof7#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_0_2.vb)]\n [!code-cs[string.lastindexof7#1](~/add/codesnippet/csharp/m-system.string.lastinde_0_2.cs)]"
  syntax:
    content: public int LastIndexOf (string value, int startIndex);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.
    return:
      type: System.Int32
      description: The zero-based starting index position of <code>value</code> if that string is found, or -1 if it is not found or if the current instance equals <xref href="System.String"></xref>. If <code>value</code> is <xref href="System.String"></xref>, the return value is the smaller of <code>startIndex</code> and the last index position in this instance.
  overload: System.String.LastIndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The current instance does not equal <xref href=\"System.String\"></xref>, and <code>startIndex</code> is less than zero or greater than the length of the current instance.  \n  \n -or-  \n  \n The current instance equals <xref href=\"System.String\"></xref>, and <code>startIndex</code> is less than -1 or greater than zero."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOf(System.String,System.StringComparison)
  id: LastIndexOf(System.String,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(String,StringComparison)
  nameWithType: String.LastIndexOf(String,StringComparison)
  fullName: System.String.LastIndexOf(String,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the last occurrence of a specified string within the current <xref href="System.String"></xref> object. A parameter specifies the type of search to use for the specified string.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  \n  \n The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.  \n  \n The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined."
  example:
  - "The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  \n  \n [!code-cs[system.string.LastIndexOfCmp#1](~/add/codesnippet/csharp/m-system.string.lastinde_6_1.cs)]\n [!code-vb[system.string.LastIndexOfCmp#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_6_1.vb)]"
  syntax:
    content: public int LastIndexOf (string value, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules for the search.
    return:
      type: System.Int32
      description: The zero-based starting index position of the <code>value</code> parameter if that string is found, or -1 if it is not. If <code>value</code> is <xref href="System.String"></xref>, the return value is the last index position in this instance.
  overload: System.String.LastIndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a valid <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOf(System.Char,System.Int32,System.Int32)
  id: LastIndexOf(System.Char,System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(Char,Int32,Int32)
  nameWithType: String.LastIndexOf(Char,Int32,Int32)
  fullName: System.String.LastIndexOf(Char,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  \n  \n This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string. The search is case-sensitive.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.  \n  \n [!code-cs[string.lastindexof2#1](~/add/codesnippet/csharp/m-system.string.lastinde_9_1.cs)]\n [!code-vb[string.lastindexof2#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_9_1.vb)]\n [!code-cpp[string.lastindexof2#1](~/add/codesnippet/cpp/m-system.string.lastinde_9_1.cpp)]"
  syntax:
    content: public int LastIndexOf (char value, int startIndex, int count);
    parameters:
    - id: value
      type: System.Char
      description: The Unicode character to seek.
    - id: startIndex
      type: System.Int32
      description: The starting position of the search. The search proceeds from `startIndex` toward the beginning of this instance.
    - id: count
      type: System.Int32
      description: The number of character positions to examine.
    return:
      type: System.Int32
      description: The zero-based index position of <code>value</code> if that character is found, or -1 if it is not found or if the current instance equals <xref href="System.String.Empty"></xref>.
  overload: System.String.LastIndexOf*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The current instance does not equal <xref href=\"System.String.Empty\"></xref>, and <code>startIndex</code> is less than zero or greater than or equal to the length of this instance.  \n  \n -or-  \n  \n The current instance does not equal <xref href=\"System.String.Empty\"></xref>, and <code>startIndex</code> - <code>count</code> + 1 is less than zero."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOf(System.String,System.Int32,System.Int32)
  id: LastIndexOf(System.String,System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(String,Int32,Int32)
  nameWithType: String.LastIndexOf(String,Int32,Int32)
  fullName: System.String.LastIndexOf(String,Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  \n  \n The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.  \n  \n This method performs a word (case-sensitive and culture-sensitive) search using the current culture.  \n  \n Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the LastIndexOf method always returns `startIndex`, which is the character position at which the search begins. In the following example, the LastIndexOf method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final \"m\" of two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of \"m\" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an \"m\", the method fails to return the index of the soft hyphen but instead returns the index of the \"m\".  \n  \n [!code-cs[System.String.LastIndexOf#23](~/add/codesnippet/csharp/m-system.string.lastinde_5_1.cs)]\n [!code-vb[System.String.LastIndexOf#23](~/add/codesnippet/visualbasic/m-system.string.lastinde_5_1.vb)]"
  example:
  - "The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.  \n  \n [!code-cpp[string.lastindexof8#1](~/add/codesnippet/cpp/m-system.string.lastinde_5_2.cpp)]\n [!code-vb[string.lastindexof8#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_5_2.vb)]\n [!code-cs[string.lastindexof8#1](~/add/codesnippet/csharp/m-system.string.lastinde_5_2.cs)]"
  syntax:
    content: public int LastIndexOf (string value, int startIndex, int count);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.
    - id: count
      type: System.Int32
      description: The number of character positions to examine.
    return:
      type: System.Int32
      description: The zero-based starting index position of <code>value</code> if that string is found, or -1 if it is not found or if the current instance equals <xref href="System.String"></xref>. If <code>value</code> is <xref href="System.String"></xref>, the return value is the smaller of <code>startIndex</code> and the last index position in this instance.
  overload: System.String.LastIndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>count</code> is negative.  \n  \n -or-  \n  \n The current instance does not equal <xref href=\"System.String\"></xref>, and <code>startIndex</code> is negative.  \n  \n -or-  \n  \n The current instance does not equal <xref href=\"System.String\"></xref>, and <code>startIndex</code> is greater than the length of this instance.  \n  \n -or-  \n  \n The current instance does not equal <xref href=\"System.String.Empty\"></xref>, and <code>startIndex</code> - <code>count</code>+ 1 specifies a position that is not within this instance.  \n  \n -or-  \n  \n The current instance equals <xref href=\"System.String.Empty\"></xref> and <code>start</code> is less than -1 or greater than zero.  \n  \n -or-  \n  \n The current instance equals <xref href=\"System.String.Empty\"></xref> and <code>count</code> is greater than 1."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)
  id: LastIndexOf(System.String,System.Int32,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(String,Int32,StringComparison)
  nameWithType: String.LastIndexOf(String,Int32,StringComparison)
  fullName: System.String.LastIndexOf(String,Int32,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index of the last occurrence of a specified string within the current <xref href="System.String"></xref> object. The search starts at a specified character position and proceeds backward toward the beginning of the string. A parameter specifies the type of comparison to perform when searching for the specified string.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  \n  \n The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.  \n  \n The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules."
  example:
  - "The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  \n  \n [!code-cs[system.string.LastIndexOfCmp#1](~/add/codesnippet/csharp/m-system.string.lastinde_2_1.cs)]\n [!code-vb[system.string.LastIndexOfCmp#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_2_1.vb)]"
  syntax:
    content: public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules for the search.
    return:
      type: System.Int32
      description: The zero-based starting index position of the <code>value</code> parameter if that string is found, or -1 if it is not found or if the current instance equals <xref href="System.String"></xref>. If <code>value</code> is <xref href="System.String"></xref>, the return value is the smaller of <code>startIndex</code> and the last index position in this instance.
  overload: System.String.LastIndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The current instance does not equal <xref href=\"System.String\"></xref>, and <code>startIndex</code> is less than zero or greater than the length of the current instance.  \n  \n -or-  \n  \n The current instance equals <xref href=\"System.String\"></xref>, and <code>startIndex</code> is less than -1 or greater than zero."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a valid <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)
  id: LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOf(String,Int32,Int32,StringComparison)
  nameWithType: String.LastIndexOf(String,Int32,Int32,StringComparison)
  fullName: System.String.LastIndexOf(String,Int32,Int32,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions. A parameter specifies the type of comparison to perform when searching for the specified string.
  remarks: "Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  \n  \n The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.  \n  \n The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules."
  example:
  - "The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  \n  \n [!code-cs[system.string.LastIndexOfCmp#1](~/add/codesnippet/csharp/ebc12778-1ccc-4a21-b937-_1.cs)]\n [!code-vb[system.string.LastIndexOfCmp#1](~/add/codesnippet/visualbasic/ebc12778-1ccc-4a21-b937-_1.vb)]"
  syntax:
    content: public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.
    - id: count
      type: System.Int32
      description: The number of character positions to examine.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that specifies the rules for the search.
    return:
      type: System.Int32
      description: The zero-based starting index position of the <code>value</code> parameter if that string is found, or -1 if it is not found or if the current instance equals <xref href="System.String"></xref>. If <code>value</code> is <xref href="System.String"></xref>, the return value is the smaller of <code>startIndex</code> and the last index position in this instance.
  overload: System.String.LastIndexOf*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>count</code> is negative.  \n  \n -or-  \n  \n The current instance does not equal <xref href=\"System.String\"></xref>, and <code>startIndex</code> is negative.  \n  \n -or-  \n  \n The current instance does not equal <xref href=\"System.String\"></xref>, and <code>startIndex</code> is greater than the length of this instance.  \n  \n -or-  \n  \n The current instance does not equal <xref href=\"System.String.Empty\"></xref>, and <code>startIndex</code> + 1 - <code>count</code> specifies a position that is not within this instance.  \n  \n -or-  \n  \n The current instance equals <xref href=\"System.String.Empty\"></xref> and <code>start</code> is less than -1 or greater than zero.  \n  \n -or-  \n  \n The current instance equals <xref href=\"System.String.Empty\"></xref> and <code>count</code> is greater than 1."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a valid <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOfAny(System.Char[])
  id: LastIndexOfAny(System.Char[])
  parent: System.String
  langs:
  - csharp
  name: LastIndexOfAny(Char[])
  nameWithType: String.LastIndexOfAny(Char[])
  fullName: System.String.LastIndexOfAny(Char[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.
  remarks: "Index numbering starts from zero.  \n  \n This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined. The search is case-sensitive.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example finds the index of the last occurrence of any character in the string \"is\" within another string.  \n  \n [!code-cpp[string.lastindexofany1#1](~/add/codesnippet/cpp/m-system.string.lastinde_3_1.cpp)]\n [!code-cs[string.lastindexofany1#1](~/add/codesnippet/csharp/m-system.string.lastinde_3_1.cs)]\n [!code-vb[string.lastindexofany1#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_3_1.vb)]"
  syntax:
    content: public int LastIndexOfAny (char[] anyOf);
    parameters:
    - id: anyOf
      type: System.Char[]
      description: A Unicode character array containing one or more characters to seek.
    return:
      type: System.Int32
      description: The index position of the last occurrence in this instance where any character in <code>anyOf</code> was found; -1 if no character in <code>anyOf</code> was found.
  overload: System.String.LastIndexOfAny*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>anyOf</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOfAny(System.Char[],System.Int32)
  id: LastIndexOfAny(System.Char[],System.Int32)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOfAny(Char[],Int32)
  nameWithType: String.LastIndexOfAny(Char[],Int32)
  fullName: System.String.LastIndexOfAny(Char[],Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array. The search starts at a specified character position and proceeds backward toward the beginning of the string.
  remarks: "Index numbering starts from zero.  \n  \n This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined. The search is case-sensitive.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example finds the index of the last occurrence of any character in the string \"is\" within a substring of another string.  \n  \n [!code-cpp[string.lastindexofany2#1](~/add/codesnippet/cpp/m-system.string.lastinde_7_1.cpp)]\n [!code-cs[string.lastindexofany2#1](~/add/codesnippet/csharp/m-system.string.lastinde_7_1.cs)]\n [!code-vb[string.lastindexofany2#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_7_1.vb)]"
  syntax:
    content: public int LastIndexOfAny (char[] anyOf, int startIndex);
    parameters:
    - id: anyOf
      type: System.Char[]
      description: A Unicode character array containing one or more characters to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.
    return:
      type: System.Int32
      description: The index position of the last occurrence in this instance where any character in <code>anyOf</code> was found; -1 if no character in <code>anyOf</code> was found or if the current instance equals <xref href="System.String.Empty"></xref>.
  overload: System.String.LastIndexOfAny*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>anyOf</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: The current instance does not equal <xref href="System.String.Empty"></xref>, and <code>startIndex</code> specifies a position that is not within this instance.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)
  id: LastIndexOfAny(System.Char[],System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: LastIndexOfAny(Char[],Int32,Int32)
  nameWithType: String.LastIndexOfAny(Char[],Int32,Int32)
  fullName: System.String.LastIndexOfAny(Char[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.
  remarks: "Index numbering starts from zero.  \n  \n This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined. The search is case-sensitive.  \n  \n This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature \"Æ\" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as \"AE\" (U+0041, U+0045), depending on the culture."
  example:
  - "The following example finds the index of the last occurrence of any character in the string \"aid\" within a substring of another string.  \n  \n [!code-cs[string.lastindexofany3#1](~/add/codesnippet/csharp/m-system.string.lastinde_1_1.cs)]\n [!code-cpp[string.lastindexofany3#1](~/add/codesnippet/cpp/m-system.string.lastinde_1_1.cpp)]\n [!code-vb[string.lastindexofany3#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_1_1.vb)]"
  syntax:
    content: public int LastIndexOfAny (char[] anyOf, int startIndex, int count);
    parameters:
    - id: anyOf
      type: System.Char[]
      description: A Unicode character array containing one or more characters to seek.
    - id: startIndex
      type: System.Int32
      description: The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.
    - id: count
      type: System.Int32
      description: The number of character positions to examine.
    return:
      type: System.Int32
      description: The index position of the last occurrence in this instance where any character in <code>anyOf</code> was found; -1 if no character in <code>anyOf</code> was found or if the current instance equals <xref href="System.String.Empty"></xref>.
  overload: System.String.LastIndexOfAny*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>anyOf</code> is `null`.
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "The current instance does not equal <xref href=\"System.String.Empty\"></xref>, and <code>count</code> or <code>startIndex</code> is negative.  \n  \n -or-  \n  \n The current instance does not equal <xref href=\"System.String.Empty\"></xref>, and <code>startIndex</code> minus <code>count</code> + 1 is less than zero."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Length
  id: Length
  parent: System.String
  langs:
  - csharp
  name: Length
  nameWithType: String.Length
  fullName: System.String.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: Gets the number of characters in the current <xref href="System.String"></xref> object.
  remarks: "The Length property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters. The reason is that a Unicode character might be represented by more than one <xref:System.Char>. Use the <xref:System.Globalization.StringInfo?displayProperty=fullName> class to work with each Unicode character instead of each <xref:System.Char>.  \n  \n In some languages, such as C and C++, a null character indicates the end of a string. In the .NET Framework, a null character can be embedded in a string. When a string includes one or more null characters, they are included in the length of the total string. For example, in the following string, the substrings \"abc\" and \"def\" are separated by a null character. The Length property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.  \n  \n [!code-vb[System.String.Class#1](~/add/codesnippet/visualbasic/p-system.string.length_1.vb)]\n [!code-cs[System.String.Class#1](~/add/codesnippet/csharp/p-system.string.length_1.cs)]\n [!code-cpp[System.String.Class#1](~/add/codesnippet/cpp/p-system.string.length_1.cpp)]"
  example:
  - "The following example demonstrates the Length property.  \n  \n [!code-cpp[string.length#1](~/add/codesnippet/cpp/p-system.string.length_2.cpp)]\n [!code-cs[string.length#1](~/add/codesnippet/csharp/p-system.string.length_2.cs)]\n [!code-vb[string.length#1](~/add/codesnippet/visualbasic/p-system.string.length_2.vb)]"
  syntax:
    content: public int Length { get; }
    return:
      type: System.Int32
      description: The number of characters in the current string.
  overload: System.String.Length*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Normalize
  id: Normalize
  parent: System.String
  langs:
  - csharp
  name: Normalize()
  nameWithType: String.Normalize()
  fullName: System.String.Normalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.
  remarks: "Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. For example, any of the following code points can represent the letter \"ắ\":  \n  \n-   U+1EAF  \n  \n-   U+0103 U+0301  \n  \n-   U+0061 U+0306 U+0301  \n  \n The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.  \n  \n The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.  \n  \n To normalize and compare two strings, do the following:  \n  \n1.  Obtain the strings to be compared from an input source, such as a file or a user input device.  \n  \n2.  Call the Normalize method to normalize the strings to normalization form C.  \n  \n3.  To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison?displayProperty=fullName> or <xref:System.StringComparison?displayProperty=fullName>as the <xref:System.StringComparison> argument. To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=fullName> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=fullName> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=fullName>.  \n  \n4.  Emit the strings in the sorted output based on the order indicated by the previous step.  \n  \n For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>."
  example:
  - "The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.  \n  \n [!code-vb[string.normalize#1](~/add/codesnippet/visualbasic/m-system.string.normalize_1.vb)]\n [!code-cpp[string.normalize#1](~/add/codesnippet/cpp/m-system.string.normalize_1.cpp)]\n [!code-cs[string.normalize#1](~/add/codesnippet/csharp/m-system.string.normalize_1.cs)]"
  syntax:
    content: public string Normalize ();
    parameters: []
    return:
      type: System.String
      description: A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.
  overload: System.String.Normalize*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The current instance contains invalid Unicode characters.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Normalize(System.Text.NormalizationForm)
  id: Normalize(System.Text.NormalizationForm)
  parent: System.String
  langs:
  - csharp
  name: Normalize(NormalizationForm)
  nameWithType: String.Normalize(NormalizationForm)
  fullName: System.String.Normalize(NormalizationForm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.
  remarks: "Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.  \n  \n The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.  \n  \n To normalize and compare two strings, do the following:  \n  \n1.  Obtain the strings to be compared from an input source, such as a file or a user input device.  \n  \n2.  Call the Normalize method to normalize the strings to a specified normalization form.  \n  \n3.  To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison?displayProperty=fullName> or <xref:System.StringComparison?displayProperty=fullName> as the <xref:System.StringComparison> argument. To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=fullName> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=fullName> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=fullName>.  \n  \n4.  Emit the strings in the sorted output based on the order indicated by the previous step.  \n  \n For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>."
  example:
  - "The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.  \n  \n [!code-vb[string.normalize#1](~/add/codesnippet/visualbasic/m-system.string.normaliz_1.vb)]\n [!code-cpp[string.normalize#1](~/add/codesnippet/cpp/m-system.string.normaliz_1.cpp)]\n [!code-cs[string.normalize#1](~/add/codesnippet/csharp/m-system.string.normaliz_1.cs)]"
  syntax:
    content: public string Normalize (System.Text.NormalizationForm normalizationForm);
    parameters:
    - id: normalizationForm
      type: System.Text.NormalizationForm
      description: A Unicode normalization form.
    return:
      type: System.String
      description: A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <code>normalizationForm</code> parameter.
  overload: System.String.Normalize*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: The current instance contains invalid Unicode characters.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.op_Equality(System.String,System.String)
  id: op_Equality(System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: op_Equality(String,String)
  nameWithType: String.op_Equality(String,String)
  fullName: System.String.op_Equality(String,String)
  type: Operator
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether two specified strings have the same value.
  remarks: "The Equality method defines the operation of the equality operator for the <xref:System.String> class. It enables code such as that shown in the Example section. The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.  \n  \n> [!NOTE]\n>  The Visual Basic compiler does not resolve the equality operator as a call to the Equality method. Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=fullName> method."
  example:
  - "The following example demonstrates the equality operator.  \n  \n [!code-cs[system.string.equality#1](~/add/codesnippet/csharp/m-system.string.op-equal_1.cs)]\n [!code-cpp[system.string.equality#1](~/add/codesnippet/cpp/m-system.string.op-equal_1.cpp)]"
  syntax:
    content: public static bool op_Equality (string a, string b);
    parameters:
    - id: a
      type: System.String
      description: The first string to compare, or `null`.
    - id: b
      type: System.String
      description: The second string to compare, or `null`.
    return:
      type: System.Boolean
      description: '`true` if the value of <code>a</code> is the same as the value of <code>b</code>; otherwise, `false`.'
  overload: System.String.op_Equality*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.op_Inequality(System.String,System.String)
  id: op_Inequality(System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: op_Inequality(String,String)
  nameWithType: String.op_Inequality(String,String)
  fullName: System.String.op_Inequality(String,String)
  type: Operator
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether two specified strings have different values.
  remarks: "The Inequality method defines the operation of the inequality operator for the <xref:System.String> class.   It enables code such as that shown in the Examples section.  \n  \n The Inequality operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.  \n  \n> [!NOTE]\n>  The Visual Basic compiler does not resolve the inequality operator as a call to the Inequality method. Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=fullName> method."
  example:
  - "The following example demonstrates the inequality operator.  \n  \n [!code-cpp[system.string.inequality#1](~/add/codesnippet/cpp/m-system.string.op-inequ_1.cpp)]\n [!code-cs[system.string.inequality#1](~/add/codesnippet/csharp/m-system.string.op-inequ_1.cs)]"
  syntax:
    content: public static bool op_Inequality (string a, string b);
    parameters:
    - id: a
      type: System.String
      description: The first string to compare, or `null`.
    - id: b
      type: System.String
      description: The second string to compare, or `null`.
    return:
      type: System.Boolean
      description: '`true` if the value of <code>a</code> is different from the value of <code>b</code>; otherwise, `false`.'
  overload: System.String.op_Inequality*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.PadLeft(System.Int32)
  id: PadLeft(System.Int32)
  parent: System.String
  langs:
  - csharp
  name: PadLeft(Int32)
  nameWithType: String.PadLeft(Int32)
  fullName: System.String.PadLeft(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.
  remarks: "A Unicode space is defined as hexadecimal 0x0020.  \n  \n The PadLeft method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.  \n  \n> [!NOTE]\n>  If the PadLeftmethod pads the current instance with whitespace characters, this method does not modify the value of the current instance. Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters."
  example:
  - "The following example demonstrates the PadLeft method.  \n  \n [!code-cs[Classic String.PadLeft Example#1](~/add/codesnippet/csharp/m-system.string.padleft-_0_1.cs)]\n [!code-vb[Classic String.PadLeft Example#1](~/add/codesnippet/visualbasic/m-system.string.padleft-_0_1.vb)]\n [!code-cpp[Classic String.PadLeft Example#1](~/add/codesnippet/cpp/m-system.string.padleft-_0_1.cpp)]"
  syntax:
    content: public string PadLeft (int totalWidth);
    parameters:
    - id: totalWidth
      type: System.Int32
      description: The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.
    return:
      type: System.String
      description: A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <code>totalWidth</code>. However, if <code>totalWidth</code> is less than the length of this instance, the method returns a reference to the existing instance. If <code>totalWidth</code> is equal to the length of this instance, the method returns a new string that is identical to this instance.
  overload: System.String.PadLeft*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>totalWidth</code> is less than zero.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.PadLeft(System.Int32,System.Char)
  id: PadLeft(System.Int32,System.Char)
  parent: System.String
  langs:
  - csharp
  name: PadLeft(Int32,Char)
  nameWithType: String.PadLeft(Int32,Char)
  fullName: System.String.PadLeft(Int32,Char)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.
  remarks: "The PadLeft method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.  \n  \n> [!NOTE]\n>  If the <xref:System.String.PadLeft%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance. Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters."
  example:
  - "The following example demonstrates the <xref:System.String.PadLeft%2A> method.  \n  \n [!code-cpp[Classic String.PadLeft1 Example#1](~/add/codesnippet/cpp/m-system.string.padleft-_1_1.cpp)]\n [!code-cs[Classic String.PadLeft1 Example#1](~/add/codesnippet/csharp/m-system.string.padleft-_1_1.cs)]\n [!code-vb[Classic String.PadLeft1 Example#1](~/add/codesnippet/visualbasic/m-system.string.padleft-_1_1.vb)]"
  syntax:
    content: public string PadLeft (int totalWidth, char paddingChar);
    parameters:
    - id: totalWidth
      type: System.Int32
      description: The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.
    - id: paddingChar
      type: System.Char
      description: A Unicode padding character.
    return:
      type: System.String
      description: A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <code>paddingChar</code> characters as needed to create a length of <code>totalWidth</code>. However, if <code>totalWidth</code> is less than the length of this instance, the method returns a reference to the existing instance. If <code>totalWidth</code> is equal to the length of this instance, the method returns a new string that is identical to this instance.
  overload: System.String.PadLeft*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>totalWidth</code> is less than zero.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.PadRight(System.Int32)
  id: PadRight(System.Int32)
  parent: System.String
  langs:
  - csharp
  name: PadRight(Int32)
  nameWithType: String.PadRight(Int32)
  fullName: System.String.PadRight(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.
  remarks: "A Unicode space is defined as hexadecimal 0x0020.  \n  \n The PadRight method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.  \n  \n> [!NOTE]\n>  If thePadRight method pads the current instance with whitespace characters, this method does not modify the value of the current instance. Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters."
  example:
  - "The following example demonstrates the PadRight method.  \n  \n [!code-cpp[Classic String.PadRight Example#1](~/add/codesnippet/cpp/m-system.string.padright_0_1.cpp)]\n [!code-vb[Classic String.PadRight Example#1](~/add/codesnippet/visualbasic/m-system.string.padright_0_1.vb)]\n [!code-cs[Classic String.PadRight Example#1](~/add/codesnippet/csharp/m-system.string.padright_0_1.cs)]"
  syntax:
    content: public string PadRight (int totalWidth);
    parameters:
    - id: totalWidth
      type: System.Int32
      description: The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.
    return:
      type: System.String
      description: A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <code>totalWidth</code>. However, if <code>totalWidth</code> is less than the length of this instance, the method returns a reference to the existing instance. If <code>totalWidth</code> is equal to the length of this instance, the method returns a new string that is identical to this instance.
  overload: System.String.PadRight*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>totalWidth</code> is less than zero.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.PadRight(System.Int32,System.Char)
  id: PadRight(System.Int32,System.Char)
  parent: System.String
  langs:
  - csharp
  name: PadRight(Int32,Char)
  nameWithType: String.PadRight(Int32,Char)
  fullName: System.String.PadRight(Int32,Char)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.
  remarks: "The PadRight method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.  \n  \n> [!NOTE]\n>  If the <xref:System.String.PadRight%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance. Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters."
  example:
  - "The following example demonstrates the <xref:System.String.PadRight%2A> method.  \n  \n [!code-vb[Classic String.PadRight1 Example#1](~/add/codesnippet/visualbasic/m-system.string.padright_1_1.vb)]\n [!code-cs[Classic String.PadRight1 Example#1](~/add/codesnippet/csharp/m-system.string.padright_1_1.cs)]\n [!code-cpp[Classic String.PadRight1 Example#1](~/add/codesnippet/cpp/m-system.string.padright_1_1.cpp)]"
  syntax:
    content: public string PadRight (int totalWidth, char paddingChar);
    parameters:
    - id: totalWidth
      type: System.Int32
      description: The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.
    - id: paddingChar
      type: System.Char
      description: A Unicode padding character.
    return:
      type: System.String
      description: A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <code>paddingChar</code> characters as needed to create a length of <code>totalWidth</code>. However, if <code>totalWidth</code> is less than the length of this instance, the method returns a reference to the existing instance. If <code>totalWidth</code> is equal to the length of this instance, the method returns a new string that is identical to this instance.
  overload: System.String.PadRight*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>totalWidth</code> is less than zero.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Remove(System.Int32)
  id: Remove(System.Int32)
  parent: System.String
  langs:
  - csharp
  name: Remove(Int32)
  nameWithType: String.Remove(Int32)
  fullName: System.String.Remove(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.
  remarks: "In the [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)], strings are zero-based. The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed."
  example:
  - "The following example demonstrates the <xref:System.String.Remove%2A> method. The next-to-last case removes all text starting from the specified index through the end of the string. The last case removes three characters starting from the specified index.  \n  \n [!code-cs[string.remove#1](~/add/codesnippet/csharp/m-system.string.remove-s_0_1.cs)]\n [!code-vb[string.remove#1](~/add/codesnippet/visualbasic/m-system.string.remove-s_0_1.vb)]\n [!code-cpp[string.remove#1](~/add/codesnippet/cpp/m-system.string.remove-s_0_1.cpp)]"
  syntax:
    content: public string Remove (int startIndex);
    parameters:
    - id: startIndex
      type: System.Int32
      description: The zero-based position to begin deleting characters.
    return:
      type: System.String
      description: A new string that is equivalent to this string except for the removed characters.
  overload: System.String.Remove*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code> is less than zero.  \n  \n -or-  \n  \n <code>startIndex</code> specifies a position that is not within this string."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Remove(System.Int32,System.Int32)
  id: Remove(System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: Remove(Int32,Int32)
  nameWithType: String.Remove(Int32,Int32)
  fullName: System.String.Remove(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.
  remarks: "In the [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)], strings are zero-based. The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed. The characters are removed at the position specified by `startIndex`."
  example:
  - "The following example demonstrates how you can remove the middle name from a complete name.  \n  \n [!code-cpp[stringremove#1](~/add/codesnippet/cpp/m-system.string.remove-s_1_1.cpp)]\n [!code-cs[stringremove#1](~/add/codesnippet/csharp/m-system.string.remove-s_1_1.cs)]\n [!code-vb[stringremove#1](~/add/codesnippet/visualbasic/m-system.string.remove-s_1_1.vb)]"
  syntax:
    content: public string Remove (int startIndex, int count);
    parameters:
    - id: startIndex
      type: System.Int32
      description: The zero-based position to begin deleting characters.
    - id: count
      type: System.Int32
      description: The number of characters to delete.
    return:
      type: System.String
      description: A new string that is equivalent to this instance except for the removed characters.
  overload: System.String.Remove*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "Either <code>startIndex</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>startIndex</code> plus <code>count</code> specify a position outside this instance."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Replace(System.Char,System.Char)
  id: Replace(System.Char,System.Char)
  parent: System.String
  langs:
  - csharp
  name: Replace(Char,Char)
  nameWithType: String.Replace(Char,Char)
  fullName: System.String.Replace(Char,Char)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.
  remarks: "This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.  \n  \n Because this method returns the modified string, you can chain together successive calls to the Replace method to perform multiple replacements on the original string. Method calls are executed from left to right. The following example provides an illustration.  \n  \n [!code-cs[System.String.Replace#2](~/add/codesnippet/csharp/m-system.string.replace-_1_1.cs)]\n [!code-vb[System.String.Replace#2](~/add/codesnippet/visualbasic/m-system.string.replace-_1_1.vb)]"
  example:
  - "The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.  \n  \n [!code-cpp[string.replace1#1](~/add/codesnippet/cpp/m-system.string.replace-_1_2.cpp)]\n [!code-cs[string.replace1#1](~/add/codesnippet/csharp/m-system.string.replace-_1_2.cs)]\n [!code-vb[string.replace1#1](~/add/codesnippet/visualbasic/m-system.string.replace-_1_2.vb)]"
  syntax:
    content: public string Replace (char oldChar, char newChar);
    parameters:
    - id: oldChar
      type: System.Char
      description: The Unicode character to be replaced.
    - id: newChar
      type: System.Char
      description: The Unicode character to replace all occurrences of `oldChar`.
    return:
      type: System.String
      description: A string that is equivalent to this instance except that all instances of <code>oldChar</code> are replaced with <code>newChar</code>. If <code>oldChar</code> is not found in the current instance, the method returns the current instance unchanged.
  overload: System.String.Replace*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Replace(System.String,System.String)
  id: Replace(System.String,System.String)
  parent: System.String
  langs:
  - csharp
  name: Replace(String,String)
  nameWithType: String.Replace(String,String)
  fullName: System.String.Replace(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.
  remarks: "If `newValue` is `null`, all occurrences of `oldValue` are removed.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.  \n  \n This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.  \n  \n Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string. Method calls are executed from left to right. The following example provides an illustration.  \n  \n [!code-cs[System.String.Replace#1](~/add/codesnippet/csharp/m-system.string.replace-_0_1.cs)]\n [!code-vb[System.String.Replace#1](~/add/codesnippet/visualbasic/m-system.string.replace-_0_1.vb)]"
  example:
  - "The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.  \n  \n [!code-cpp[stringreplace#1](~/add/codesnippet/cpp/m-system.string.replace-_0_2.cpp)]\n [!code-cs[stringreplace#1](~/add/codesnippet/csharp/m-system.string.replace-_0_2.cs)]\n [!code-vb[stringreplace#1](~/add/codesnippet/visualbasic/m-system.string.replace-_0_2.vb)]"
  syntax:
    content: public string Replace (string oldValue, string newValue);
    parameters:
    - id: oldValue
      type: System.String
      description: The string to be replaced.
    - id: newValue
      type: System.String
      description: The string to replace all occurrences of `oldValue`.
    return:
      type: System.String
      description: A string that is equivalent to the current string except that all instances of <code>oldValue</code> are replaced with <code>newValue</code>. If <code>oldValue</code> is not found in the current instance, the method returns the current instance unchanged.
  overload: System.String.Replace*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>oldValue</code> is `null`.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>oldValue</code> is the empty string ("").
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Split(System.Char[])
  id: Split(System.Char[])
  parent: System.String
  langs:
  - csharp
  name: Split(Char[])
  nameWithType: String.Split(Char[])
  fullName: System.String.Split(Char[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Splits a string into substrings that are based on the characters in an array.
  remarks: "When a string is delimited by a known set of characters, you can use the Split method to separate it into substrings. For other ways to extract substrings from a string, see the [Alternatives to String.Split](#Alternatives) section.  \n  \n## Return value details  \n Delimiter characters are not included in the elements of the returned array. For example, if the separator array includes the character \"-\" and the value of the current string instance is \"aa-bb-cc\", the method returns an array that contains three elements: \"aa\", \"bb\", and \"cc\".  \n  \n If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.  \n  \n Each element of `separator` defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String>. Here are some examples:  \n  \n|String value|Separator|Returned array|  \n|------------------|---------------|--------------------|  \n|\"42, 12, 19\"|new Char[] {',', ' '} (C#)<br /><br /> Char() = {\",\"c, \" \"c}) (Visual Basic)|{\"42\", \"\", \"12\", \"\", \"19\"}|  \n|\"42..12..19\"|new Char[] {'.'} (C#)<br /><br /> Char() = {\".\"c} (Visual Basic)|{\"42\", \"\", \"12\", \"\", \"19\"}|  \n|\"Banana\"|new Char[] {'.'} (C#)<br /><br /> Char() = {\".\"c} (Visual Basic)|{\"Banana\"}|  \n|\"Darb\\nSmarba\" (C#)<br /><br /> \"Darb\" & vbLf & \"Smarba\" (Visual Basic)|new Char[] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{\"Darb\", \"Smarba\"}|  \n|\"Darb\\nSmarba\" (C#)<br /><br /> \"Darb\" & vbLf & \"Smarba\" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{\"Darb\", \"Smarba\"}|  \n  \n## The separator array  \n Each element of separator defines a separate delimiter that consists of a single character. If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters. White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  \n  \n## String.Split(Char[]) and compiler overload resolution  \n Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=fullName> is a character array, you can call it with a single character, as the following example shows.  \n  \n [!code-cs[System.String.Split#12](~/add/codesnippet/csharp/m-system.string.split-sy_3_1.cs)]\n [!code-vb[System.String.Split#12](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_1.vb)]  \n  \n Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array. This is not the case for other <xref:System.String.Split%2A?displayProperty=fullName> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.  \n  \n## Comparison details  \n The Split method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.  \n  \n The Split method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration.  \n  \n<a name=\"Alternatives\"></a>   \n## Alternatives to String.Split  \n The Split method is not always the best way to break a delimited string into substrings. If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.  \n  \n### Regular expressions  \n If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements. For example, if strings take the form \"*number* *operand* *number*\" you can use a [regular expression](~/add/includes/ajax-current-ext-md.md) to extract and handle the string's elements. Here's an example:  \n  \n [!code-cs[System.String.Split#8](~/add/codesnippet/csharp/m-system.string.split-sy_3_2.cs)]\n [!code-vb[System.String.Split#8](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_2.vb)]  \n  \n The regular expression pattern `(\\d+)\\s+([-+*/])\\s+(\\d+)` is defined like this:  \n  \n|Pattern|Description|  \n|-------------|-----------------|  \n|`(\\d+)`|Match one or more decimal digits. This is the first capturing group.|  \n|`\\s+`|Match one or more whitespace characters.|  \n|`([-+*/])`|Match an arithmetic operator sign (+, -, *, or /). This is the second capturing group.|  \n|`\\s+`|Match one or more whitespace characters.|  \n|`(\\d+)`|Match one or more decimal digits. This is the third capturing group.|  \n  \n You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters. This is a common scenario when either of these conditions occurs:  \n  \n-   One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.  \n  \n-   The sequence and number of delimiter characters is variable or unknown.  \n  \n For example, the Split method cannot be used to split the following string, because the number of `\\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they do not always serve as delimiters.  \n  \n```  \n  \n[This is captured\\ntext.]\\n\\n[\\n[This is more captured text.]\\n]  \n\\n[Some more captured text:\\n   Option1\\n   Option2][Terse text.]  \n  \n```  \n  \n A regular expression can split this string easily, as the following example shows.  \n  \n [!code-cs[System.String.Split#9](~/add/codesnippet/csharp/m-system.string.split-sy_3_3.cs)]\n [!code-vb[System.String.Split#9](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_3.vb)]  \n  \n The regular expression pattern `\\[([^\\[\\]]+)\\]` is defined like this:  \n  \n|Pattern|Description|  \n|-------------|-----------------|  \n|`\\[`|Match an opening bracket.|  \n|`([^\\[\\]]+)`|Match any character that is not an opening or a closing bracket one or more times. This is the first capturing group.|  \n|`\\]`|Match a closing bracket.|  \n  \n The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName> method is almost identical to Split, except that it splits a string based on a regular expression pattern instead of a fixed character set. For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName>method to split a string that contains substrings delimited by various combinations of hyphens and other characters.  \n  \n [!code-vb[System.String.Split#10](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_4.vb)]\n [!code-cs[System.String.Split#10](~/add/codesnippet/csharp/m-system.string.split-sy_3_4.cs)]  \n  \n The regular expression pattern `\\s-\\s?[+*]?\\s?-\\s` is defined like this:  \n  \n|Pattern|Description|  \n|-------------|-----------------|  \n|`\\s-`|Match a whitespace character followed by a hyphen.|  \n|`\\s?`|Match zero or one whitespace character.|  \n|`[+*]?`|Match zero or one occurrence of either the + or * character.|  \n|`\\s?`|Match zero or one whitespace character.|  \n|`-\\s`|Match a hyphen followed by a whitespace character.|  \n  \n### Search methods and the Substring method  \n If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins. You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want. The string comparison methods include:  \n  \n-   <xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.  \n  \n-   <xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.  \n  \n-   <xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.  \n  \n-   <xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.  \n  \n The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string. It then uses the <xref:System.String.Substring%2A> method to return full sentences.  \n  \n [!code-cs[System.String.Split#11](~/add/codesnippet/csharp/m-system.string.split-sy_3_5.cs)]\n [!code-vb[System.String.Split#11](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_5.vb)]  \n  \n## Performance Considerations  \n The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method. You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.  \n  \n To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  \n  \n In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call."
  example:
  - "The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters. The character array passed to the `separator` parameter of the Split method consists of a space character and a tab character, together with some common punctuation symbols.  \n  \n [!code-cs[System.String.Split#2](~/add/codesnippet/csharp/m-system.string.split-sy_3_6.cs)]\n [!code-vb[System.String.Split#2](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_6.vb)]"
  syntax:
    content: public string[] Split (char[] separator);
    parameters:
    - id: separator
      type: System.Char[]
      description: A character array that delimits the substrings in this string, an empty array that contains no delimiters, or `null`.
    return:
      type: System.String[]
      description: An array whose elements contain the substrings from this instance that are delimited by one or more characters in <code>separator</code>. For more information, see the Remarks section.
  overload: System.String.Split*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Split(System.Char[],System.Int32)
  id: Split(System.Char[],System.Int32)
  parent: System.String
  langs:
  - csharp
  name: Split(Char[],Int32)
  nameWithType: String.Split(Char[],Int32)
  fullName: System.String.Split(Char[],Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Splits a string into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.
  remarks: "Delimiter characters are not included in the elements of the returned array.  \n  \n If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance. If `count` is zero, an empty array is returned.  \n  \n If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  \n  \n Each element of `separator` defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.  \n  \n If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.  \n  \n If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.  \n  \n The following table provides examples.  \n  \n|String value|Separator|Count|Returned array|  \n|------------------|---------------|-----------|--------------------|  \n|\"42, 12, 19\"|new Char[] {',', ' '} (C#)<br /><br /> Char() = {\",\"c, \" \"c} (Visual Basic)|2|{\"42\", \" 12, 19\"}|  \n|\"42..12..19\"|new Char[] {'.'} (C#)<br /><br /> Char() = {\".\"c} (Visual Basic)|4|{\"42\", \"\", \"12\", \".19\"}|  \n|\"Banana\"|new Char[] {'.'} (C#)<br /><br /> Char() = {\".\"c} (Visual Basic)|2|{\"Banana\"}|  \n|\"Darb\\nSmarba\" (C#)<br /><br /> \"Darb\" & vbLf & \"Smarba\" (Visual Basic)|new Char[] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{\"Darb\\nSmarba\"} (C#)<br /><br /> \"Darb\" & vbLf & \"Smarba\" (Visual Basic)|  \n|\"Darb\\nSmarba\" (C#)<br /><br /> \"Darb\" & vbLf & \"Smarba\" (Visual Basic)|new Char[] null (C#)<br /><br /> Char() = Nothing|2|{\"Darb\", \"Smarba\"}|  \n|\"Darb\\nSmarba\" (C#)<br /><br /> \"Darb\" & vbLf & \"Smarba\" (Visual Basic)|new Char[] null (C#)<br /><br /> Char() = Nothing|100|{\"Darb\", \"Smarba\"}|  \n  \n## Performance Considerations  \n The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  \n  \n If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  \n  \n In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call."
  example:
  - "The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.  \n  \n [!code-cs[StringSplit2#10](~/add/codesnippet/csharp/m-system.string.split-sy_2_1.cs)]\n [!code-vb[StringSplit2#10](~/add/codesnippet/visualbasic/m-system.string.split-sy_2_1.vb)]"
  syntax:
    content: public string[] Split (char[] separator, int count);
    parameters:
    - id: separator
      type: System.Char[]
      description: A character array that delimits the substrings in this string, an empty array that contains no delimiters, or `null`.
    - id: count
      type: System.Int32
      description: The maximum number of substrings to return.
    return:
      type: System.String[]
      description: An array whose elements contain the substrings in this instance that are delimited by one or more characters in <code>separator</code>. For more information, see the Remarks section.
  overload: System.String.Split*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>count</code> is negative.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Split(System.Char[],System.StringSplitOptions)
  id: Split(System.Char[],System.StringSplitOptions)
  parent: System.String
  langs:
  - csharp
  name: Split(Char[],StringSplitOptions)
  nameWithType: String.Split(Char[],StringSplitOptions)
  fullName: System.String.Split(Char[],StringSplitOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Splits a string into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.
  remarks: "## Return value details  \n Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array. For example, if the `separator` array includes the character \"-\" and the value of the current string instance is \"aa-bb-cc\", the method returns an array that contains three elements: \"aa\", \"bb\", and \"cc\".  \n  \n If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.  \n  \n If the `options` parameter is <xref:System.StringSplitOptions> and the length of this instance is zero, the method returns an empty array.  \n  \n Each element of `separator` defines a separate delimiter that consists of a single character. If the `options` argument is <xref:System.StringSplitOptions>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String?displayProperty=fullName>. For example, if `separator` includes  two elements, \"-\" and \"_\", the value of the string instance is \"-_aa-\\_\", and the value of   the `options` argument is <xref:System.StringSplitOptions>, the method returns a string array with the following five elements:  \n  \n1.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that precedes the \"-\" character at index 0.  \n  \n2.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string between the \"-\" character at index 0 and the \"_\" character at index 1.  \n  \n3.  \"aa\",  \n  \n4.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that follows the \"_\" character at index 4.  \n  \n5.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that follows the \"-\" character at index 5.  \n  \n## The separator array  \n If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  \n  \n If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the `null`. The following example shows several ways to unambiguously identify this overload.  \n  \n [!code-vb[System.String.Split#5](~/add/codesnippet/visualbasic/m-system.string.split-sy_5_1.vb)]\n [!code-cs[System.String.Split#5](~/add/codesnippet/csharp/m-system.string.split-sy_5_1.cs)]  \n  \n## Comparison details  \n The Split method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.  \n  \n The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration.  \n  \n## Performance Considerations  \n The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  \n  \n If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  \n  \n In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call."
  example:
  - "The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.  \n  \n [!code-cs[string.split3#1](~/add/codesnippet/csharp/m-system.string.split-sy_5_2.cs)]\n [!code-vb[string.split3#1](~/add/codesnippet/visualbasic/m-system.string.split-sy_5_2.vb)]\n [!code-cpp[string.split3#1](~/add/codesnippet/cpp/m-system.string.split-sy_5_2.cpp)]"
  syntax:
    content: public string[] Split (char[] separator, StringSplitOptions options);
    parameters:
    - id: separator
      type: System.Char[]
      description: A character array that delimits the substrings in this string, an empty array that contains no delimiters, or `null`.
    - id: options
      type: System.StringSplitOptions
      description: <xref href="System.StringSplitOptions"></xref> to omit empty array elements from the array returned; or <xref href="System.StringSplitOptions"></xref> to include empty array elements in the array returned.
    return:
      type: System.String[]
      description: An array whose elements contain the substrings in this string that are delimited by one or more characters in <code>separator</code>. For more information, see the Remarks section.
  overload: System.String.Split*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>options</code> is not one of the <xref href="System.StringSplitOptions"></xref> values.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Split(System.String[],System.StringSplitOptions)
  id: Split(System.String[],System.StringSplitOptions)
  parent: System.String
  langs:
  - csharp
  name: Split(String[],StringSplitOptions)
  nameWithType: String.Split(String[],StringSplitOptions)
  fullName: System.String.Split(String[],StringSplitOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Splits a string into substrings based on the strings in an array. You can specify whether the substrings include empty array elements.
  remarks: "When a string is delimited by a known set of strings, you can use the Split method to separate it into substrings.  \n  \n## Return value details  \n Delimiter strings are not included in the elements of the returned array. For example, if the `separator` array includes the string \"--\" and the value of the current string instance is \"aa--bb-cc\", the method returns an array that contains three elements: \"aa\", \"bb\", and \"cc\".  \n  \n If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.  \n  \n If the `options` parameter is <xref:System.StringSplitOptions> and the length of this instance is zero, the method returns an empty array.  \n  \n Each element of `separator` defines a separate delimiter that consists of one or more characters. If the `options` argument is <xref:System.StringSplitOptions>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String?displayProperty=fullName>. For example, if `separator` includes  two elements, \"-\" and \"_\", the value of the string instance is \"-_aa-\\_\", and the value of   the `options` argument is <xref:System.StringSplitOptions>, the method returns a sting array with the following five elements:  \n  \n1.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that precedes the \"-\" substring at index 0.  \n  \n2.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string between the \"-\" substring at index 0 and the \"_\" substring at index 1.  \n  \n3.  \"aa\",  \n  \n4.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that follows the \"_\" substring at index 4.  \n  \n5.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that follows the \"-\" substring at index 5.  \n  \n## The separator array  \n If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter. For example, if one of the elements in `separator` is \"10\", attempting to split the string \"This10is10a10string.\" returns the following four-element array: { \"This\", \"is\", \"a\", \"string.\" }.  \n  \n If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  \n  \n If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the `null`. The following example shows several ways to unambiguously identify this overload.  \n  \n [!code-vb[System.String.Split#6](~/add/codesnippet/visualbasic/m-system.string.split-sy_4_1.vb)]\n [!code-cs[System.String.Split#6](~/add/codesnippet/csharp/m-system.string.split-sy_4_1.cs)]  \n  \n## Comparison details  \n The Split method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.  \n  \n The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration.  \n  \n The Split method ignores any element of `separator` whose value is `null` or the empty string (\"\").  \n  \n To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance. The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.  \n  \n For example, consider an instance whose value is \"abcdef\". If the first element in `separator` was \"ef\" and the second element was \"bcde\", the result of the split operation would be a string array that contains two elements, \"a\" and \"f\". This is because the substring in the instance, \"bcde\", is encountered and matches an element in `separator` before the substring \"f\" is encountered.  \n  \n However, if the first element of `separator` was \"bcd\" and the second element was \"bc\", the result of the split operation would be a string array that contains two elements, \"a\" and \"ef\". This is because \"bcd\" is the first delimiter in `separator` that matches a delimiter in the instance. If the order of the separators was reversed so the first element was \"bc\" and the second element was \"bcd\", the result would be a string array that contains two elements,  \"a\" and \"def\".  \n  \n## Performance considerations  \n The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  \n  \n If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  \n  \n In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call."
  example:
  - "The following example illustrates the difference in the arrays returned by calling a string's Split method with its `options` parameter equal to <xref:System.StringSplitOptions?displayProperty=fullName> and <xref:System.StringSplitOptions?displayProperty=fullName>.  \n  \n [!code-cs[System.String.Split#1](~/add/codesnippet/csharp/m-system.string.split-sy_4_2.cs)]\n [!code-vb[System.String.Split#1](~/add/codesnippet/visualbasic/m-system.string.split-sy_4_2.vb)]  \n  \n The following example defines an array of separators that include punctuation and white-space characters. Passing this array along with a value of <xref:System.StringSplitOptions?displayProperty=fullName> to the Split method returns an array that consists of the individual words from the string.  \n  \n [!code-vb[System.String.Split#7](~/add/codesnippet/visualbasic/m-system.string.split-sy_4_3.vb)]\n [!code-cs[System.String.Split#7](~/add/codesnippet/csharp/m-system.string.split-sy_4_3.cs)]  \n  \n Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions?displayProperty=fullName>. This prevents the returned array from including<xref:System.String.Empty?displayProperty=fullName> values that represent empty substring matches between punctuation marks and white-space characters."
  syntax:
    content: public string[] Split (string[] separator, StringSplitOptions options);
    parameters:
    - id: separator
      type: System.String[]
      description: A string array that delimits the substrings in this string, an empty array that contains no delimiters, or `null`.
    - id: options
      type: System.StringSplitOptions
      description: <xref href="System.StringSplitOptions"></xref> to omit empty array elements from the array returned; or <xref href="System.StringSplitOptions"></xref> to include empty array elements in the array returned.
    return:
      type: System.String[]
      description: An array whose elements contain the substrings in this string that are delimited by one or more strings in <code>separator</code>. For more information, see the Remarks section.
  overload: System.String.Split*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>options</code> is not one of the <xref href="System.StringSplitOptions"></xref> values.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)
  id: Split(System.Char[],System.Int32,System.StringSplitOptions)
  parent: System.String
  langs:
  - csharp
  name: Split(Char[],Int32,StringSplitOptions)
  nameWithType: String.Split(Char[],Int32,StringSplitOptions)
  fullName: System.String.Split(Char[],Int32,StringSplitOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Splits a string into a maximum number of substrings based on the characters in an array.
  remarks: "Delimiter characters are not included in the elements of the returned array.  \n  \n If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance. If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method. However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the null. The following example shows several ways to unambiguously identify this overload.  \n  \n [!code-vb[System.String.Split#3](~/add/codesnippet/visualbasic/m-system.string.split-sy_0_1.vb)]\n [!code-cs[System.String.Split#3](~/add/codesnippet/csharp/m-system.string.split-sy_0_1.cs)]  \n  \n If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions> and the length of this instance is zero, an empty array is returned.  \n  \n Each element of `separator` defines a separate delimiter character. If the `options` parameter is <xref:System.StringSplitOptions>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.  \n  \n If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.  \n  \n If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.  \n  \n## Performance Considerations  \n The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  \n  \n If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  \n  \n In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call."
  example:
  - "The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.  \n  \n [!code-cs[string.split3#1](~/add/codesnippet/csharp/m-system.string.split-sy_0_2.cs)]\n [!code-vb[string.split3#1](~/add/codesnippet/visualbasic/m-system.string.split-sy_0_2.vb)]\n [!code-cpp[string.split3#1](~/add/codesnippet/cpp/m-system.string.split-sy_0_2.cpp)]"
  syntax:
    content: public string[] Split (char[] separator, int count, StringSplitOptions options);
    parameters:
    - id: separator
      type: System.Char[]
      description: A character array that delimits the substrings in this string, an empty array that contains no delimiters, or `null`.
    - id: count
      type: System.Int32
      description: The maximum number of substrings to return.
    - id: options
      type: System.StringSplitOptions
      description: <xref href="System.StringSplitOptions"></xref> to omit empty array elements from the array returned; or <xref href="System.StringSplitOptions"></xref> to include empty array elements in the array returned.
    return:
      type: System.String[]
      description: An array whose elements contain the substrings in this string that are delimited by one or more characters in <code>separator</code>. For more information, see the Remarks section.
  overload: System.String.Split*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>count</code> is negative.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>options</code> is not one of the <xref href="System.StringSplitOptions"></xref> values.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Split(System.String[],System.Int32,System.StringSplitOptions)
  id: Split(System.String[],System.Int32,System.StringSplitOptions)
  parent: System.String
  langs:
  - csharp
  name: Split(String[],Int32,StringSplitOptions)
  nameWithType: String.Split(String[],Int32,StringSplitOptions)
  fullName: System.String.Split(String[],Int32,StringSplitOptions)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Splits a string into a maximum number of substrings based on the strings in an array. You can specify whether the substrings include empty array elements.
  remarks: "## Return value details  \n Delimiter strings are not included in the elements of the returned array.  \n  \n If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance. If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method. However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the `null`. The following example shows several ways to unambiguously identify this overload.  \n  \n [!code-vb[System.String.Split#4](~/add/codesnippet/visualbasic/m-system.string.split-sy_1_1.vb)]\n [!code-cs[System.String.Split#4](~/add/codesnippet/csharp/m-system.string.split-sy_1_1.cs)]  \n  \n If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions> and the length of this instance is zero, an empty array is returned.  \n  \n Each element of `separator` defines a separate delimiter that consists of one or more characters. If the `options` parameter is <xref:System.StringSplitOptions>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.  \n  \n If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.  \n  \n If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.  \n  \n## The separator array  \n If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter. For example, if one of the elements in `separator` is \"10\", attempting to split the string \"This10is10a10string.\" returns this four-element array: { \"This\", \"is\", \"a\", \"string.\" }.  \n  \n## Comparison details  \n The Split method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.  \n  \n The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration.  \n  \n The Split method ignores any element of `separator` whose value is `null` or the empty string (\"\").  \n  \n To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance. The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.  \n  \n For example, consider an instance whose value is \"abcdef\". If the first element in `separator` was \"ef\" and the second element was \"bcde\", the result of the split operation would be \"a\" and \"f\". This is because the substring in the instance, \"bcde\", is encountered and matches an element in `separator` before the substring \"f\" is encountered.  \n  \n However, if the first element of `separator` was \"bcd\" and the second element was \"bc\", the result of the split operation would be \"a\" and \"ef\". This is because \"bcd\" is the first delimiter in `separator` that matches a delimiter in the instance. If the order of the separators was reversed so the first element was \"bc\" and the second element was \"bcd\", the result would be \"a\" and \"def\".  \n  \n## Performance considerations  \n The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  \n  \n If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  \n  \n In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call."
  example:
  - "The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.  \n  \n [!code-cs[string.split3#1](~/add/codesnippet/csharp/m-system.string.split-sy_1_2.cs)]\n [!code-vb[string.split3#1](~/add/codesnippet/visualbasic/m-system.string.split-sy_1_2.vb)]\n [!code-cpp[string.split3#1](~/add/codesnippet/cpp/m-system.string.split-sy_1_2.cpp)]"
  syntax:
    content: public string[] Split (string[] separator, int count, StringSplitOptions options);
    parameters:
    - id: separator
      type: System.String[]
      description: A string array that delimits the substrings in this string, an empty array that contains no delimiters, or `null`.
    - id: count
      type: System.Int32
      description: The maximum number of substrings to return.
    - id: options
      type: System.StringSplitOptions
      description: <xref href="System.StringSplitOptions"></xref> to omit empty array elements from the array returned; or <xref href="System.StringSplitOptions"></xref> to include empty array elements in the array returned.
    return:
      type: System.String[]
      description: An array whose elements contain the substrings in this string that are delimited by one or more strings in <code>separator</code>. For more information, see the Remarks section.
  overload: System.String.Split*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>count</code> is negative.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>options</code> is not one of the <xref href="System.StringSplitOptions"></xref> values.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.StartsWith(System.String)
  id: StartsWith(System.String)
  parent: System.String
  langs:
  - csharp
  name: StartsWith(String)
  nameWithType: String.StartsWith(String)
  fullName: System.String.StartsWith(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether the beginning of this string instance matches the specified string.
  remarks: "This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal. To be equal, `value` must be an empty string (<xref:System.String?displayProperty=fullName>), must be a reference to this same instance, or must match the beginning of this instance.  \n  \n This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture."
  example:
  - "The following example defines a `StripStartTags` method that uses the StartsWith method to remove HTML start tags from the beginning of a string. Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed. The example does not remove HTML tags embedded in a string.  \n  \n [!code-cpp[stringstartswith#1](~/add/codesnippet/cpp/m-system.string.startswi_1_1.cpp)]\n [!code-vb[stringstartswith#1](~/add/codesnippet/visualbasic/m-system.string.startswi_1_1.vb)]\n [!code-cs[stringstartswith#1](~/add/codesnippet/csharp/m-system.string.startswi_1_1.cs)]"
  syntax:
    content: public bool StartsWith (string value);
    parameters:
    - id: value
      type: System.String
      description: The string to compare.
    return:
      type: System.Boolean
      description: '`true` if <code>value</code> matches the beginning of this string; otherwise, `false`.'
  overload: System.String.StartsWith*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.StartsWith(System.String,System.StringComparison)
  id: StartsWith(System.String,System.StringComparison)
  parent: System.String
  langs:
  - csharp
  name: StartsWith(String,StringComparison)
  nameWithType: String.StartsWith(String,StringComparison)
  fullName: System.String.StartsWith(String,StringComparison)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.
  remarks: The StartsWith method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal. To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string. The type of comparison performed by the StartsWith method depends on the value of the `comparisonType` parameter. The comparison can use the conventions of the current culture (<xref:System.StringComparison?displayProperty=fullName> and <xref:System.StringComparison?displayProperty=fullName>) or the invariant culture (<xref:System.StringComparison?displayProperty=fullName> and <xref:System.StringComparison?displayProperty=fullName>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison?displayProperty=fullName> or <xref:System.StringComparison?displayProperty=fullName>). The comparison can also be case-sensitive (<xref:System.StringComparison?displayProperty=fullName>, <xref:System.StringComparison?displayProperty=fullName>, or <xref:System.StringComparison?displayProperty=fullName>), or it can ignore case (<xref:System.StringComparison?displayProperty=fullName>, <xref:System.StringComparison?displayProperty=fullName>, <xref:System.StringComparison?displayProperty=fullName>).
  example:
  - "The following example searches for the string \"the\" at the beginning of a longer string that begins with the word \"The\". As the output from the example shows, a call to the StartsWith method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.  \n  \n [!code-cs[System.String.StartsWith#2](~/add/codesnippet/csharp/m-system.string.startswi_0_1.cs)]\n [!code-cpp[System.String.StartsWith#2](~/add/codesnippet/cpp/m-system.string.startswi_0_1.cpp)]\n [!code-vb[System.String.StartsWith#2](~/add/codesnippet/visualbasic/m-system.string.startswi_0_1.vb)]  \n  \n The following example determines whether a string starts with a particular substring. It initializes a two-dimensional string array. The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string. The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed. Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.  \n  \n [!code-cs[System.String.StartsWith#1](~/add/codesnippet/csharp/m-system.string.startswi_0_2.cs)]\n [!code-cpp[System.String.StartsWith#1](~/add/codesnippet/cpp/m-system.string.startswi_0_2.cpp)]\n [!code-vb[System.String.StartsWith#1](~/add/codesnippet/visualbasic/m-system.string.startswi_0_2.vb)]"
  syntax:
    content: public bool StartsWith (string value, StringComparison comparisonType);
    parameters:
    - id: value
      type: System.String
      description: The string to compare.
    - id: comparisonType
      type: System.StringComparison
      description: One of the enumeration values that determines how this string and `value` are compared.
    return:
      type: System.Boolean
      description: '`true` if this instance begins with <code>value</code>; otherwise, `false`.'
  overload: System.String.StartsWith*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: <code>comparisonType</code> is not a <xref href="System.StringComparison"></xref> value.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)
  id: StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)
  parent: System.String
  langs:
  - csharp
  name: StartsWith(String,Boolean,CultureInfo)
  nameWithType: String.StartsWith(String,Boolean,CultureInfo)
  fullName: System.String.StartsWith(String,Boolean,CultureInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.
  remarks: "This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal. To be equal, `value` must be an empty string (<xref:System.String?displayProperty=fullName>), must be a reference to this same instance, or must match the beginning of this instance.  \n  \n This method performs a comparison using the specified casing and culture."
  example:
  - "The following example determines whether a string occurs at the beginning of another string. The StartsWith method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.  \n  \n [!code-vb[system.string.StartsWithCI#1](~/add/codesnippet/visualbasic/372b987b-05c6-4c5f-99d3-_1.vb)]\n [!code-cs[system.string.StartsWithCI#1](~/add/codesnippet/csharp/372b987b-05c6-4c5f-99d3-_1.cs)]"
  syntax:
    content: public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);
    parameters:
    - id: value
      type: System.String
      description: The string to compare.
    - id: ignoreCase
      type: System.Boolean
      description: '`true` to ignore case during the comparison; otherwise, `false`.'
    - id: culture
      type: System.Globalization.CultureInfo
      description: Cultural information that determines how this string and `value` are compared. If `culture` is `null`, the current culture is used.
    return:
      type: System.Boolean
      description: '`true` if the <code>value</code> parameter matches the beginning of this string; otherwise, `false`.'
  overload: System.String.StartsWith*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>value</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Substring(System.Int32)
  id: Substring(System.Int32)
  parent: System.String
  langs:
  - csharp
  name: Substring(Int32)
  nameWithType: String.Substring(Int32)
  fullName: System.String.Substring(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Retrieves a substring from this instance. The substring starts at a specified character position and continues to the end of the string.
  remarks: "You call the Substring method to extract a substring from a string that begins at a specified character position and ends at the end of the string. The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1. To extract a substring that begins at a specified character position and ends before to the end of the string, call the <xref:System.String.Substring%2A> method.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string that begins at the `startIndex` position in the current string.  \n  \n To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`. The second example illustrates this; it extracts a key value that begins one character position after the \"=\" character.  \n  \n If `startIndex` is equal to zero, the method returns the original string unchanged."
  example:
  - "The following example demonstrates obtaining a substring from a string.  \n  \n [!code-cpp[System.String.Substring#10](~/add/codesnippet/cpp/m-system.string.substrin_1_1.cpp)]\n [!code-vb[System.String.Substring#10](~/add/codesnippet/visualbasic/m-system.string.substrin_1_1.vb)]\n [!code-cs[System.String.Substring#10](~/add/codesnippet/csharp/m-system.string.substrin_1_1.cs)]  \n  \n The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals (\"=\") character.  \n  \n [!code-cs[System.String.Substring#1](~/add/codesnippet/csharp/m-system.string.substrin_1_2.cs)]\n [!code-vb[System.String.Substring#1](~/add/codesnippet/visualbasic/m-system.string.substrin_1_2.vb)]  \n  \n The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.. The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method. The call to the Substring method then extracts the value assigned to the key. It starts at one character position beyond the equals character and extends to the end of the string."
  syntax:
    content: public string Substring (int startIndex);
    parameters:
    - id: startIndex
      type: System.Int32
      description: The zero-based starting character position of a substring in this instance.
    return:
      type: System.String
      description: A string that is equivalent to the substring that begins at <code>startIndex</code> in this instance, or <xref href="System.String"></xref> if <code>startIndex</code> is equal to the length of this instance.
  overload: System.String.Substring*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: <code>startIndex</code> is less than zero or greater than the length of this instance.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Substring(System.Int32,System.Int32)
  id: Substring(System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: Substring(Int32,Int32)
  nameWithType: String.Substring(Int32,Int32)
  fullName: System.String.Substring(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.
  remarks: "You call the Substring method to extract a substring from a string that begins at a specified character position and ends before the end of the string. The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1. To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.  \n  \n The `length` parameter represents the total number of characters to extract from the current string instance. This includes the starting character found at index  `startIndex`.  In other words, the Substring method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.  \n  \n To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.  \n  \n If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.  You can then convert that value to an index position in the string as follows:  \n  \n-   If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method. The following example extracts a continuous block of \"b\" characters from a string.  \n  \n     [!code-vb[System.String.Substring#2](~/add/codesnippet/visualbasic/m-system.string.substrin_0_1.vb)]\n     [!code-cs[System.String.Substring#2](~/add/codesnippet/csharp/m-system.string.substrin_0_1.cs)]  \n  \n-   If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method., and `endMatchLength` is the length of the character sequence that marks the end of the substring. The following example extracts a block of text that contains an XML `<definition>` element.  \n  \n     [!code-vb[System.String.Substring#3](~/add/codesnippet/visualbasic/m-system.string.substrin_0_2.vb)]\n     [!code-cs[System.String.Substring#3](~/add/codesnippet/csharp/m-system.string.substrin_0_2.cs)]  \n  \n-   If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.  \n  \n If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged."
  example:
  - "The following example illustrates a simple call to the Substring method that extracts two characters from a string starting at the sixth character position (that is, at index five).  \n  \n [!code-vb[System.String.Substring#4](~/add/codesnippet/visualbasic/m-system.string.substrin_0_3.vb)]\n [!code-cs[System.String.Substring#4](~/add/codesnippet/csharp/m-system.string.substrin_0_3.cs)]  \n  \n The following example uses the Substring method in the following three cases to isolate substrings within a string. In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.  \n  \n-   It extracts the single character and the third position in the string (at index 2) and compares it with a \"c\". This comparison returns `true`.  \n  \n-   It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method. This returns true because the call to the Substring method returns <xref:System.String.Empty?displayProperty=fullName>.  \n  \n-   It attempts to extract one character starting at the fourth position in the string. Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.  \n  \n [!code-vb[Classic String.Substring1 Example#1](~/add/codesnippet/visualbasic/m-system.string.substrin_0_4.vb)]\n [!code-cs[Classic String.Substring1 Example#1](~/add/codesnippet/csharp/m-system.string.substrin_0_4.cs)]  \n  \n The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals (\"=\") character.  \n  \n [!code-cs[System.String.Substring#1](~/add/codesnippet/csharp/m-system.string.substrin_0_5.cs)]\n [!code-vb[System.String.Substring#1](~/add/codesnippet/visualbasic/m-system.string.substrin_0_5.vb)]  \n  \n The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.. The call to the Substring method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method. The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key. It starts at one character position beyond the equals character and extends to the end of the string."
  syntax:
    content: public string Substring (int startIndex, int length);
    parameters:
    - id: startIndex
      type: System.Int32
      description: The zero-based starting character position of a substring in this instance.
    - id: length
      type: System.Int32
      description: The number of characters in the substring.
    return:
      type: System.String
      description: A string that is equivalent to the substring of length <code>length</code> that begins at <code>startIndex</code> in this instance, or <xref href="System.String"></xref> if <code>startIndex</code> is equal to the length of this instance and <code>length</code> is zero.
  overload: System.String.Substring*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code> plus <code>length</code> indicates a position not within this instance.  \n  \n -or-  \n  \n <code>startIndex</code> or <code>length</code> is less than zero."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#Collections#Generic#IEnumerable{System#Char}#GetEnumerator
  id: System#Collections#Generic#IEnumerable{System#Char}#GetEnumerator
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.Collections.Generic.IEnumerable()
  nameWithType: String.System.Collections.Generic.IEnumerable()
  fullName: System.String.System.Collections.Generic.IEnumerable()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  syntax:
    content: System.Collections.Generic.IEnumerator<char> IEnumerable<char>.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerator{System.Char}
      description: To be added.
  overload: System.String.System#Collections#Generic#IEnumerable<System#Char>#GetEnumerator*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: String.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.String.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns an enumerator that iterates through the current <xref href="System.String"></xref> object.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface. For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=fullName> method.
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: An enumerator that can be used to iterate through the current string.
  overload: System.String.System#Collections#IEnumerable#GetEnumerator*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToBoolean(System.IFormatProvider)
  id: System#IConvertible#ToBoolean(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToBoolean(IFormatProvider)
  nameWithType: String.System.IConvertible.ToBoolean(IFormatProvider)
  fullName: System.String.System.IConvertible.ToBoolean(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToBoolean*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=fullName> method.
  syntax:
    content: bool IConvertible.ToBoolean (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: This parameter is ignored.
    return:
      type: System.Boolean
      description: '`true` if the value of the current string is <xref href="System.Boolean"></xref>; `false` if the value of the current string is <xref href="System.Boolean"></xref>.'
  overload: System.String.System#IConvertible#ToBoolean*
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: The value of the current string is not <xref href="System.Boolean"></xref> or <xref href="System.Boolean"></xref>.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToByte(System.IFormatProvider)
  id: System#IConvertible#ToByte(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToByte(IFormatProvider)
  nameWithType: String.System.IConvertible.ToByte(IFormatProvider)
  fullName: System.String.System.IConvertible.ToByte(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToByte*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: byte IConvertible.ToByte (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Byte
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToByte*
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: The value of the current <xref href="System.String"></xref> object cannot be parsed.
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: The value of the current <xref href="System.String"></xref> object is a number greater than <xref href="System.Byte.MaxValue"></xref> or less than <xref href="System.Byte.MinValue"></xref>.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToChar(System.IFormatProvider)
  id: System#IConvertible#ToChar(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToChar(IFormatProvider)
  nameWithType: String.System.IConvertible.ToChar(IFormatProvider)
  fullName: System.String.System.IConvertible.ToChar(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToChar*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: char IConvertible.ToChar (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Char
      description: The character at index 0 in the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToChar*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToDateTime(System.IFormatProvider)
  id: System#IConvertible#ToDateTime(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToDateTime(IFormatProvider)
  nameWithType: String.System.IConvertible.ToDateTime(IFormatProvider)
  fullName: System.String.System.IConvertible.ToDateTime(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToDateTime*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: DateTime IConvertible.ToDateTime (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.DateTime
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToDateTime*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToDecimal(System.IFormatProvider)
  id: System#IConvertible#ToDecimal(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToDecimal(IFormatProvider)
  nameWithType: String.System.IConvertible.ToDecimal(IFormatProvider)
  fullName: System.String.System.IConvertible.ToDecimal(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToDecimal*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: decimal IConvertible.ToDecimal (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Decimal
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToDecimal*
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: The value of the current <xref href="System.String"></xref> object cannot be parsed.
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: The value of the current <xref href="System.String"></xref> object is a number less than <xref href="System.Decimal.MinValue"></xref> or than <xref href="System.Decimal.MaxValue"></xref> greater.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToDouble(System.IFormatProvider)
  id: System#IConvertible#ToDouble(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToDouble(IFormatProvider)
  nameWithType: String.System.IConvertible.ToDouble(IFormatProvider)
  fullName: System.String.System.IConvertible.ToDouble(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToDouble*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: double IConvertible.ToDouble (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Double
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToDouble*
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: The value of the current <xref href="System.String"></xref> object cannot be parsed.
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: The value of the current <xref href="System.String"></xref> object is a number less than <xref href="System.Double.MinValue"></xref> or greater than <xref href="System.Double.MaxValue"></xref>.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToInt16(System.IFormatProvider)
  id: System#IConvertible#ToInt16(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToInt16(IFormatProvider)
  nameWithType: String.System.IConvertible.ToInt16(IFormatProvider)
  fullName: System.String.System.IConvertible.ToInt16(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToInt16*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: short IConvertible.ToInt16 (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Int16
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToInt16*
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: The value of the current <xref href="System.String"></xref> object cannot be parsed.
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: The value of the current <xref href="System.String"></xref> object is a number greater than <xref href="System.Int16.MaxValue"></xref> or less than <xref href="System.Int16.MinValue"></xref>.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToInt32(System.IFormatProvider)
  id: System#IConvertible#ToInt32(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToInt32(IFormatProvider)
  nameWithType: String.System.IConvertible.ToInt32(IFormatProvider)
  fullName: System.String.System.IConvertible.ToInt32(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToInt32*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: int IConvertible.ToInt32 (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Int32
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToInt32*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToInt64(System.IFormatProvider)
  id: System#IConvertible#ToInt64(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToInt64(IFormatProvider)
  nameWithType: String.System.IConvertible.ToInt64(IFormatProvider)
  fullName: System.String.System.IConvertible.ToInt64(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToInt64*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: long IConvertible.ToInt64 (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Int64
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToInt64*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToSByte(System.IFormatProvider)
  id: System#IConvertible#ToSByte(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToSByte(IFormatProvider)
  nameWithType: String.System.IConvertible.ToSByte(IFormatProvider)
  fullName: System.String.System.IConvertible.ToSByte(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToSByte*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: sbyte IConvertible.ToSByte (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.SByte
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToSByte*
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: The value of the current <xref href="System.String"></xref> object cannot be parsed.
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: The value of the current <xref href="System.String"></xref> object is a number greater than <xref href="System.SByte.MaxValue"></xref> or less than <xref href="System.SByte.MinValue"></xref>.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToSingle(System.IFormatProvider)
  id: System#IConvertible#ToSingle(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToSingle(IFormatProvider)
  nameWithType: String.System.IConvertible.ToSingle(IFormatProvider)
  fullName: System.String.System.IConvertible.ToSingle(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToSingle*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: float IConvertible.ToSingle (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Single
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToSingle*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)
  id: System#IConvertible#ToType(System.Type,System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToType(Type,IFormatProvider)
  nameWithType: String.System.IConvertible.ToType(Type,IFormatProvider)
  fullName: System.String.System.IConvertible.ToType(Type,IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToType*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.
  syntax:
    content: object IConvertible.ToType (Type type, IFormatProvider provider);
    parameters:
    - id: type
      type: System.Type
      description: The type of the returned object.
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.Object
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToType*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>type</code> is `null`.
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: The value of the current <xref href="System.String"></xref> object cannot be converted to the type specified by the <code>type</code> parameter.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToUInt16(System.IFormatProvider)
  id: System#IConvertible#ToUInt16(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToUInt16(IFormatProvider)
  nameWithType: String.System.IConvertible.ToUInt16(IFormatProvider)
  fullName: System.String.System.IConvertible.ToUInt16(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToUInt16*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: ushort IConvertible.ToUInt16 (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.UInt16
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToUInt16*
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: The value of the current <xref href="System.String"></xref> object cannot be parsed.
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: The value of the current <xref href="System.String"></xref> object is a number greater than <xref href="System.UInt16.MaxValue"></xref> or less than <xref href="System.UInt16.MinValue"></xref>.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToUInt32(System.IFormatProvider)
  id: System#IConvertible#ToUInt32(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToUInt32(IFormatProvider)
  nameWithType: String.System.IConvertible.ToUInt32(IFormatProvider)
  fullName: System.String.System.IConvertible.ToUInt32(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToUInt32*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: uint IConvertible.ToUInt32 (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.UInt32
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToUInt32*
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: The value of the current <xref href="System.String"></xref> object cannot be parsed.
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: The value of the current <xref href="System.String"></xref> object is a number greater <xref href="System.UInt32.MaxValue"></xref> or less than <xref href="System.UInt32.MinValue"></xref>
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.System#IConvertible#ToUInt64(System.IFormatProvider)
  id: System#IConvertible#ToUInt64(System.IFormatProvider)
  isEii: true
  parent: System.String
  langs:
  - csharp
  name: System.IConvertible.ToUInt64(IFormatProvider)
  nameWithType: String.System.IConvertible.ToUInt64(IFormatProvider)
  fullName: System.String.System.IConvertible.ToUInt64(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: For a description of this member, see <xref:System.IConvertible.ToUInt64*>.
  remarks: This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.
  syntax:
    content: ulong IConvertible.ToUInt64 (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: An object that provides culture-specific formatting information.
    return:
      type: System.UInt64
      description: The converted value of the current <xref href="System.String"></xref> object.
  overload: System.String.System#IConvertible#ToUInt64*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToCharArray
  id: ToCharArray
  parent: System.String
  langs:
  - csharp
  name: ToCharArray()
  nameWithType: String.ToCharArray()
  fullName: System.String.ToCharArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Copies the characters in this instance to a Unicode character array.
  remarks: "This method copies each character (that is, each <xref:System.Char> object) in a string to a character array. The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=fullName> – 1.  \n  \n To create a string from the characters in a character array, call the [String(Char\\[\\])](assetId:///M:System.String.#ctor(System.Char[])?qualifyHint=False&autoUpgrade=False) constructor.  \n  \n To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=fullName> method. Some of the standard encodings available in the .NET Framework include the following:  \n  \n|Encoding|Object|  \n|--------------|------------|  \n|ASCII|<xref:System.Text.ASCIIEncoding>|  \n|UTF-7|<xref:System.Text.UTF7Encoding>|  \n|UTF-8|<xref:System.Text.UTF8Encoding>|  \n|UTF-16|<xref:System.Text.UnicodeEncoding>|  \n|UTF-32|<xref:System.Text.UTF32Encoding>|  \n  \n For more information, see [Character Encoding in the .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example calls the ToCharArray method to extract the characters in a string to a character array. It then displays the original string and the elements in the array.  \n  \n [!code-vb[System.String.ToCharArray#1](~/add/codesnippet/visualbasic/m-system.string.tocharar_0_1.vb)]\n [!code-cs[System.String.ToCharArray#1](~/add/codesnippet/csharp/m-system.string.tocharar_0_1.cs)]  \n  \n The following example defines a string containing the characters that serve as delimiters in a delimited string. It then calls the ToCharArray method to create a character array that can be passed to the [Split(Char\\[\\])](assetId:///M:System.String.Split(System.Char[])?qualifyHint=False&autoUpgrade=False) method to separate the delimited string into its individual substrings.  \n  \n [!code-cs[StringSplit2#1](~/add/codesnippet/csharp/m-system.string.tocharar_0_2.cs)]\n [!code-cs[StringSplit2#1](~/add/codesnippet/csharp/m-system.string.tocharar_0_2.cs)]\n [!code-cpp[StringSplit2#1](~/add/codesnippet/cpp/m-system.string.tocharar_0_2.cpp)]\n [!code-vb[StringSplit2#1](~/add/codesnippet/visualbasic/m-system.string.tocharar_0_2.vb)]"
  syntax:
    content: public char[] ToCharArray ();
    parameters: []
    return:
      type: System.Char[]
      description: A Unicode character array whose elements are the individual characters of this instance. If this instance is an empty string, the returned array is empty and has a zero length.
  overload: System.String.ToCharArray*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToCharArray(System.Int32,System.Int32)
  id: ToCharArray(System.Int32,System.Int32)
  parent: System.String
  langs:
  - csharp
  name: ToCharArray(Int32,Int32)
  nameWithType: String.ToCharArray(Int32,Int32)
  fullName: System.String.ToCharArray(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Copies the characters in a specified substring in this instance to a Unicode character array.
  remarks: "This method copies the characters in a portion of a string to a character array. To create a string from a range of characters in a character array, call the  [String(Char\\[\\], Int32, Int32)](assetId:///M:System.String.#ctor(System.Char[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=False) constructor.  \n  \n The `startIndex` parameter is zero-based. That is, the index of the first character in the string instance is zero.  \n  \n If `length` is zero, the returned array is empty and has a zero length. If this instance is `null` or an empty string (\"\"), the returned array is empty and has a zero length.  \n  \n To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its [GetBytes(String, Int32, Int32, Byte\\[\\], Int32)](assetId:///M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)?qualifyHint=False&autoUpgrade=False) method. Some of the standard encodings available in the .NET Framework include the following:  \n  \n|Encoding|Object|  \n|--------------|------------|  \n|ASCII|<xref:System.Text.ASCIIEncoding>|  \n|UTF-7|<xref:System.Text.UTF7Encoding>|  \n|UTF-8|<xref:System.Text.UTF8Encoding>|  \n|UTF-16|<xref:System.Text.UnicodeEncoding>|  \n|UTF-32|<xref:System.Text.UTF32Encoding>|  \n  \n For more information, see [Character Encoding in the .NET Framework](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.  \n  \n [!code-cpp[string.tochararray1#1](~/add/codesnippet/cpp/m-system.string.tocharar_1_1.cpp)]\n [!code-vb[string.tochararray1#1](~/add/codesnippet/visualbasic/m-system.string.tocharar_1_1.vb)]\n [!code-cs[string.tochararray1#1](~/add/codesnippet/csharp/m-system.string.tocharar_1_1.cs)]"
  syntax:
    content: public char[] ToCharArray (int startIndex, int length);
    parameters:
    - id: startIndex
      type: System.Int32
      description: The starting position of a substring in this instance.
    - id: length
      type: System.Int32
      description: The length of the substring in this instance.
    return:
      type: System.Char[]
      description: A Unicode character array whose elements are the <code>length</code> number of characters in this instance starting from character position <code>startIndex</code>.
  overload: System.String.ToCharArray*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>startIndex</code> or <code>length</code> is less than zero.  \n  \n -or-  \n  \n <code>startIndex</code> plus <code>length</code> is greater than the length of this instance."
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToLower
  id: ToLower
  parent: System.String
  langs:
  - csharp
  name: ToLower()
  nameWithType: String.ToLower()
  fullName: System.String.ToLower()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a copy of this string converted to lowercase.
  remarks: "This method takes into account the casing rules of the current culture.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.  \n  \n## Security Considerations  \n The casing operation that results from calling the ToLower method takes the casing conventions of the current culture into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods. This produces the same result in every culture (unlike the ToLower method) and performs more efficiently."
  example:
  - "The following example converts several mixed case strings to lowercase.  \n  \n [!code-cs[stringlowerupper#1](~/add/codesnippet/csharp/m-system.string.tolower_1.cs)]\n [!code-cpp[stringlowerupper#1](~/add/codesnippet/cpp/m-system.string.tolower_1.cpp)]\n [!code-vb[stringlowerupper#1](~/add/codesnippet/visualbasic/m-system.string.tolower_1.vb)]"
  syntax:
    content: public string ToLower ();
    parameters: []
    return:
      type: System.String
      description: A string in lowercase.
  overload: System.String.ToLower*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToLower(System.Globalization.CultureInfo)
  id: ToLower(System.Globalization.CultureInfo)
  parent: System.String
  langs:
  - csharp
  name: ToLower(CultureInfo)
  nameWithType: String.ToLower(CultureInfo)
  fullName: System.String.ToLower(CultureInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.
  remarks: "The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.  \n  \n## Security Considerations  \n If you pass the ToLower method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>, the casing operation will take culture-specific rules into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method. This produces the same result in every culture and performs more efficiently."
  example:
  - "The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings. The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.  \n  \n [!code-cpp[string.tolower1#1](~/add/codesnippet/cpp/m-system.string.tolower-_1.cpp)]\n [!code-vb[string.tolower1#1](~/add/codesnippet/visualbasic/m-system.string.tolower-_1.vb)]\n [!code-cs[string.tolower1#1](~/add/codesnippet/csharp/m-system.string.tolower-_1.cs)]"
  syntax:
    content: public string ToLower (System.Globalization.CultureInfo culture);
    parameters:
    - id: culture
      type: System.Globalization.CultureInfo
      description: An object that supplies culture-specific casing rules.
    return:
      type: System.String
      description: The lowercase equivalent of the current string.
  overload: System.String.ToLower*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>culture</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToLowerInvariant
  id: ToLowerInvariant
  parent: System.String
  langs:
  - csharp
  name: ToLowerInvariant()
  nameWithType: String.ToLowerInvariant()
  fullName: System.String.ToLowerInvariant()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a copy of this <xref href="System.String"></xref> object converted to lowercase using the casing rules of the invariant culture.
  remarks: "The invariant culture represents a culture that is culture-insensitive. It is associated with the English language but not with a specific country or region. For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> property.  \n  \n If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the ToLowerInvariant method. The ToLowerInvariant method is equivalent to `ToLower(CultureInfo.InvariantCulture)`. The method is recommended when a collection of strings must appear in a predictable order in a user interface control.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.  \n  \n## Security Considerations  \n If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the ToLowerInvariant or <xref:System.String.ToUpperInvariant%2A> methods."
  example:
  - "The following example defines a string array that contains a single word in a number of languages. The ToLowerInvariant method is used to populate the elements of a parallel array with the case-insensitive version of each word. The [Array.Sort\\<TKey, TValue>(TKey\\[\\], TValue\\[\\], IComparer\\<TKey>)](assetId:///M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})?qualifyHint=True&autoUpgrade=False) method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.  \n  \n [!code-cs[System.String.ToLowerInvariant#1](~/add/codesnippet/csharp/m-system.string.toloweri_1.cs)]\n [!code-vb[System.String.ToLowerInvariant#1](~/add/codesnippet/visualbasic/m-system.string.toloweri_1.vb)]"
  syntax:
    content: public string ToLowerInvariant ();
    parameters: []
    return:
      type: System.String
      description: The lowercase equivalent of the current string.
  overload: System.String.ToLowerInvariant*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToString
  id: ToString
  parent: System.String
  langs:
  - csharp
  name: ToString()
  nameWithType: String.ToString()
  fullName: System.String.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns this instance of <xref href="System.String"></xref>; no actual conversion is performed.
  remarks: Because this method simply returns the current string unchanged, there is no need to call it directly. It is usually called implicitly in a composite formatting operation, as the example shows.
  example:
  - "The following example demonstrates the ToString method.Note that the example does not explicitly call the ToString method. Instead, the method is called implicitly by the [composite formatting](~/add/includes/ajax-current-ext-md.md) feature.  \n  \n [!code-vb[string.tostring#1](~/add/codesnippet/visualbasic/m-system.string.tostring_1.vb)]\n [!code-cs[string.tostring#1](~/add/codesnippet/csharp/m-system.string.tostring_1.cs)]\n [!code-cpp[string.tostring#1](~/add/codesnippet/cpp/m-system.string.tostring_1.cpp)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: The current string.
  overload: System.String.ToString*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToString(System.IFormatProvider)
  id: ToString(System.IFormatProvider)
  parent: System.String
  langs:
  - csharp
  name: ToString(IFormatProvider)
  nameWithType: String.ToString(IFormatProvider)
  fullName: System.String.ToString(IFormatProvider)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns this instance of <xref href="System.String"></xref>; no actual conversion is performed.
  remarks: "`provider` is reserved, and does not currently participate in this operation.  \n  \n Because this method simply returns the current string unchanged, there is no need to call it directly."
  syntax:
    content: public string ToString (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: (Reserved) An object that supplies culture-specific formatting information.
    return:
      type: System.String
      description: The current string.
  overload: System.String.ToString*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToUpper
  id: ToUpper
  parent: System.String
  langs:
  - csharp
  name: ToUpper()
  nameWithType: String.ToUpper()
  fullName: System.String.ToUpper()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a copy of this string converted to uppercase.
  remarks: "This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent. If a character does not have an uppercase equivalent, it is included unchanged in the returned string.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.  \n  \n The ToUpper method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison. A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison?displayProperty=fullName> for a culture-sensitive, case-insensitive comparison.  \n  \n## Security Considerations  \n The casing operation that results from calling the ToUpper method takes the casing conventions of the current culture into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method. This produces the same result in every culture (unlike the ToUpper method) and performs more efficiently."
  example:
  - "The following example calls the ToUpper method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets. It then displays each string whose uppercase character is different from its lowercase character.  \n  \n [!code-vb[System.String.ToUpper#1](~/add/codesnippet/visualbasic/m-system.string.toupper_1.vb)]\n [!code-cs[System.String.ToUpper#1](~/add/codesnippet/csharp/m-system.string.toupper_1.cs)]\n [!code-cpp[System.String.ToUpper#1](~/add/codesnippet/cpp/m-system.string.toupper_1.cpp)]"
  syntax:
    content: public string ToUpper ();
    parameters: []
    return:
      type: System.String
      description: The uppercase equivalent of the current string.
  overload: System.String.ToUpper*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToUpper(System.Globalization.CultureInfo)
  id: ToUpper(System.Globalization.CultureInfo)
  parent: System.String
  langs:
  - csharp
  name: ToUpper(CultureInfo)
  nameWithType: String.ToUpper(CultureInfo)
  fullName: System.String.ToUpper(CultureInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.
  remarks: "The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.  \n  \n## Security Considerations  \n If you pass the ToUpper method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>, the casing operation will take culture-specific rules into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method. This produces the same result in every culture and performs more efficiently."
  example:
  - "The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings. The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.  \n  \n [!code-cs[string.toupper1#1](~/add/codesnippet/csharp/m-system.string.toupper-_1.cs)]\n [!code-vb[string.toupper1#1](~/add/codesnippet/visualbasic/m-system.string.toupper-_1.vb)]"
  syntax:
    content: public string ToUpper (System.Globalization.CultureInfo culture);
    parameters:
    - id: culture
      type: System.Globalization.CultureInfo
      description: An object that supplies culture-specific casing rules.
    return:
      type: System.String
      description: The uppercase equivalent of the current string.
  overload: System.String.ToUpper*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: <code>culture</code> is `null`.
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.ToUpperInvariant
  id: ToUpperInvariant
  parent: System.String
  langs:
  - csharp
  name: ToUpperInvariant()
  nameWithType: String.ToUpperInvariant()
  fullName: System.String.ToUpperInvariant()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Returns a copy of this <xref href="System.String"></xref> object converted to uppercase using the casing rules of the invariant culture.
  remarks: "The invariant culture represents a culture that is culture-insensitive. It is associated with the English language but not with a specific country or region. For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> property.  \n  \n If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the ToUpperInvariant method. The ToUpperInvariant method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`. The method is recommended when a collection of strings must appear in a predictable order in a user interface control.  \n  \n> [!NOTE]\n>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.  \n  \n## Security Considerations  \n If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or ToUpperInvariant methods."
  example:
  - "The following example defines a string array that contains a single word in a number of languages. The ToUpperInvariant method is used to populate the elements of a parallel array with the case-insensitive version of each word. The [Array.Sort\\<TKey, TValue>(TKey\\[\\], TValue\\[\\], IComparer\\<TKey>)](assetId:///M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})?qualifyHint=True&autoUpgrade=False) method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.  \n  \n [!code-cs[System.String.ToUpperInvariant#1](~/add/codesnippet/csharp/m-system.string.toupperi_1.cs)]\n [!code-vb[System.String.ToUpperInvariant#1](~/add/codesnippet/visualbasic/m-system.string.toupperi_1.vb)]"
  syntax:
    content: public string ToUpperInvariant ();
    parameters: []
    return:
      type: System.String
      description: The uppercase equivalent of the current string.
  overload: System.String.ToUpperInvariant*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Trim
  id: Trim
  parent: System.String
  langs:
  - csharp
  name: Trim()
  nameWithType: String.Trim()
  fullName: System.String.Trim()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Removes all leading and trailing white-space characters from the current <xref href="System.String"></xref> object.
  remarks: "The Trim method removes from the current string all leading and trailing white-space characters. Each leading and trailing trim operation stops when a non-white-space character is encountered. For example, if the current string is \"   abc   xyz   \", the Trim method returns \"abc   xyz\". To remove white-space characters between words in a string, use a [.NET Framework Regular Expressions](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!NOTE]\n>  If the Trim method removes any characters from the current instance, this method does not modify the value of the current instance. Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.  \n  \n If the current string equals <xref:System.String> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String>.  \n  \n White-space characters are defined by the Unicode standard. The Trim method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method."
  example:
  - "The following example uses the Trim method to remove any extra white space from strings entered by the user before concatenating them.  \n  \n [!code-cpp[System.String.Trim#2](~/add/codesnippet/cpp/m-system.string.trim_1.cpp)]\n [!code-cs[System.String.Trim#2](~/add/codesnippet/csharp/m-system.string.trim_1.cs)]\n [!code-vb[System.String.Trim#2](~/add/codesnippet/visualbasic/m-system.string.trim_1.vb)]"
  syntax:
    content: public string Trim ();
    parameters: []
    return:
      type: System.String
      description: The string that remains after all white-space characters are removed from the start and end of the current string. If no characters can be trimmed from the current instance, the method returns the current instance unchanged.
  overload: System.String.Trim*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.Trim(System.Char[])
  id: Trim(System.Char[])
  parent: System.String
  langs:
  - csharp
  name: Trim(Char[])
  nameWithType: String.Trim(Char[])
  fullName: System.String.Trim(Char[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Removes all leading and trailing occurrences of a set of characters specified in an array from the current <xref href="System.String"></xref> object.
  remarks: "The Trim method removes from the current string all leading and trailing characters that are in the `trimChars` parameter. Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered. For example, if the current string is \"123abc456xyz789\" and `trimChars` contains the digits from \"1\" through \"9\", the Trim method returns \"abc456xyz\".  \n  \n> [!NOTE]\n>  If the Trim method removes any characters from the current instance, this method does not modify the value of the current instance. Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.  \n  \n If the current string equals <xref:System.String> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String>.  \n  \n If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method,"
  example:
  - "The following example uses the Trim method to remove space, asterisk (*), and apostrophe (') characters from a string.  \n  \n [!code-cpp[System.String.Trim#1](~/add/codesnippet/cpp/m-system.string.trim-sys_1.cpp)]\n [!code-vb[System.String.Trim#1](~/add/codesnippet/visualbasic/m-system.string.trim-sys_1.vb)]\n [!code-cs[System.String.Trim#1](~/add/codesnippet/csharp/m-system.string.trim-sys_1.cs)]"
  syntax:
    content: public string Trim (char[] trimChars);
    parameters:
    - id: trimChars
      type: System.Char[]
      description: An array of Unicode characters to remove, or `null`.
    return:
      type: System.String
      description: The string that remains after all occurrences of the characters in the <code>trimChars</code> parameter are removed from the start and end of the current string. If <code>trimChars</code> is `null` or an empty array, white-space characters are removed instead. If no characters can be trimmed from the current instance, the method returns the current instance unchanged.
  overload: System.String.Trim*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.TrimEnd(System.Char[])
  id: TrimEnd(System.Char[])
  parent: System.String
  langs:
  - csharp
  name: TrimEnd(Char[])
  nameWithType: String.TrimEnd(Char[])
  fullName: System.String.TrimEnd(Char[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Removes all trailing occurrences of a set of characters specified in an array from the current <xref href="System.String"></xref> object.
  remarks: "The TrimEnd method removes from the current string all trailing characters that are in the `trimChars` parameter. The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string. For example, if the current string is \"123abc456xyz789\" and `trimChars` contains the digits from \"1\" through \"9\", the TrimEnd method returns \"123abc456xyz\".  \n  \n> [!NOTE]\n>  If the TrimEnd method removes any characters from the current instance, this method does not modify the value of the current instance. Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string."
  example:
  - "The following example demonstrates how you can use the TrimEnd method to trim white space or punctuation marks from the end of a string.  \n  \n [!code-cs[System.String.TrimEnd#2](~/add/codesnippet/csharp/m-system.string.trimend-_1.cs)]\n [!code-vb[System.String.TrimEnd#2](~/add/codesnippet/visualbasic/m-system.string.trimend-_1.vb)]"
  syntax:
    content: public string TrimEnd (char[] trimChars);
    parameters:
    - id: trimChars
      type: System.Char[]
      description: An array of Unicode characters to remove, or `null`.
    return:
      type: System.String
      description: The string that remains after all occurrences of the characters in the <code>trimChars</code> parameter are removed from the end of the current string. If <code>trimChars</code> is `null` or an empty array, Unicode white-space characters are removed instead. If no characters can be trimmed from the current instance, the method returns the current instance unchanged.
  overload: System.String.TrimEnd*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
- uid: System.String.TrimStart(System.Char[])
  id: TrimStart(System.Char[])
  parent: System.String
  langs:
  - csharp
  name: TrimStart(Char[])
  nameWithType: String.TrimStart(Char[])
  fullName: System.String.TrimStart(Char[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: Removes all leading occurrences of a set of characters specified in an array from the current <xref href="System.String"></xref> object.
  remarks: "The TrimStart method removes from the current string all leading characters that are in the `trimChars` parameter. The trim operation stops when a character that is not in `trimChars` is encountered. For example, if the current string is \"123abc456xyz789\" and `trimChars` contains the digits from \"1\" through \"9\", the TrimStart method returns \"abc456xyz789\".  \n  \n> [!NOTE]\n>  If the TrimStart method removes any characters from the current instance, this method does not modify the value of the current instance. Instead, it returns a new string in which all leading white space characters found in the current instance are removed."
  example:
  - "The following example uses the TrimStart method to trim white space and comment characters from lines of source code. The `StripComments` method wraps a call to TrimStart and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#. The TrimStart method is also called to remove leading white space when evaluating whether a string is a comment.  \n  \n [!code-cs[System.String.TrimStart#1](~/add/codesnippet/csharp/m-system.string.trimstar_1.cs)]\n [!code-vb[System.String.TrimStart#1](~/add/codesnippet/visualbasic/m-system.string.trimstar_1.vb)]  \n  \n The following example then illustrates a call to the `StripComments` method.  \n  \n [!code-cs[System.String.TrimStart#2](~/add/codesnippet/csharp/m-system.string.trimstar_2.cs)]\n [!code-vb[System.String.TrimStart#2](~/add/codesnippet/visualbasic/m-system.string.trimstar_2.vb)]"
  syntax:
    content: public string TrimStart (char[] trimChars);
    parameters:
    - id: trimChars
      type: System.Char[]
      description: An array of Unicode characters to remove, or `null`.
    return:
      type: System.String
      description: The string that remains after all occurrences of characters in the <code>trimChars</code> parameter are removed from the start of the current string. If <code>trimChars</code> is `null` or an empty array, white-space characters are removed instead.
  overload: System.String.TrimStart*
  exceptions: []
  version:
  - netframework-20
  - netframework-30
  - netframework-35
  - netframework-40
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentOutOfRangeException
  parent: System
  isExternal: false
  name: ArgumentOutOfRangeException
  nameWithType: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  nameWithType: ArgumentException
  fullName: System.ArgumentException
- uid: System.ArgumentNullException
  parent: System
  isExternal: false
  name: ArgumentNullException
  nameWithType: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.AccessViolationException
  parent: System
  isExternal: false
  name: AccessViolationException
  nameWithType: AccessViolationException
  fullName: System.AccessViolationException
- uid: System.IndexOutOfRangeException
  parent: System
  isExternal: false
  name: IndexOutOfRangeException
  nameWithType: IndexOutOfRangeException
  fullName: System.IndexOutOfRangeException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  nameWithType: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.OutOfMemoryException
  parent: System
  isExternal: false
  name: OutOfMemoryException
  nameWithType: OutOfMemoryException
  fullName: System.OutOfMemoryException
- uid: System.FormatException
  parent: System
  isExternal: false
  name: FormatException
  nameWithType: FormatException
  fullName: System.FormatException
- uid: System.OverflowException
  parent: System
  isExternal: false
  name: OverflowException
  nameWithType: OverflowException
  fullName: System.OverflowException
- uid: System.InvalidCastException
  parent: System
  isExternal: false
  name: InvalidCastException
  nameWithType: InvalidCastException
  fullName: System.InvalidCastException
- uid: System.String.#ctor(System.Char*)
  parent: System.String
  isExternal: false
  name: String(Char*)
  nameWithType: String.String(Char*)
  fullName: System.String.String(Char*)
- uid: System.Char*
  parent: System
  isExternal: false
  name: Char*
  nameWithType: Char*
  fullName: System.Char*
  spec.csharp:
  - uid: System.Char
    name: Char
    nameWithType: Char
    fullName: Char
  - name: '*'
    nameWithType: '*'
    fullName: '*'
- uid: System.String.#ctor(System.Char[])
  parent: System.String
  isExternal: false
  name: String(Char[])
  nameWithType: String.String(Char[])
  fullName: System.String.String(Char[])
- uid: System.Char[]
  parent: System
  isExternal: false
  name: Char[]
  nameWithType: Char[]
  fullName: System.Char[]
  spec.csharp:
  - uid: System.Char
    name: Char
    nameWithType: Char
    fullName: Char[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.String.#ctor(System.SByte*)
  parent: System.String
  isExternal: false
  name: String(SByte*)
  nameWithType: String.String(SByte*)
  fullName: System.String.String(SByte*)
- uid: System.SByte*
  parent: System
  isExternal: false
  name: SByte*
  nameWithType: SByte*
  fullName: System.SByte*
  spec.csharp:
  - uid: System.SByte
    name: SByte
    nameWithType: SByte
    fullName: SByte
  - name: '*'
    nameWithType: '*'
    fullName: '*'
- uid: System.String.#ctor(System.Char,System.Int32)
  parent: System.String
  isExternal: false
  name: String(Char,Int32)
  nameWithType: String.String(Char,Int32)
  fullName: System.String.String(Char,Int32)
- uid: System.Char
  parent: System
  isExternal: false
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.String.#ctor(System.Char*,System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: String(Char*,Int32,Int32)
  nameWithType: String.String(Char*,Int32,Int32)
  fullName: System.String.String(Char*,Int32,Int32)
- uid: System.String.#ctor(System.Char[],System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: String(Char[],Int32,Int32)
  nameWithType: String.String(Char[],Int32,Int32)
  fullName: System.String.String(Char[],Int32,Int32)
- uid: System.String.#ctor(System.SByte*,System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: String(SByte*,Int32,Int32)
  nameWithType: String.String(SByte*,Int32,Int32)
  fullName: System.String.String(SByte*,Int32,Int32)
- uid: System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)
  parent: System.String
  isExternal: false
  name: String(SByte*,Int32,Int32,Encoding)
  nameWithType: String.String(SByte*,Int32,Int32,Encoding)
  fullName: System.String.String(SByte*,Int32,Int32,Encoding)
- uid: System.Text.Encoding
  parent: System.Text
  isExternal: false
  name: Encoding
  nameWithType: Encoding
  fullName: System.Text.Encoding
- uid: System.String.Chars(System.Int32)
  parent: System.String
  isExternal: false
  name: Chars(Int32)
  nameWithType: String.Chars(Int32)
  fullName: System.String.Chars(Int32)
- uid: System.String.Clone
  parent: System.String
  isExternal: false
  name: Clone()
  nameWithType: String.Clone()
  fullName: System.String.Clone()
- uid: System.String.Compare(System.String,System.String)
  parent: System.String
  isExternal: false
  name: Compare(String,String)
  nameWithType: String.Compare(String,String)
  fullName: System.String.Compare(String,String)
- uid: System.String
  parent: System
  isExternal: false
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.String.Compare(System.String,System.String,System.Boolean)
  parent: System.String
  isExternal: false
  name: Compare(String,String,Boolean)
  nameWithType: String.Compare(String,String,Boolean)
  fullName: System.String.Compare(String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.String.Compare(System.String,System.String,System.StringComparison)
  parent: System.String
  isExternal: false
  name: Compare(String,String,StringComparison)
  nameWithType: String.Compare(String,String,StringComparison)
  fullName: System.String.Compare(String,String,StringComparison)
- uid: System.StringComparison
  parent: System
  isExternal: false
  name: StringComparison
  nameWithType: StringComparison
  fullName: System.StringComparison
- uid: System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)
  parent: System.String
  isExternal: false
  name: Compare(String,String,Boolean,CultureInfo)
  nameWithType: String.Compare(String,String,Boolean,CultureInfo)
  fullName: System.String.Compare(String,String,Boolean,CultureInfo)
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: false
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)
  parent: System.String
  isExternal: false
  name: Compare(String,String,CultureInfo,CompareOptions)
  nameWithType: String.Compare(String,String,CultureInfo,CompareOptions)
  fullName: System.String.Compare(String,String,CultureInfo,CompareOptions)
- uid: System.Globalization.CompareOptions
  parent: System.Globalization
  isExternal: false
  name: CompareOptions
  nameWithType: CompareOptions
  fullName: System.Globalization.CompareOptions
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: Compare(String,Int32,String,Int32,Int32)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32)
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)
  parent: System.String
  isExternal: false
  name: Compare(String,Int32,String,Int32,Int32,Boolean)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32,Boolean)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32,Boolean)
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)
  parent: System.String
  isExternal: false
  name: Compare(String,Int32,String,Int32,Int32,StringComparison)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32,StringComparison)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32,StringComparison)
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)
  parent: System.String
  isExternal: false
  name: Compare(String,Int32,String,Int32,Int32,Boolean,CultureInfo)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32,Boolean,CultureInfo)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32,Boolean,CultureInfo)
- uid: System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)
  parent: System.String
  isExternal: false
  name: Compare(String,Int32,String,Int32,Int32,CultureInfo,CompareOptions)
  nameWithType: String.Compare(String,Int32,String,Int32,Int32,CultureInfo,CompareOptions)
  fullName: System.String.Compare(String,Int32,String,Int32,Int32,CultureInfo,CompareOptions)
- uid: System.String.CompareOrdinal(System.String,System.String)
  parent: System.String
  isExternal: false
  name: CompareOrdinal(String,String)
  nameWithType: String.CompareOrdinal(String,String)
  fullName: System.String.CompareOrdinal(String,String)
- uid: System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: CompareOrdinal(String,Int32,String,Int32,Int32)
  nameWithType: String.CompareOrdinal(String,Int32,String,Int32,Int32)
  fullName: System.String.CompareOrdinal(String,Int32,String,Int32,Int32)
- uid: System.String.CompareTo(System.Object)
  parent: System.String
  isExternal: false
  name: CompareTo(Object)
  nameWithType: String.CompareTo(Object)
  fullName: System.String.CompareTo(Object)
- uid: System.String.CompareTo(System.String)
  parent: System.String
  isExternal: false
  name: CompareTo(String)
  nameWithType: String.CompareTo(String)
  fullName: System.String.CompareTo(String)
- uid: System.String.Concat(System.Collections.Generic.IEnumerable{System.String})
  parent: System.String
  isExternal: false
  name: Concat(IEnumerable<String>)
  nameWithType: String.Concat(IEnumerable<String>)
  fullName: System.String.Concat(IEnumerable<String>)
- uid: System.Collections.Generic.IEnumerable{System.String}
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerable<String>
  nameWithType: IEnumerable<String>
  fullName: System.Collections.Generic.IEnumerable<System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.String.Concat(System.Object)
  parent: System.String
  isExternal: false
  name: Concat(Object)
  nameWithType: String.Concat(Object)
  fullName: System.String.Concat(Object)
- uid: System.String.Concat(System.Object[])
  parent: System.String
  isExternal: false
  name: Concat(Object[])
  nameWithType: String.Concat(Object[])
  fullName: System.String.Concat(Object[])
- uid: System.Object[]
  parent: System
  isExternal: false
  name: Object[]
  nameWithType: Object[]
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.String.Concat(System.String[])
  parent: System.String
  isExternal: false
  name: Concat(String[])
  nameWithType: String.Concat(String[])
  fullName: System.String.Concat(String[])
- uid: System.String[]
  parent: System
  isExternal: false
  name: String[]
  nameWithType: String[]
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.String.Concat(System.Object,System.Object)
  parent: System.String
  isExternal: false
  name: Concat(Object,Object)
  nameWithType: String.Concat(Object,Object)
  fullName: System.String.Concat(Object,Object)
- uid: System.String.Concat(System.String,System.String)
  parent: System.String
  isExternal: false
  name: Concat(String,String)
  nameWithType: String.Concat(String,String)
  fullName: System.String.Concat(String,String)
- uid: System.String.Concat(System.Object,System.Object,System.Object)
  parent: System.String
  isExternal: false
  name: Concat(Object,Object,Object)
  nameWithType: String.Concat(Object,Object,Object)
  fullName: System.String.Concat(Object,Object,Object)
- uid: System.String.Concat(System.String,System.String,System.String)
  parent: System.String
  isExternal: false
  name: Concat(String,String,String)
  nameWithType: String.Concat(String,String,String)
  fullName: System.String.Concat(String,String,String)
- uid: System.String.Concat(System.Object,System.Object,System.Object,System.Object)
  parent: System.String
  isExternal: false
  name: Concat(Object,Object,Object,Object)
  nameWithType: String.Concat(Object,Object,Object,Object)
  fullName: System.String.Concat(Object,Object,Object,Object)
- uid: System.String.Concat(System.String,System.String,System.String,System.String)
  parent: System.String
  isExternal: false
  name: Concat(String,String,String,String)
  nameWithType: String.Concat(String,String,String,String)
  fullName: System.String.Concat(String,String,String,String)
- uid: System.String.Concat``1(System.Collections.Generic.IEnumerable`1)
  parent: System.String
  isExternal: false
  name: Concat(IEnumerable<T>)
  nameWithType: String.Concat(IEnumerable<T>)
  fullName: System.String.Concat(IEnumerable<T>)
- uid: System.Collections.Generic.IEnumerable`1
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerable<T>
  nameWithType: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
- uid: System.String.Contains(System.String)
  parent: System.String
  isExternal: false
  name: Contains(String)
  nameWithType: String.Contains(String)
  fullName: System.String.Contains(String)
- uid: System.String.Copy(System.String)
  parent: System.String
  isExternal: false
  name: Copy(String)
  nameWithType: String.Copy(String)
  fullName: System.String.Copy(String)
- uid: System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: CopyTo(Int32,Char[],Int32,Int32)
  nameWithType: String.CopyTo(Int32,Char[],Int32,Int32)
  fullName: System.String.CopyTo(Int32,Char[],Int32,Int32)
- uid: System.String.Empty
  parent: System.String
  isExternal: false
  name: Empty
  nameWithType: String.Empty
  fullName: System.String.Empty
- uid: System.String.EndsWith(System.String)
  parent: System.String
  isExternal: false
  name: EndsWith(String)
  nameWithType: String.EndsWith(String)
  fullName: System.String.EndsWith(String)
- uid: System.String.EndsWith(System.String,System.StringComparison)
  parent: System.String
  isExternal: false
  name: EndsWith(String,StringComparison)
  nameWithType: String.EndsWith(String,StringComparison)
  fullName: System.String.EndsWith(String,StringComparison)
- uid: System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)
  parent: System.String
  isExternal: false
  name: EndsWith(String,Boolean,CultureInfo)
  nameWithType: String.EndsWith(String,Boolean,CultureInfo)
  fullName: System.String.EndsWith(String,Boolean,CultureInfo)
- uid: System.String.Equals(System.Object)
  parent: System.String
  isExternal: false
  name: Equals(Object)
  nameWithType: String.Equals(Object)
  fullName: System.String.Equals(Object)
- uid: System.String.Equals(System.String)
  parent: System.String
  isExternal: false
  name: Equals(String)
  nameWithType: String.Equals(String)
  fullName: System.String.Equals(String)
- uid: System.String.Equals(System.String,System.String)
  parent: System.String
  isExternal: false
  name: Equals(String,String)
  nameWithType: String.Equals(String,String)
  fullName: System.String.Equals(String,String)
- uid: System.String.Equals(System.String,System.StringComparison)
  parent: System.String
  isExternal: false
  name: Equals(String,StringComparison)
  nameWithType: String.Equals(String,StringComparison)
  fullName: System.String.Equals(String,StringComparison)
- uid: System.String.Equals(System.String,System.String,System.StringComparison)
  parent: System.String
  isExternal: false
  name: Equals(String,String,StringComparison)
  nameWithType: String.Equals(String,String,StringComparison)
  fullName: System.String.Equals(String,String,StringComparison)
- uid: System.String.Format(System.String,System.Object)
  parent: System.String
  isExternal: false
  name: Format(String,Object)
  nameWithType: String.Format(String,Object)
  fullName: System.String.Format(String,Object)
- uid: System.String.Format(System.String,System.Object[])
  parent: System.String
  isExternal: false
  name: Format(String,Object[])
  nameWithType: String.Format(String,Object[])
  fullName: System.String.Format(String,Object[])
- uid: System.String.Format(System.IFormatProvider,System.String,System.Object[])
  parent: System.String
  isExternal: false
  name: Format(IFormatProvider,String,Object[])
  nameWithType: String.Format(IFormatProvider,String,Object[])
  fullName: System.String.Format(IFormatProvider,String,Object[])
- uid: System.IFormatProvider
  parent: System
  isExternal: false
  name: IFormatProvider
  nameWithType: IFormatProvider
  fullName: System.IFormatProvider
- uid: System.String.Format(System.String,System.Object,System.Object)
  parent: System.String
  isExternal: false
  name: Format(String,Object,Object)
  nameWithType: String.Format(String,Object,Object)
  fullName: System.String.Format(String,Object,Object)
- uid: System.String.Format(System.String,System.Object,System.Object,System.Object)
  parent: System.String
  isExternal: false
  name: Format(String,Object,Object,Object)
  nameWithType: String.Format(String,Object,Object,Object)
  fullName: System.String.Format(String,Object,Object,Object)
- uid: System.String.GetEnumerator
  parent: System.String
  isExternal: false
  name: GetEnumerator()
  nameWithType: String.GetEnumerator()
  fullName: System.String.GetEnumerator()
- uid: System.CharEnumerator
  parent: System
  isExternal: false
  name: CharEnumerator
  nameWithType: CharEnumerator
  fullName: System.CharEnumerator
- uid: System.String.GetHashCode
  parent: System.String
  isExternal: false
  name: GetHashCode()
  nameWithType: String.GetHashCode()
  fullName: System.String.GetHashCode()
- uid: System.String.GetTypeCode
  parent: System.String
  isExternal: false
  name: GetTypeCode()
  nameWithType: String.GetTypeCode()
  fullName: System.String.GetTypeCode()
- uid: System.TypeCode
  parent: System
  isExternal: false
  name: TypeCode
  nameWithType: TypeCode
  fullName: System.TypeCode
- uid: System.String.IndexOf(System.Char)
  parent: System.String
  isExternal: false
  name: IndexOf(Char)
  nameWithType: String.IndexOf(Char)
  fullName: System.String.IndexOf(Char)
- uid: System.String.IndexOf(System.String)
  parent: System.String
  isExternal: false
  name: IndexOf(String)
  nameWithType: String.IndexOf(String)
  fullName: System.String.IndexOf(String)
- uid: System.String.IndexOf(System.Char,System.Int32)
  parent: System.String
  isExternal: false
  name: IndexOf(Char,Int32)
  nameWithType: String.IndexOf(Char,Int32)
  fullName: System.String.IndexOf(Char,Int32)
- uid: System.String.IndexOf(System.String,System.Int32)
  parent: System.String
  isExternal: false
  name: IndexOf(String,Int32)
  nameWithType: String.IndexOf(String,Int32)
  fullName: System.String.IndexOf(String,Int32)
- uid: System.String.IndexOf(System.String,System.StringComparison)
  parent: System.String
  isExternal: false
  name: IndexOf(String,StringComparison)
  nameWithType: String.IndexOf(String,StringComparison)
  fullName: System.String.IndexOf(String,StringComparison)
- uid: System.String.IndexOf(System.Char,System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: IndexOf(Char,Int32,Int32)
  nameWithType: String.IndexOf(Char,Int32,Int32)
  fullName: System.String.IndexOf(Char,Int32,Int32)
- uid: System.String.IndexOf(System.String,System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: IndexOf(String,Int32,Int32)
  nameWithType: String.IndexOf(String,Int32,Int32)
  fullName: System.String.IndexOf(String,Int32,Int32)
- uid: System.String.IndexOf(System.String,System.Int32,System.StringComparison)
  parent: System.String
  isExternal: false
  name: IndexOf(String,Int32,StringComparison)
  nameWithType: String.IndexOf(String,Int32,StringComparison)
  fullName: System.String.IndexOf(String,Int32,StringComparison)
- uid: System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)
  parent: System.String
  isExternal: false
  name: IndexOf(String,Int32,Int32,StringComparison)
  nameWithType: String.IndexOf(String,Int32,Int32,StringComparison)
  fullName: System.String.IndexOf(String,Int32,Int32,StringComparison)
- uid: System.String.IndexOfAny(System.Char[])
  parent: System.String
  isExternal: false
  name: IndexOfAny(Char[])
  nameWithType: String.IndexOfAny(Char[])
  fullName: System.String.IndexOfAny(Char[])
- uid: System.String.IndexOfAny(System.Char[],System.Int32)
  parent: System.String
  isExternal: false
  name: IndexOfAny(Char[],Int32)
  nameWithType: String.IndexOfAny(Char[],Int32)
  fullName: System.String.IndexOfAny(Char[],Int32)
- uid: System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: IndexOfAny(Char[],Int32,Int32)
  nameWithType: String.IndexOfAny(Char[],Int32,Int32)
  fullName: System.String.IndexOfAny(Char[],Int32,Int32)
- uid: System.String.Insert(System.Int32,System.String)
  parent: System.String
  isExternal: false
  name: Insert(Int32,String)
  nameWithType: String.Insert(Int32,String)
  fullName: System.String.Insert(Int32,String)
- uid: System.String.Intern(System.String)
  parent: System.String
  isExternal: false
  name: Intern(String)
  nameWithType: String.Intern(String)
  fullName: System.String.Intern(String)
- uid: System.String.IsInterned(System.String)
  parent: System.String
  isExternal: false
  name: IsInterned(String)
  nameWithType: String.IsInterned(String)
  fullName: System.String.IsInterned(String)
- uid: System.String.IsNormalized
  parent: System.String
  isExternal: false
  name: IsNormalized()
  nameWithType: String.IsNormalized()
  fullName: System.String.IsNormalized()
- uid: System.String.IsNormalized(System.Text.NormalizationForm)
  parent: System.String
  isExternal: false
  name: IsNormalized(NormalizationForm)
  nameWithType: String.IsNormalized(NormalizationForm)
  fullName: System.String.IsNormalized(NormalizationForm)
- uid: System.Text.NormalizationForm
  parent: System.Text
  isExternal: false
  name: NormalizationForm
  nameWithType: NormalizationForm
  fullName: System.Text.NormalizationForm
- uid: System.String.IsNullOrEmpty(System.String)
  parent: System.String
  isExternal: false
  name: IsNullOrEmpty(String)
  nameWithType: String.IsNullOrEmpty(String)
  fullName: System.String.IsNullOrEmpty(String)
- uid: System.String.IsNullOrWhiteSpace(System.String)
  parent: System.String
  isExternal: false
  name: IsNullOrWhiteSpace(String)
  nameWithType: String.IsNullOrWhiteSpace(String)
  fullName: System.String.IsNullOrWhiteSpace(String)
- uid: System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})
  parent: System.String
  isExternal: false
  name: Join(String,IEnumerable<String>)
  nameWithType: String.Join(String,IEnumerable<String>)
  fullName: System.String.Join(String,IEnumerable<String>)
- uid: System.String.Join(System.String,System.Object[])
  parent: System.String
  isExternal: false
  name: Join(String,Object[])
  nameWithType: String.Join(String,Object[])
  fullName: System.String.Join(String,Object[])
- uid: System.String.Join(System.String,System.String[])
  parent: System.String
  isExternal: false
  name: Join(String,String[])
  nameWithType: String.Join(String,String[])
  fullName: System.String.Join(String,String[])
- uid: System.String.Join(System.String,System.String[],System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: Join(String,String[],Int32,Int32)
  nameWithType: String.Join(String,String[],Int32,Int32)
  fullName: System.String.Join(String,String[],Int32,Int32)
- uid: System.String.Join``1(System.String,System.Collections.Generic.IEnumerable`1)
  parent: System.String
  isExternal: false
  name: Join(String,IEnumerable<T>)
  nameWithType: String.Join(String,IEnumerable<T>)
  fullName: System.String.Join(String,IEnumerable<T>)
- uid: System.String.LastIndexOf(System.Char)
  parent: System.String
  isExternal: false
  name: LastIndexOf(Char)
  nameWithType: String.LastIndexOf(Char)
  fullName: System.String.LastIndexOf(Char)
- uid: System.String.LastIndexOf(System.String)
  parent: System.String
  isExternal: false
  name: LastIndexOf(String)
  nameWithType: String.LastIndexOf(String)
  fullName: System.String.LastIndexOf(String)
- uid: System.String.LastIndexOf(System.Char,System.Int32)
  parent: System.String
  isExternal: false
  name: LastIndexOf(Char,Int32)
  nameWithType: String.LastIndexOf(Char,Int32)
  fullName: System.String.LastIndexOf(Char,Int32)
- uid: System.String.LastIndexOf(System.String,System.Int32)
  parent: System.String
  isExternal: false
  name: LastIndexOf(String,Int32)
  nameWithType: String.LastIndexOf(String,Int32)
  fullName: System.String.LastIndexOf(String,Int32)
- uid: System.String.LastIndexOf(System.String,System.StringComparison)
  parent: System.String
  isExternal: false
  name: LastIndexOf(String,StringComparison)
  nameWithType: String.LastIndexOf(String,StringComparison)
  fullName: System.String.LastIndexOf(String,StringComparison)
- uid: System.String.LastIndexOf(System.Char,System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: LastIndexOf(Char,Int32,Int32)
  nameWithType: String.LastIndexOf(Char,Int32,Int32)
  fullName: System.String.LastIndexOf(Char,Int32,Int32)
- uid: System.String.LastIndexOf(System.String,System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: LastIndexOf(String,Int32,Int32)
  nameWithType: String.LastIndexOf(String,Int32,Int32)
  fullName: System.String.LastIndexOf(String,Int32,Int32)
- uid: System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)
  parent: System.String
  isExternal: false
  name: LastIndexOf(String,Int32,StringComparison)
  nameWithType: String.LastIndexOf(String,Int32,StringComparison)
  fullName: System.String.LastIndexOf(String,Int32,StringComparison)
- uid: System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)
  parent: System.String
  isExternal: false
  name: LastIndexOf(String,Int32,Int32,StringComparison)
  nameWithType: String.LastIndexOf(String,Int32,Int32,StringComparison)
  fullName: System.String.LastIndexOf(String,Int32,Int32,StringComparison)
- uid: System.String.LastIndexOfAny(System.Char[])
  parent: System.String
  isExternal: false
  name: LastIndexOfAny(Char[])
  nameWithType: String.LastIndexOfAny(Char[])
  fullName: System.String.LastIndexOfAny(Char[])
- uid: System.String.LastIndexOfAny(System.Char[],System.Int32)
  parent: System.String
  isExternal: false
  name: LastIndexOfAny(Char[],Int32)
  nameWithType: String.LastIndexOfAny(Char[],Int32)
  fullName: System.String.LastIndexOfAny(Char[],Int32)
- uid: System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: LastIndexOfAny(Char[],Int32,Int32)
  nameWithType: String.LastIndexOfAny(Char[],Int32,Int32)
  fullName: System.String.LastIndexOfAny(Char[],Int32,Int32)
- uid: System.String.Length
  parent: System.String
  isExternal: false
  name: Length
  nameWithType: String.Length
  fullName: System.String.Length
- uid: System.String.Normalize
  parent: System.String
  isExternal: false
  name: Normalize()
  nameWithType: String.Normalize()
  fullName: System.String.Normalize()
- uid: System.String.Normalize(System.Text.NormalizationForm)
  parent: System.String
  isExternal: false
  name: Normalize(NormalizationForm)
  nameWithType: String.Normalize(NormalizationForm)
  fullName: System.String.Normalize(NormalizationForm)
- uid: System.String.op_Equality(System.String,System.String)
  parent: System.String
  isExternal: false
  name: op_Equality(String,String)
  nameWithType: String.op_Equality(String,String)
  fullName: System.String.op_Equality(String,String)
- uid: System.String.op_Inequality(System.String,System.String)
  parent: System.String
  isExternal: false
  name: op_Inequality(String,String)
  nameWithType: String.op_Inequality(String,String)
  fullName: System.String.op_Inequality(String,String)
- uid: System.String.PadLeft(System.Int32)
  parent: System.String
  isExternal: false
  name: PadLeft(Int32)
  nameWithType: String.PadLeft(Int32)
  fullName: System.String.PadLeft(Int32)
- uid: System.String.PadLeft(System.Int32,System.Char)
  parent: System.String
  isExternal: false
  name: PadLeft(Int32,Char)
  nameWithType: String.PadLeft(Int32,Char)
  fullName: System.String.PadLeft(Int32,Char)
- uid: System.String.PadRight(System.Int32)
  parent: System.String
  isExternal: false
  name: PadRight(Int32)
  nameWithType: String.PadRight(Int32)
  fullName: System.String.PadRight(Int32)
- uid: System.String.PadRight(System.Int32,System.Char)
  parent: System.String
  isExternal: false
  name: PadRight(Int32,Char)
  nameWithType: String.PadRight(Int32,Char)
  fullName: System.String.PadRight(Int32,Char)
- uid: System.String.Remove(System.Int32)
  parent: System.String
  isExternal: false
  name: Remove(Int32)
  nameWithType: String.Remove(Int32)
  fullName: System.String.Remove(Int32)
- uid: System.String.Remove(System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: Remove(Int32,Int32)
  nameWithType: String.Remove(Int32,Int32)
  fullName: System.String.Remove(Int32,Int32)
- uid: System.String.Replace(System.Char,System.Char)
  parent: System.String
  isExternal: false
  name: Replace(Char,Char)
  nameWithType: String.Replace(Char,Char)
  fullName: System.String.Replace(Char,Char)
- uid: System.String.Replace(System.String,System.String)
  parent: System.String
  isExternal: false
  name: Replace(String,String)
  nameWithType: String.Replace(String,String)
  fullName: System.String.Replace(String,String)
- uid: System.String.Split(System.Char[])
  parent: System.String
  isExternal: false
  name: Split(Char[])
  nameWithType: String.Split(Char[])
  fullName: System.String.Split(Char[])
- uid: System.String.Split(System.Char[],System.Int32)
  parent: System.String
  isExternal: false
  name: Split(Char[],Int32)
  nameWithType: String.Split(Char[],Int32)
  fullName: System.String.Split(Char[],Int32)
- uid: System.String.Split(System.Char[],System.StringSplitOptions)
  parent: System.String
  isExternal: false
  name: Split(Char[],StringSplitOptions)
  nameWithType: String.Split(Char[],StringSplitOptions)
  fullName: System.String.Split(Char[],StringSplitOptions)
- uid: System.StringSplitOptions
  parent: System
  isExternal: false
  name: StringSplitOptions
  nameWithType: StringSplitOptions
  fullName: System.StringSplitOptions
- uid: System.String.Split(System.String[],System.StringSplitOptions)
  parent: System.String
  isExternal: false
  name: Split(String[],StringSplitOptions)
  nameWithType: String.Split(String[],StringSplitOptions)
  fullName: System.String.Split(String[],StringSplitOptions)
- uid: System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)
  parent: System.String
  isExternal: false
  name: Split(Char[],Int32,StringSplitOptions)
  nameWithType: String.Split(Char[],Int32,StringSplitOptions)
  fullName: System.String.Split(Char[],Int32,StringSplitOptions)
- uid: System.String.Split(System.String[],System.Int32,System.StringSplitOptions)
  parent: System.String
  isExternal: false
  name: Split(String[],Int32,StringSplitOptions)
  nameWithType: String.Split(String[],Int32,StringSplitOptions)
  fullName: System.String.Split(String[],Int32,StringSplitOptions)
- uid: System.String.StartsWith(System.String)
  parent: System.String
  isExternal: false
  name: StartsWith(String)
  nameWithType: String.StartsWith(String)
  fullName: System.String.StartsWith(String)
- uid: System.String.StartsWith(System.String,System.StringComparison)
  parent: System.String
  isExternal: false
  name: StartsWith(String,StringComparison)
  nameWithType: String.StartsWith(String,StringComparison)
  fullName: System.String.StartsWith(String,StringComparison)
- uid: System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)
  parent: System.String
  isExternal: false
  name: StartsWith(String,Boolean,CultureInfo)
  nameWithType: String.StartsWith(String,Boolean,CultureInfo)
  fullName: System.String.StartsWith(String,Boolean,CultureInfo)
- uid: System.String.Substring(System.Int32)
  parent: System.String
  isExternal: false
  name: Substring(Int32)
  nameWithType: String.Substring(Int32)
  fullName: System.String.Substring(Int32)
- uid: System.String.Substring(System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: Substring(Int32,Int32)
  nameWithType: String.Substring(Int32,Int32)
  fullName: System.String.Substring(Int32,Int32)
- uid: System.String.System#Collections#Generic#IEnumerable{System#Char}#GetEnumerator
  parent: System.String
  isExternal: false
  name: System.Collections.Generic.IEnumerable()
  nameWithType: String.System.Collections.Generic.IEnumerable()
  fullName: System.String.System.Collections.Generic.IEnumerable()
- uid: System.Collections.Generic.IEnumerator{System.Char}
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerator<Char>
  nameWithType: IEnumerator<Char>
  fullName: System.Collections.Generic.IEnumerator<System.Char>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerator`1
    name: IEnumerator
    nameWithType: IEnumerator
    fullName: IEnumerator<System.Char>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Char
    name: Char
    nameWithType: Char
    fullName: Char
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.String.System#Collections#IEnumerable#GetEnumerator
  parent: System.String
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: String.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.String.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: false
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.String.System#IConvertible#ToBoolean(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToBoolean(IFormatProvider)
  nameWithType: String.System.IConvertible.ToBoolean(IFormatProvider)
  fullName: System.String.System.IConvertible.ToBoolean(IFormatProvider)
- uid: System.String.System#IConvertible#ToByte(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToByte(IFormatProvider)
  nameWithType: String.System.IConvertible.ToByte(IFormatProvider)
  fullName: System.String.System.IConvertible.ToByte(IFormatProvider)
- uid: System.Byte
  parent: System
  isExternal: false
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.String.System#IConvertible#ToChar(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToChar(IFormatProvider)
  nameWithType: String.System.IConvertible.ToChar(IFormatProvider)
  fullName: System.String.System.IConvertible.ToChar(IFormatProvider)
- uid: System.String.System#IConvertible#ToDateTime(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToDateTime(IFormatProvider)
  nameWithType: String.System.IConvertible.ToDateTime(IFormatProvider)
  fullName: System.String.System.IConvertible.ToDateTime(IFormatProvider)
- uid: System.DateTime
  parent: System
  isExternal: false
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.String.System#IConvertible#ToDecimal(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToDecimal(IFormatProvider)
  nameWithType: String.System.IConvertible.ToDecimal(IFormatProvider)
  fullName: System.String.System.IConvertible.ToDecimal(IFormatProvider)
- uid: System.Decimal
  parent: System
  isExternal: false
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: System.String.System#IConvertible#ToDouble(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToDouble(IFormatProvider)
  nameWithType: String.System.IConvertible.ToDouble(IFormatProvider)
  fullName: System.String.System.IConvertible.ToDouble(IFormatProvider)
- uid: System.Double
  parent: System
  isExternal: false
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.String.System#IConvertible#ToInt16(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToInt16(IFormatProvider)
  nameWithType: String.System.IConvertible.ToInt16(IFormatProvider)
  fullName: System.String.System.IConvertible.ToInt16(IFormatProvider)
- uid: System.Int16
  parent: System
  isExternal: false
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.String.System#IConvertible#ToInt32(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToInt32(IFormatProvider)
  nameWithType: String.System.IConvertible.ToInt32(IFormatProvider)
  fullName: System.String.System.IConvertible.ToInt32(IFormatProvider)
- uid: System.String.System#IConvertible#ToInt64(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToInt64(IFormatProvider)
  nameWithType: String.System.IConvertible.ToInt64(IFormatProvider)
  fullName: System.String.System.IConvertible.ToInt64(IFormatProvider)
- uid: System.Int64
  parent: System
  isExternal: false
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.String.System#IConvertible#ToSByte(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToSByte(IFormatProvider)
  nameWithType: String.System.IConvertible.ToSByte(IFormatProvider)
  fullName: System.String.System.IConvertible.ToSByte(IFormatProvider)
- uid: System.SByte
  parent: System
  isExternal: false
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.String.System#IConvertible#ToSingle(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToSingle(IFormatProvider)
  nameWithType: String.System.IConvertible.ToSingle(IFormatProvider)
  fullName: System.String.System.IConvertible.ToSingle(IFormatProvider)
- uid: System.Single
  parent: System
  isExternal: false
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToType(Type,IFormatProvider)
  nameWithType: String.System.IConvertible.ToType(Type,IFormatProvider)
  fullName: System.String.System.IConvertible.ToType(Type,IFormatProvider)
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.String.System#IConvertible#ToUInt16(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToUInt16(IFormatProvider)
  nameWithType: String.System.IConvertible.ToUInt16(IFormatProvider)
  fullName: System.String.System.IConvertible.ToUInt16(IFormatProvider)
- uid: System.UInt16
  parent: System
  isExternal: false
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.String.System#IConvertible#ToUInt32(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToUInt32(IFormatProvider)
  nameWithType: String.System.IConvertible.ToUInt32(IFormatProvider)
  fullName: System.String.System.IConvertible.ToUInt32(IFormatProvider)
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.String.System#IConvertible#ToUInt64(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToUInt64(IFormatProvider)
  nameWithType: String.System.IConvertible.ToUInt64(IFormatProvider)
  fullName: System.String.System.IConvertible.ToUInt64(IFormatProvider)
- uid: System.UInt64
  parent: System
  isExternal: false
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.String.ToCharArray
  parent: System.String
  isExternal: false
  name: ToCharArray()
  nameWithType: String.ToCharArray()
  fullName: System.String.ToCharArray()
- uid: System.String.ToCharArray(System.Int32,System.Int32)
  parent: System.String
  isExternal: false
  name: ToCharArray(Int32,Int32)
  nameWithType: String.ToCharArray(Int32,Int32)
  fullName: System.String.ToCharArray(Int32,Int32)
- uid: System.String.ToLower
  parent: System.String
  isExternal: false
  name: ToLower()
  nameWithType: String.ToLower()
  fullName: System.String.ToLower()
- uid: System.String.ToLower(System.Globalization.CultureInfo)
  parent: System.String
  isExternal: false
  name: ToLower(CultureInfo)
  nameWithType: String.ToLower(CultureInfo)
  fullName: System.String.ToLower(CultureInfo)
- uid: System.String.ToLowerInvariant
  parent: System.String
  isExternal: false
  name: ToLowerInvariant()
  nameWithType: String.ToLowerInvariant()
  fullName: System.String.ToLowerInvariant()
- uid: System.String.ToString
  parent: System.String
  isExternal: false
  name: ToString()
  nameWithType: String.ToString()
  fullName: System.String.ToString()
- uid: System.String.ToString(System.IFormatProvider)
  parent: System.String
  isExternal: false
  name: ToString(IFormatProvider)
  nameWithType: String.ToString(IFormatProvider)
  fullName: System.String.ToString(IFormatProvider)
- uid: System.String.ToUpper
  parent: System.String
  isExternal: false
  name: ToUpper()
  nameWithType: String.ToUpper()
  fullName: System.String.ToUpper()
- uid: System.String.ToUpper(System.Globalization.CultureInfo)
  parent: System.String
  isExternal: false
  name: ToUpper(CultureInfo)
  nameWithType: String.ToUpper(CultureInfo)
  fullName: System.String.ToUpper(CultureInfo)
- uid: System.String.ToUpperInvariant
  parent: System.String
  isExternal: false
  name: ToUpperInvariant()
  nameWithType: String.ToUpperInvariant()
  fullName: System.String.ToUpperInvariant()
- uid: System.String.Trim
  parent: System.String
  isExternal: false
  name: Trim()
  nameWithType: String.Trim()
  fullName: System.String.Trim()
- uid: System.String.Trim(System.Char[])
  parent: System.String
  isExternal: false
  name: Trim(Char[])
  nameWithType: String.Trim(Char[])
  fullName: System.String.Trim(Char[])
- uid: System.String.TrimEnd(System.Char[])
  parent: System.String
  isExternal: false
  name: TrimEnd(Char[])
  nameWithType: String.TrimEnd(Char[])
  fullName: System.String.TrimEnd(Char[])
- uid: System.String.TrimStart(System.Char[])
  parent: System.String
  isExternal: false
  name: TrimStart(Char[])
  nameWithType: String.TrimStart(Char[])
  fullName: System.String.TrimStart(Char[])
- uid: System.String.#ctor*
  parent: System.String
  isExternal: false
  name: String
  nameWithType: String.String
- uid: System.String.Chars*
  parent: System.String
  isExternal: false
  name: Chars
  nameWithType: String.Chars
- uid: System.String.Clone*
  parent: System.String
  isExternal: false
  name: Clone
  nameWithType: String.Clone
- uid: System.String.Compare*
  parent: System.String
  isExternal: false
  name: Compare
  nameWithType: String.Compare
- uid: System.String.CompareOrdinal*
  parent: System.String
  isExternal: false
  name: CompareOrdinal
  nameWithType: String.CompareOrdinal
- uid: System.String.CompareTo*
  parent: System.String
  isExternal: false
  name: CompareTo
  nameWithType: String.CompareTo
- uid: System.String.Concat*
  parent: System.String
  isExternal: false
  name: Concat
  nameWithType: String.Concat
- uid: System.String.Concat<T>*
  parent: System.String
  isExternal: false
  name: Concat<T>
  nameWithType: String.Concat<T>
- uid: System.String.Contains*
  parent: System.String
  isExternal: false
  name: Contains
  nameWithType: String.Contains
- uid: System.String.Copy*
  parent: System.String
  isExternal: false
  name: Copy
  nameWithType: String.Copy
- uid: System.String.CopyTo*
  parent: System.String
  isExternal: false
  name: CopyTo
  nameWithType: String.CopyTo
- uid: System.String.EndsWith*
  parent: System.String
  isExternal: false
  name: EndsWith
  nameWithType: String.EndsWith
- uid: System.String.Equals*
  parent: System.String
  isExternal: false
  name: Equals
  nameWithType: String.Equals
- uid: System.String.Format*
  parent: System.String
  isExternal: false
  name: Format
  nameWithType: String.Format
- uid: System.String.GetEnumerator*
  parent: System.String
  isExternal: false
  name: GetEnumerator
  nameWithType: String.GetEnumerator
- uid: System.String.GetHashCode*
  parent: System.String
  isExternal: false
  name: GetHashCode
  nameWithType: String.GetHashCode
- uid: System.String.GetTypeCode*
  parent: System.String
  isExternal: false
  name: GetTypeCode
  nameWithType: String.GetTypeCode
- uid: System.String.IndexOf*
  parent: System.String
  isExternal: false
  name: IndexOf
  nameWithType: String.IndexOf
- uid: System.String.IndexOfAny*
  parent: System.String
  isExternal: false
  name: IndexOfAny
  nameWithType: String.IndexOfAny
- uid: System.String.Insert*
  parent: System.String
  isExternal: false
  name: Insert
  nameWithType: String.Insert
- uid: System.String.Intern*
  parent: System.String
  isExternal: false
  name: Intern
  nameWithType: String.Intern
- uid: System.String.IsInterned*
  parent: System.String
  isExternal: false
  name: IsInterned
  nameWithType: String.IsInterned
- uid: System.String.IsNormalized*
  parent: System.String
  isExternal: false
  name: IsNormalized
  nameWithType: String.IsNormalized
- uid: System.String.IsNullOrEmpty*
  parent: System.String
  isExternal: false
  name: IsNullOrEmpty
  nameWithType: String.IsNullOrEmpty
- uid: System.String.IsNullOrWhiteSpace*
  parent: System.String
  isExternal: false
  name: IsNullOrWhiteSpace
  nameWithType: String.IsNullOrWhiteSpace
- uid: System.String.Join*
  parent: System.String
  isExternal: false
  name: Join
  nameWithType: String.Join
- uid: System.String.Join<T>*
  parent: System.String
  isExternal: false
  name: Join<T>
  nameWithType: String.Join<T>
- uid: System.String.LastIndexOf*
  parent: System.String
  isExternal: false
  name: LastIndexOf
  nameWithType: String.LastIndexOf
- uid: System.String.LastIndexOfAny*
  parent: System.String
  isExternal: false
  name: LastIndexOfAny
  nameWithType: String.LastIndexOfAny
- uid: System.String.Length*
  parent: System.String
  isExternal: false
  name: Length
  nameWithType: String.Length
- uid: System.String.Normalize*
  parent: System.String
  isExternal: false
  name: Normalize
  nameWithType: String.Normalize
- uid: System.String.op_Equality*
  parent: System.String
  isExternal: false
  name: op_Equality
  nameWithType: String.op_Equality
- uid: System.String.op_Inequality*
  parent: System.String
  isExternal: false
  name: op_Inequality
  nameWithType: String.op_Inequality
- uid: System.String.PadLeft*
  parent: System.String
  isExternal: false
  name: PadLeft
  nameWithType: String.PadLeft
- uid: System.String.PadRight*
  parent: System.String
  isExternal: false
  name: PadRight
  nameWithType: String.PadRight
- uid: System.String.Remove*
  parent: System.String
  isExternal: false
  name: Remove
  nameWithType: String.Remove
- uid: System.String.Replace*
  parent: System.String
  isExternal: false
  name: Replace
  nameWithType: String.Replace
- uid: System.String.Split*
  parent: System.String
  isExternal: false
  name: Split
  nameWithType: String.Split
- uid: System.String.StartsWith*
  parent: System.String
  isExternal: false
  name: StartsWith
  nameWithType: String.StartsWith
- uid: System.String.Substring*
  parent: System.String
  isExternal: false
  name: Substring
  nameWithType: String.Substring
- uid: System.String.System#Collections#Generic#IEnumerable<System#Char>#GetEnumerator*
  parent: System.String
  isExternal: false
  name: System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator
  nameWithType: String.System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator
- uid: System.String.System#Collections#IEnumerable#GetEnumerator*
  parent: System.String
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: String.System.Collections.IEnumerable.GetEnumerator
- uid: System.String.System#IConvertible#ToBoolean*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToBoolean
  nameWithType: String.System.IConvertible.ToBoolean
- uid: System.String.System#IConvertible#ToByte*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToByte
  nameWithType: String.System.IConvertible.ToByte
- uid: System.String.System#IConvertible#ToChar*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToChar
  nameWithType: String.System.IConvertible.ToChar
- uid: System.String.System#IConvertible#ToDateTime*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToDateTime
  nameWithType: String.System.IConvertible.ToDateTime
- uid: System.String.System#IConvertible#ToDecimal*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToDecimal
  nameWithType: String.System.IConvertible.ToDecimal
- uid: System.String.System#IConvertible#ToDouble*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToDouble
  nameWithType: String.System.IConvertible.ToDouble
- uid: System.String.System#IConvertible#ToInt16*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToInt16
  nameWithType: String.System.IConvertible.ToInt16
- uid: System.String.System#IConvertible#ToInt32*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToInt32
  nameWithType: String.System.IConvertible.ToInt32
- uid: System.String.System#IConvertible#ToInt64*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToInt64
  nameWithType: String.System.IConvertible.ToInt64
- uid: System.String.System#IConvertible#ToSByte*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToSByte
  nameWithType: String.System.IConvertible.ToSByte
- uid: System.String.System#IConvertible#ToSingle*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToSingle
  nameWithType: String.System.IConvertible.ToSingle
- uid: System.String.System#IConvertible#ToType*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToType
  nameWithType: String.System.IConvertible.ToType
- uid: System.String.System#IConvertible#ToUInt16*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToUInt16
  nameWithType: String.System.IConvertible.ToUInt16
- uid: System.String.System#IConvertible#ToUInt32*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToUInt32
  nameWithType: String.System.IConvertible.ToUInt32
- uid: System.String.System#IConvertible#ToUInt64*
  parent: System.String
  isExternal: false
  name: System.IConvertible.ToUInt64
  nameWithType: String.System.IConvertible.ToUInt64
- uid: System.String.ToCharArray*
  parent: System.String
  isExternal: false
  name: ToCharArray
  nameWithType: String.ToCharArray
- uid: System.String.ToLower*
  parent: System.String
  isExternal: false
  name: ToLower
  nameWithType: String.ToLower
- uid: System.String.ToLowerInvariant*
  parent: System.String
  isExternal: false
  name: ToLowerInvariant
  nameWithType: String.ToLowerInvariant
- uid: System.String.ToString*
  parent: System.String
  isExternal: false
  name: ToString
  nameWithType: String.ToString
- uid: System.String.ToUpper*
  parent: System.String
  isExternal: false
  name: ToUpper
  nameWithType: String.ToUpper
- uid: System.String.ToUpperInvariant*
  parent: System.String
  isExternal: false
  name: ToUpperInvariant
  nameWithType: String.ToUpperInvariant
- uid: System.String.Trim*
  parent: System.String
  isExternal: false
  name: Trim
  nameWithType: String.Trim
- uid: System.String.TrimEnd*
  parent: System.String
  isExternal: false
  name: TrimEnd
  nameWithType: String.TrimEnd
- uid: System.String.TrimStart*
  parent: System.String
  isExternal: false
  name: TrimStart
  nameWithType: String.TrimStart
